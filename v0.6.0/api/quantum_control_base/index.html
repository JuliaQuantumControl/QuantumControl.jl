<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>QuantumControlBase · QuantumControl.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliaquantumcontrol.github.io/QuantumControl.jl/api/quantum_control_base/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QuantumControl.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../glossary/">Glossary</a></li><li><a class="tocitem" href="../../manual/">User Manual</a></li><li><a class="tocitem" href="../../howto/">Howto</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/">List of Examples</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../quantum_control/">QuantumControl</a></li><li><a class="tocitem" href="../quantum_control_reference/">Local Submodules</a></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox" checked/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Subpackages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../quantum_propagators/">QuantumPropagators</a></li><li class="is-active"><a class="tocitem" href>QuantumControlBase</a><ul class="internal"><li><a class="tocitem" href="#Package-Index"><span>Package Index</span></a></li><li><a class="tocitem" href="#QuantumControlBaseAPI"><span><code>QuantumControlBase</code></span></a></li></ul></li><li><a class="tocitem" href="../krotov/">Krotov</a></li><li><a class="tocitem" href="../grape/">GRAPE</a></li></ul></li><li><a class="tocitem" href="../quantum_control_index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li><a class="is-disabled">Subpackages</a></li><li class="is-active"><a href>QuantumControlBase</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>QuantumControlBase</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/master/docs/generate_api.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="QuantumControlBasePackage"><a class="docs-heading-anchor" href="#QuantumControlBasePackage">QuantumControlBase Package</a><a id="QuantumControlBasePackage-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBasePackage" title="Permalink"></a></h1><h2 id="Package-Index"><a class="docs-heading-anchor" href="#Package-Index">Package Index</a><a id="Package-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Package-Index" title="Permalink"></a></h2><p><span>$\gdef\tgt{\text{tgt}}$</span> <span>$\gdef\tr{\operatorname{tr}}$</span> <span>$\gdef\Re{\operatorname{Re}}$</span> <span>$\gdef\Im{\operatorname{Im}}$</span></p><ul><li><a href="#QuantumControlBase.ControlProblem"><code>QuantumControlBase.ControlProblem</code></a></li><li><a href="#QuantumControlBase.Objective"><code>QuantumControlBase.Objective</code></a></li><li><a href="#QuantumControlBase.chain_infohooks"><code>QuantumControlBase.chain_infohooks</code></a></li><li><a href="#QuantumControlBase.get_control_deriv"><code>QuantumControlBase.get_control_deriv</code></a></li><li><a href="#QuantumControlBase.get_control_derivs"><code>QuantumControlBase.get_control_derivs</code></a></li><li><a href="#QuantumControlBase.make_chi"><code>QuantumControlBase.make_chi</code></a></li><li><a href="#QuantumControlBase.make_grad_J_a"><code>QuantumControlBase.make_grad_J_a</code></a></li><li><a href="#QuantumControlBase.optimize"><code>QuantumControlBase.optimize</code></a></li><li><a href="#QuantumControlBase.propagate_objective"><code>QuantumControlBase.propagate_objective</code></a></li><li><a href="#QuantumControlBase.propagate_objectives"><code>QuantumControlBase.propagate_objectives</code></a></li><li><a href="#QuantumControlBase.@threadsif"><code>QuantumControlBase.@threadsif</code></a></li></ul><h2 id="QuantumControlBaseAPI"><a class="docs-heading-anchor" href="#QuantumControlBaseAPI"><code>QuantumControlBase</code></a><a id="QuantumControlBaseAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBaseAPI" title="Permalink"></a></h2><p>Public Members:</p><ul><li><a href="#QuantumControlBase.ControlProblem"><code>ControlProblem</code></a></li><li><a href="#QuantumControlBase.Objective"><code>Objective</code></a></li><li><a href="#QuantumControlBase.optimize"><code>optimize</code></a></li><li><a href="#QuantumControlBase.propagate_objective"><code>propagate_objective</code></a></li><li><a href="#QuantumControlBase.propagate_objectives"><code>propagate_objectives</code></a></li></ul><p>Private Members:</p><ul><li><a href="#QuantumControlBase.get_control_derivs"><code>get_control_derivs</code></a></li><li><a href="#QuantumControlBase.@threadsif"><code>@threadsif</code></a></li><li><a href="#QuantumControlBase.get_control_deriv"><code>get_control_deriv</code></a></li><li><a href="#QuantumControlBase.make_chi"><code>make_chi</code></a></li><li><a href="#QuantumControlBase.make_grad_J_a"><code>make_grad_J_a</code></a></li><li><a href="#QuantumControlBase.chain_infohooks"><code>chain_infohooks</code></a></li></ul><h3 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.ControlProblem" href="#QuantumControlBase.ControlProblem"><code>QuantumControlBase.ControlProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A full control problem with multiple objectives.</p><pre><code class="language-julia hljs">ControlProblem(;
   objectives,
   tlist,
   kwargs...
)</code></pre><p>Note that the control problem can only be instantiated via keyword arguments.</p><p>The <code>objectives</code> are a list of <a href="#QuantumControlBase.Objective"><code>Objective</code></a> instances, each defining an initial state and a dynamical generator for the evolution of that state. Usually, the objective will also include a target state (see <a href="#QuantumControlBase.Objective"><code>Objective</code></a>) and possibly a weight.</p><p>The <code>tlist</code> is the time grid on which the time evolution of the initial states of each objective should be propagated.</p><p>The remaining <code>kwargs</code> are keyword arguments that are passed directly to the optimal control method. These typically include e.g. the optimization functional.</p><p>The control problem is solved by finding a set of controls that simultaneously fulfill all objectives.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Objective" href="#QuantumControlBase.Objective"><code>QuantumControlBase.Objective</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Optimization objective.</p><pre><code class="language-julia hljs">Objective(;
    initial_state,
    generator,
    target_state=nothing,
    weight=1.0,
    kwargs...
)</code></pre><p>describes an optimization objective that is tracked by the time evolution of the given <code>initial_state</code> under the given <code>generator</code>, e.g., a time-dependent Hamiltonian or Liouvillian. Each objective represents a single propagated state on which an optimization functional may depend.</p><p>The most common control problems in quantum control (state-to-state, gate optimization) require that the <code>initial_state</code> evolves into a <code>target_state</code>, which should be given as a keyword argument.</p><p>An optimization functional usually depends on <em>multiple</em> forward-propagated states (i.e., multiple <code>objectives</code>). Sometimes, it is useful to weight the contributions of different <code>objectives</code> relative to each other, see, e.g., Goerz <em>et al</em>., New J. Phys. 16, 055012 (2014). To this end, a <code>weight</code> can be attached to each <code>Objective</code> as an optional keyword argument.</p><p>Any other keyword arguments are available to a custom functional as properties of the <code>Objective</code> .</p><p>Note that the <code>Objective</code> can only be instantiated via keyword arguments, with <code>initial_state</code> and <code>generator</code> being the only two mandatory keyword arguments.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.optimize" href="#QuantumControlBase.optimize"><code>QuantumControlBase.optimize</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Optimize a quantum control problem.</p><pre><code class="language-julia hljs">result = optimize(problem; method=&lt;method&gt;, kwargs...)</code></pre><p>optimizes towards a solution of given <a href="#QuantumControlBase.ControlProblem"><code>problem</code></a> with the given optimization <code>method</code>. Any keyword argument temporarily overrides the corresponding keyword argument in <code>problem</code>.</p></div></section><section><div><pre><code class="language-julia hljs">result = optimize(problem; method=:krotov, kwargs...)</code></pre><p>optimizes the given control <a href="#QuantumControlBase.ControlProblem"><code>problem</code></a> using Krotov&#39;s method, returning a <a href="../krotov/#Krotov.KrotovResult"><code>KrotovResult</code></a>.</p><p>Keyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of <code>problem</code>.</p><p><strong>Required problem keyword arguments</strong></p><ul><li><code>J_T</code>: A function <code>J_T(ϕ, objectives)</code> that evaluates the final time functional from a list <code>ϕ</code> of forward-propagated states and <code>problem.objectives</code>.</li></ul><p><strong>Recommended problem keyword arguments</strong></p><ul><li><code>lambda_a=1.0</code>: The inverse Krotov step width λ_a for every pulse.</li><li><code>update_shape=(t-&gt;1.0)</code>: A function <code>S(t)</code> for the &quot;update shape&quot; that scales the update for every pulse</li></ul><p>If different controls require different <code>lambda_a</code> or <code>update_shape</code>, a dict <code>pulse_options</code> must be given instead of a global <code>lambda_a</code> and <code>update_shape</code>, see below.</p><p><strong>Optional problem keyword arguments</strong></p><p>The following keyword arguments are supported (with default values):</p><ul><li><p><code>pulse_options</code>: A dictionary that maps every control (as obtained by <a href="../quantum_propagators/#QuantumPropagators.Controls.get_controls"><code>get_controls</code></a> from the <code>problem.objectives</code>) to the following dict:</p><ul><li><code>:lambda_a</code>:  The value for inverse Krotov step width λₐ</li><li><code>:update_shape</code>: A function <code>S(t)</code> for the &quot;update shape&quot; that scales the Krotov pulse update.</li></ul><p>This overrides the global <code>lambda_a</code> and <code>update_shape</code> arguments.</p></li><li><p><code>chi</code>: A function <code>chi!(χ, ϕ, objectives)</code> what receives a list <code>ϕ</code> of the forward propagated states and must set <span>$|χₖ⟩ = -∂J_T/∂⟨ϕₖ|$</span>. If not given, it will be automatically determined from <code>J_T</code> via <a href="#QuantumControlBase.make_chi"><code>make_chi</code></a> with the default parameters.</p></li><li><p><code>sigma=nothing</code>: Function that calculate the second-order contribution. If not given, the first-order Krotov method is used.</p></li><li><p><code>iter_start=0</code>: the initial iteration number</p></li><li><p><code>iter_stop=5000</code>: the maximum iteration number</p></li><li><p><code>prop_method</code>/<code>fw_prop_method</code>/<code>bw_prop_method</code>: The propagation method to use for each objective, see below.</p></li><li><p><code>update_hook</code>: A function that receives the Krotov workspace, the iteration number, the list of updated pulses and the list of guess pulses as positional arguments. The function may mutate any of its arguments. This may be used e.g. to apply a spectral filter to the updated pulses, or to update propagation workspaces inside the Krotov workspace.</p></li><li><p><code>info_hook</code>: A function (or tuple of functions) that receives the same argumens as <code>update_hook</code>, in order to write information about the current iteration to the screen or to a file. The default <code>info_hook</code> prints a table with convergence information to the screen. Runs after <code>update_hook</code>. The <code>info_hook</code> function may return a tuple, which is stored in the list of <code>records</code> inside the <a href="../krotov/#Krotov.KrotovResult"><code>KrotovResult</code></a> object.</p></li><li><p><code>check_convergence</code>: a function to check whether convergence has been reached. Receives a <a href="../krotov/#Krotov.KrotovResult"><code>KrotovResult</code></a> object <code>result</code>, and should set <code>result.converged</code> to <code>true</code> and <code>result.message</code> to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with <code>∘</code>. The convergence check is performed after any calls to <code>update_hook</code> and <code>info_hook</code>.</p></li><li><p><code>verbose=false</code>: If <code>true</code>, print information during initialization</p></li></ul><p>The propagation method for the forward propagation of each objective is determined by the first available item of the following:</p><ul><li>a <code>fw_prop_method</code> keyword argument</li><li>a <code>prop_method</code> keyword argument</li><li>a property <code>fw_prop_method</code> of the objective</li><li>a property <code>prop_method</code> of the objective</li><li>the value <code>:auto</code></li></ul><p>The propagation method for the backword propagation is determined similarly, but with <code>bw_prop_method</code> instead of <code>fw_prop_method</code>.</p></div></section><section><div><pre><code class="language-julia hljs">result = optimize(problem; method=:GRAPE, kwargs...)</code></pre><p>optimizes the given control <a href="#QuantumControlBase.ControlProblem"><code>problem</code></a> via the GRAPE method, by minimizing the functional</p><p class="math-container">\[J(\{ϵ_{ln}\}) = J_T(\{|ϕ_k(T)⟩\}) + λ_a J_a(\{ϵ_{ln}\})\]</p><p>where the final time functional <span>$J_T$</span> depends explicitly on the forward-propagated states and the running cost <span>$J_a$</span> depends explicitly on pulse values <span>$ϵ_{nl}$</span> of the l&#39;th control discretized on the n&#39;th interval of the time grid.</p><p>Returns a <a href="../grape/#GRAPE.GrapeResult"><code>GrapeResult</code></a>.</p><p>Keyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of <code>problem</code>.</p><p><strong>Required problem keyword arguments</strong></p><ul><li><code>J_T</code>: A function <code>J_T(ϕ, objectives; τ=τ)</code> that evaluates the final time functional from a vector <code>ϕ</code> of forward-propagated states and <code>problem.objectives</code>. For all <code>objectives</code> that define a <code>target_state</code>, the element <code>τₖ</code> of the vector <code>τ</code> will contain the overlap of the state <code>ϕₖ</code> with the <code>target_state</code> of the <code>k</code>&#39;th objective, or <code>NaN</code> otherwise.</li></ul><p><strong>Optional problem keyword arguments</strong></p><ul><li><p><code>chi</code>: A function <code>chi!(χ, ϕ, objectives)</code> what receives a list <code>ϕ</code> of the forward propagated states and must set <span>$|χₖ⟩ = -∂J_T/∂⟨ϕₖ|$</span>. If not given, it will be automatically determined from <code>J_T</code> via <a href="#QuantumControlBase.make_chi"><code>make_chi</code></a> with the default parameters.</p></li><li><p><code>J_a</code>: A function <code>J_a(pulsevals, tlist)</code> that evaluates running costs over the pulse values, where <code>pulsevals</code> are the vectorized values <span>$ϵ_{nl}$</span>. If not given, the optimization will not include a running cost.</p></li><li><p><code>gradient_method=:gradgen</code>: One of <code>:gradgen</code> (default) or <code>:taylor</code>. With <code>gradient_method=:gradgen</code>, the gradient is calculated using <a href="https://github.com/JuliaQuantumControl/QuantumGradientGenerators.jl">QuantumGradientGenerators</a>. With <code>gradient_method=:taylor</code>, it is evaluated via a Taylor series, see Eq. (20) in Kuprov and Rogers,  J. Chem. Phys. 131, 234108 (2009).</p></li><li><p><code>taylor_grad_max_order=100</code>: If given with <code>gradient_method=:taylor</code>, the maximum number of terms in the Taylor series. If <code>taylor_grad_check_convergence=true</code> (default), if the Taylor series does not convergence within the given number of terms, throw an an error. With <code>taylor_grad_check_convergence=true</code>, this is the exact order of the Taylor series.</p></li><li><p><code>taylor_grad_tolerance=1e-16</code>: If given with <code>gradient_method=:taylor</code> and <code>taylor_grad_check_convergence=true</code>, stop the Taylor series when the norm of the term falls below the given tolerance. Ignored if <code>taylor_grad_check_convergence=false</code>.</p></li><li><p><code>taylor_grad_check_convergence=true</code>: If given as <code>true</code> (default), check the convergence after each term in the Taylor series an stop as soon as the norm of the term drops below the given number. If <code>false</code>, stop after exactly <code>taylor_grad_max_order</code> terms.</p></li><li><p><code>lambda_a=1</code>: A weight for the running cost <code>J_a</code>.</p></li><li><p><code>grad_J_a</code>: A function to calculate the gradient of <code>J_a</code>. If not given, it will be automatically determined.</p></li><li><p><code>upper_bound</code>: An upper bound for the value of any optimized control. Time-dependent upper bounds can be specified via <code>pulse_options</code>.</p></li><li><p><code>lower_bound</code>: A lower bound for the value of any optimized control. Time-dependent lower bounds can be specified via <code>pulse_options</code>.</p></li><li><p><code>pulse_options</code>: A dictionary that maps every control (as obtained by <a href="../quantum_propagators/#QuantumPropagators.Controls.get_controls"><code>get_controls</code></a> from the <code>problem.objectives</code>) to a dict with the following possible keys:</p><ul><li><code>:upper_bounds</code>: A vector of upper bound values, one for each intervals of the time grid. Values of <code>Inf</code> indicate an unconstrained upper bound for that time interval, respectively the global <code>upper_bound</code>, if given.</li><li><code>:lower_bounds</code>: A vector of lower bound values. Values of <code>-Inf</code> indicate an unconstrained lower bound for that time interval,</li></ul></li><li><p><code>update_hook</code>: Not implemented</p></li><li><p><code>info_hook</code>: A function (or tuple of functions) that receives the same arguments as <code>update_hook</code>, in order to write information about the current iteration to the screen or to a file. The default <code>info_hook</code> prints a table with convergence information to the screen. Runs after <code>update_hook</code>. The <code>info_hook</code> function may return a tuple, which is stored in the list of <code>records</code> inside the <a href="../grape/#GRAPE.GrapeResult"><code>GrapeResult</code></a> object.</p></li><li><p><code>check_convergence</code>: A function to check whether convergence has been reached. Receives a <a href="../grape/#GRAPE.GrapeResult"><code>GrapeResult</code></a> object <code>result</code>, and should set <code>result.converged</code> to <code>true</code> and <code>result.message</code> to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with <code>∘</code>. The convergence check is performed after any calls to <code>update_hook</code> and <code>info_hook</code>.</p></li><li><p><code>x_tol</code>: Parameter for Optim.jl</p></li><li><p><code>f_tol</code>: Parameter for Optim.jl</p></li><li><p><code>g_tol</code>: Parameter for Optim.jl</p></li><li><p><code>show_trace</code>: Parameter for Optim.jl</p></li><li><p><code>extended_trace</code>:  Parameter for Optim.jl</p></li><li><p><code>show_every</code>: Parameter for Optim.jl</p></li><li><p><code>allow_f_increases</code>: Parameter for Optim.jl</p></li><li><p><code>optimizer</code>: An optional Optim.jl optimizer (<code>Optim.AbstractOptimizer</code> instance). If not given, an <a href="https://github.com/Gnimuc/LBFGSB.jl">L-BFGS-B</a> optimizer will be used.</p></li><li><p><code>prop_method</code>/<code>fw_prop_method</code>/<code>bw_prop_method</code>: The propagation method to use for each objective, see below.</p></li><li><p><code>prop_method</code>/<code>fw_prop_method</code>/<code>grad_prop_method</code>: The propagation method to use for the extended gradient vector for each objective, see below.</p></li><li><p><code>verbose=false</code>: If <code>true</code>, print information during initialization</p></li></ul><p>The propagation method for the forward propagation of each objective is determined by the first available item of the following:</p><ul><li>a <code>fw_prop_method</code> keyword argument</li><li>a <code>prop_method</code> keyword argument</li><li>a property <code>fw_prop_method</code> of the objective</li><li>a property <code>prop_method</code> of the objective</li><li>the value <code>:auto</code></li></ul><p>The propagation method for the backward propagation is determined similarly, but with <code>bw_prop_method</code> instead of <code>fw_prop_method</code>. The propagation method for the backward propagation of the extended gradient vector for each objective is determined from <code>grad_prop_method</code>, <code>fw_prop_method</code>, <code>prop_method</code> in order of precedence.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.propagate_objective" href="#QuantumControlBase.propagate_objective"><code>QuantumControlBase.propagate_objective</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Propagate with the dynamical generator of a control objective.</p><pre><code class="language-julia hljs">propagate_objective(obj, tlist; method=:auto, initial_state=obj.initial_state,
                    kwargs...)</code></pre><p>propagates <code>initial_state</code> under the dynamics described by <code>obj.generator</code>.</p><p>The optional dict <code>control_map</code> may be given to replace the controls in <code>obj.generator</code> (as obtained by <a href="../quantum_propagators/#QuantumPropagators.Controls.get_controls"><code>get_controls</code></a>) with custom functions or vectors, e.g. with the controls resulting from optimization, see also <a href="../quantum_propagators/#QuantumPropagators.Controls.substitute"><code>substitute</code></a>.</p><p>If <code>obj</code> has a property/field <code>prop_method</code> or <code>fw_prop_method</code>, its value will be used as the default for <code>method</code> instead of :auto. An explicit keyword argument for <code>method</code> always overrides the default.</p><p>All other <code>kwargs</code> are forwarded to the underlying <a href="../quantum_propagators/#QuantumPropagators.propagate"><code>QuantumPropagators.propagate</code></a> method for <code>obj.initial_state</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.propagate_objectives" href="#QuantumControlBase.propagate_objectives"><code>QuantumControlBase.propagate_objectives</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Propagate multiple objectives in parallel.</p><pre><code class="language-julia hljs">result = propagate_objectives(objectives, tlist; use_threads=true, kwargs...)</code></pre><p>runs <a href="#QuantumControlBase.propagate_objective"><code>propagate_objective</code></a> for every objective in <code>objectives</code>, collects and returns a vector of results. The propagation happens in parallel if <code>use_threads=true</code> (default). All keyword parameters are passed to <a href="#QuantumControlBase.propagate_objective"><code>propagate_objective</code></a>, except that if <code>initial_state</code> is given, it must be a vector of initial states, one for each objective. Likewise, to pass pre-allocated storage arrays to <code>storage</code>, a vector of storage arrays must be passed. A simple <code>storage=true</code> will still work to return a vector of storage results.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.get_control_derivs" href="#QuantumControlBase.get_control_derivs"><code>QuantumControlBase.get_control_derivs</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get a vector of the derivatives of <code>generator</code> w.r.t. each control.</p><pre><code class="language-julia hljs">get_control_derivs(generator, controls)</code></pre><p>return as vector containing the derivative of <code>generator</code> with respect to each control in <code>controls</code>. The elements of the vector are either <code>nothing</code> if <code>generator</code> does not depend on that particular control, or a function <code>μ(α)</code> that evaluates the derivative for a particular value of the control, see <a href="#QuantumControlBase.get_control_deriv"><code>get_control_deriv</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.@threadsif" href="#QuantumControlBase.@threadsif"><code>QuantumControlBase.@threadsif</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Conditionally apply multi-threading to <code>for</code> loops.</p><p>This is a variation on <code>Base.Threads.@threads</code> that adds a run-time boolean flag to enable or disable threading. It is intended for <em>internal use</em> in packages building on <code>QuantumControlBase</code>.</p><p>Usage:</p><pre><code class="language-julia hljs">using QuantumControlBase: @threadsif

function optimize(objectives; use_threads=true)
    @threadsif use_threads for k = 1:length(objectives)
    # ...
    end
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.get_control_deriv" href="#QuantumControlBase.get_control_deriv"><code>QuantumControlBase.get_control_deriv</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get the derivative of the generator <span>$G$</span> w.r.t. the control <span>$ϵ(t)$</span>.</p><pre><code class="language-julia hljs">μ  = get_control_deriv(generator, control)</code></pre><p>returns <code>nothing</code> if the <code>generator</code> (Hamiltonian or Liouvillian) does not depend on <code>control</code>, or generator</p><p class="math-container">\[μ = \frac{∂G}{∂ϵ(t)}\]</p><p>otherwise. For linear control terms, <code>μ</code> will be a static operator, e.g. an <code>AbstractMatrix</code> or an <a href="../quantum_propagators/#QuantumPropagators.Generators.Operator"><code>Operator</code></a>. For non-linear controls, <code>μ</code> will be time-dependent, e.g. a <a href="../quantum_propagators/#QuantumPropagators.Generators.Generator"><code>Generator</code></a>. In either case, <a href="../quantum_propagators/#QuantumPropagators.Controls.evaluate"><code>evaluate</code></a> should be used to evaluate <code>μ</code> into a constant operator for particular values of the controls and a particular point in time.</p><p>For constant generators, e.g. an <a href="../quantum_propagators/#QuantumPropagators.Generators.Operator"><code>Operator</code></a>, the result is always <code>nothing</code>.</p></div></section><section><div><pre><code class="language-julia hljs">a = get_control_deriv(ampl, control)</code></pre><p>returns the derivative <span>$∂a_l(t)/∂ϵ_{l&#39;}(t)$</span> of the given amplitude <span>$a_l(\{ϵ_{l&#39;&#39;}(t)\}, t)$</span> with respect to the given control <span>$ϵ_{l&#39;}(t)$</span>. For &quot;trivial&quot; amplitudes, where <span>$a_l(t) ≡ ϵ_l(t)$</span>, the result with be either <code>1.0</code> or <code>0.0</code> (depending on whether <code>ampl ≡ control</code>). For non-trivial amplitudes, the result may be another amplitude that depends on the controls and potentially on time, but can be evaluated to a constant with <a href="../quantum_propagators/#QuantumPropagators.Controls.evaluate"><code>evaluate</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.make_chi" href="#QuantumControlBase.make_chi"><code>QuantumControlBase.make_chi</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return a function that evaluates <span>$|χ_k⟩ = -∂J_T/∂⟨ϕ_k|$</span>.</p><pre><code class="language-julia hljs">chi! = make_chi(
    J_T,
    objectives;
    force_zygote=false,
    via=(any(isnothing(obj.target_state) for obj in objectives) ? :phi : :tau),
    use_finite_differences=false
)</code></pre><p>creates a function <code>chi!(χ, ϕ, objectives; τ)</code> that sets the k&#39;th element of <code>χ</code> to <span>$|χ_k⟩ = -∂J_T/∂⟨ϕ_k|$</span>, where <span>$|ϕ_k⟩$</span> is the k&#39;th element of <code>ϕ</code>. These are the states used as the boundary condition for the backward propagation propagation in Krotov&#39;s method and GRAPE. Each <span>$|χₖ⟩$</span> is defined as a matrix calculus <a href="https://www.ekinakyurek.me/complex-derivatives-wirtinger/">Wirtinger derivative</a>,</p><p class="math-container">\[|χ_k(T)⟩ = -\frac{∂J_T}{∂⟨ϕ_k|} = -\frac{1}{2} ∇_{ϕ_k} J_T\,;\qquad
∇_{ϕ_k} J_T ≡ \frac{∂J_T}{\Re[ϕ_k]} + i \frac{∂J_T}{\Im[ϕ_k]}\,.\]</p><p>The function <code>J_T</code> must take a vector of states <code>ϕ</code> and a vector of <code>objectives</code> as positional parameters, and a vector <code>τ</code> as a keyword argument, see e.g. <code>J_T_sm</code>). If all objectives define a <code>target_state</code>, then <code>τ</code> will be the overlap of the states <code>ϕ</code> with those target states. The functional <code>J_T</code> may or may not use those overlaps.  Likewise, the resulting <code>chi!</code> may or may not use the keyword parameter <code>τ</code>.</p><p>For functionals where <span>$-∂J_T/∂⟨ϕ_k|$</span> is known analytically, that analytic derivative will be returned, e.g.,</p><ul><li><code>J_T_sm</code> → <code>chi_sm!</code>,</li><li><code>J_T_re</code> → <code>chi_re!</code>,</li><li><code>J_T_ss</code> → <code>chi_ss!</code>.</li></ul><p>Otherwise, or if <code>force_zygote=true</code> or <code>use_finite_differences=true</code>, the derivative to calculate <span>$|χ_k⟩$</span> will be evaluated automatically, via automatic differentiation with Zygote, or via finite differences (which primarily serves for testing the Zygote gradient).</p><p>When evaluating <span>$|χ_k⟩$</span> automatically, if <code>via=:phi</code> is given , <span>$|χ_k(T)⟩$</span> is calculated directly as defined a above from the gradient with respect to the states <span>$\{|ϕ_k(T)⟩\}$</span>. The resulting function <code>chi!</code> ignores any passed <code>τ</code> keyword argument.</p><p>If <code>via=:tau</code> is given instead, the functional <span>$J_T$</span> is considered a function of overlaps <span>$τ_k = ⟨ϕ_k^\tgt|ϕ_k(T)⟩$</span>. This requires that all <code>objectives</code> define a <code>target_state</code> and that <code>J_T</code> calculates the value of the functional solely based on the values of <code>τ</code> passed as a keyword argument.  With only the complex conjugate <span>$τ̄_k = ⟨ϕ_k(T)|ϕ_k^\tgt⟩$</span> having an explicit dependency on <span>$⟨ϕ_k(T)|$</span>,  the chain rule in this case is</p><p class="math-container">\[|χ_k(T)⟩
= -\frac{∂J_T}{∂⟨ϕ_k|}
= -\left(
    \frac{∂J_T}{∂τ̄_k}
    \frac{∂τ̄_k}{∂⟨ϕ_k|}
  \right)
= - \frac{1}{2} (∇_{τ_k} J_T) |ϕ_k^\tgt⟩\,.\]</p><p>Again, we have used the definition of the Wirtinger derivatives,</p><p class="math-container">\[\begin{align*}
    \frac{∂J_T}{∂τ_k}
    &amp;≡ \frac{1}{2}\left(
        \frac{∂ J_T}{∂ \Re[τ_k]}
        - i \frac{∂ J_T}{∂ \Im[τ_k]}
    \right)\,,\\
    \frac{∂J_T}{∂τ̄_k}
    &amp;≡ \frac{1}{2}\left(
        \frac{∂ J_T}{∂ \Re[τ_k]}
        + i \frac{∂ J_T}{∂ \Im[τ_k]}
    \right)\,,
\end{align*}\]</p><p>and the definition of the Zygote gradient with respect to a complex scalar,</p><p class="math-container">\[∇_{τ_k} J_T = \left(
    \frac{∂ J_T}{∂ \Re[τ_k]}
    + i \frac{∂ J_T}{∂ \Im[τ_k]}
\right)\,.\]</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In order to extend <code>make_chi</code> with an analytic implementation for a new <code>J_T</code> function, define a new method <code>make_analytic_chi</code> like so:</p><pre><code class="language-julia hljs">make_analytic_chi(::typeof(J_T_sm), objectives) = chi_sm!</code></pre><p>which links <code>make_chi</code> for <code>J_T_sm</code> to <code>chi_sm!</code>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Zygote is notorious for being buggy (silently returning incorrect gradients). Always test automatic derivatives against finite differences and/or other automatic differentiation frameworks.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.make_grad_J_a" href="#QuantumControlBase.make_grad_J_a"><code>QuantumControlBase.make_grad_J_a</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return a function to evaluate <span>$∂J_a/∂ϵ_{ln}$</span> for a pulse value running cost.</p><pre><code class="language-julia hljs">grad_J_a! = make_grad_J_a(
    J_a,
    tlist;
    force_zygote=false,
    use_finite_differences=false
)</code></pre><p>returns a function so that <code>grad_J_a!(∇J_a, pulsevals, tlist)</code> sets <span>$∂J_a/∂ϵ_{ln}$</span> as the elements of the (vectorized) <code>∇J_a</code>. The function <code>J_a</code> must have the interface <code>J_a(pulsevals, tlist)</code>, see, e.g., <code>J_a_fluence</code>.</p><p>If <code>force_zygote=true</code>, automatic differentiation with Zygote will be used to calculate the derivative.</p><p>If <code>use_finite_differences=true</code>, the derivative will be calculated via finite differences. This may be used to verify Zygote gradients.</p><p>By default, for functionals <code>J_a</code> that have a known analytic derivative, that analytic derivative will be used. For unknown functions, the derivative will be calculated via Zygote.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In order to extend <code>make_grad_J_a</code> with an analytic implementation for a new <code>J_a</code> function, define a new method <code>make_analytic_grad_J_a</code> like so:</p><pre><code class="language-julia hljs">make_analytic_grad_J_a(::typeof(J_a_fluence), tlist) = grad_J_a_fluence!</code></pre><p>which links <code>make_grad_J_a</code> for <code>J_a_fluence</code> to <code>grad_J_a_fluence!</code>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.chain_infohooks" href="#QuantumControlBase.chain_infohooks"><code>QuantumControlBase.chain_infohooks</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Combine multiple <code>info_hook</code> functions.</p><pre><code class="language-julia hljs">chain_infohooks(funcs...)</code></pre><p>combines <code>funcs</code> into a single Function that can be passes as <code>info_hook</code> to <a href="#QuantumControlBase.ControlProblem"><code>ControlProblem</code></a> or any <code>optimize</code>-function.</p><p>Each function in <code>func</code> must be a suitable <code>info_hook</code> by itself. This means that it should receive the optimization workspace object as its first positional parameter, then positional parameters specific to the optimization method, and then an arbitrary number of data parameters. It must return either <code>nothing</code> or a tuple of &quot;info&quot; objects (which will end up in the <code>records</code> field of the optimization result).</p><p>When chaining infohooks, the <code>funcs</code> will be called in series, and the &quot;info&quot; objects will be accumulated into a single result tuple. The combined results from previous <code>funcs</code> will be given to the subsequent <code>funcs</code> as data parameters. This allows for the infohooks in the chain to communicate.</p><p>The chain will return the final combined result tuple, or <code>nothing</code> if all <code>funcs</code> return <code>nothing</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When instantiating a <a href="#QuantumControlBase.ControlProblem"><code>ControlProblem</code></a>, any <code>info_hook</code> that is a tuple will be automatically processed with <code>chain_infohooks</code>. Thus, <code>chain_infohooks</code> rarely has to be invoked manually.</p></div></div></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quantum_propagators/">« QuantumPropagators</a><a class="docs-footer-nextpage" href="../krotov/">Krotov »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/QuantumControl.jl">QuantumControl.jl</a> v0.6.0 docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 16 February 2023 21:51">Thursday 16 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · QuantumControl.jl</title><meta name="title" content="Reference · QuantumControl.jl"/><meta property="og:title" content="Reference · QuantumControl.jl"/><meta property="twitter:title" content="Reference · QuantumControl.jl"/><meta name="description" content="Documentation for QuantumControl.jl."/><meta property="og:description" content="Documentation for QuantumControl.jl."/><meta property="twitter:description" content="Documentation for QuantumControl.jl."/><meta property="og:url" content="https://juliaquantumcontrol.github.io/QuantumControl.jl/api/reference/"/><meta property="twitter:url" content="https://juliaquantumcontrol.github.io/QuantumControl.jl/api/reference/"/><link rel="canonical" href="https://juliaquantumcontrol.github.io/QuantumControl.jl/api/reference/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/assets/topbar/topbar.css" rel="stylesheet" type="text/css"/><script src="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/assets/topbar/topbar.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QuantumControl.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../glossary/">Glossary</a></li><li><a class="tocitem" href="../../overview/">Overview</a></li><li><a class="tocitem" href="../../methods/">Control Methods</a></li><li><a class="tocitem" href="../../howto/">How-to Guides</a></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../quantum_control/">QuantumControl</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#quantumcontrol-local-symbols"><span>Local Exported Symbols</span></a></li><li><a class="tocitem" href="#quantumcontrol-local-unexported-symbols"><span>Local Unexported Symbols</span></a></li><li><a class="tocitem" href="#quantumcontrol-submodules"><span>List of Submodules</span></a></li><li><a class="tocitem" href="#QuantumControlAmplitudesLocalAPI"><span><code>QuantumControl.Amplitudes</code></span></a></li><li><a class="tocitem" href="#QuantumControlControlsLocalAPI"><span><code>QuantumControl.Controls</code></span></a></li><li><a class="tocitem" href="#QuantumControlFunctionalsLocalAPI"><span><code>QuantumControl.Functionals</code></span></a></li><li><a class="tocitem" href="#QuantumControlGeneratorsLocalAPI"><span><code>QuantumControl.Generators</code></span></a></li><li><a class="tocitem" href="#QuantumControlInterfacesLocalAPI"><span><code>QuantumControl.Interfaces</code></span></a></li><li><a class="tocitem" href="#QuantumControlPulseParameterizationsLocalAPI"><span><code>QuantumControl.PulseParameterizations</code></span></a></li><li><a class="tocitem" href="#QuantumControlShapesLocalAPI"><span><code>QuantumControl.Shapes</code></span></a></li><li><a class="tocitem" href="#QuantumControlStorageLocalAPI"><span><code>QuantumControl.Storage</code></span></a></li><li><a class="tocitem" href="#QuantumControlWorkflowsLocalAPI"><span><code>QuantumControl.Workflows</code></span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Subpackages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../quantum_propagators/">QuantumPropagators</a></li></ul></li><li><a class="tocitem" href="../quantum_control_index/">Index</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/QuantumControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/master/docs/generate_api.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>This page provides <em>all</em> docstrings locally defined in the <code>QuantumControl</code> package for both private and public symbols. See also the summary of the <a href="../quantum_control/#QuantumControlAPI">public API</a>.</p><p><code>QuantumControl</code> exposes local <a href="#quantumcontrol-local-symbols">exported</a> and <a href="#quantumcontrol-local-unexported-symbols">unexported</a> local symbols as well as re-exporting symbols and sub-modules from the <a href="../quantum_propagators/#QuantumPropagatorsPackage">QuantumPropagators</a> subpackage and some of its submodules.</p><p>The <a href="#quantumcontrol-submodules"><code>QuantumControl</code> submodules</a> provide additional public functionality. Note that some of the most commonly used symbols from <code>QuantumControl</code>&#39;s submodules may also be re-exported at the top-level (such as <a href="#QuantumControl.Workflows.@optimize_or_load"><code>@optimize_or_load</code></a> from the <a href="../quantum_control/#QuantumControlWorkflowsAPI"><code>QuantumControl.Workflows</code></a> submodule).</p><h2 id="quantumcontrol-local-symbols"><a class="docs-heading-anchor" href="#quantumcontrol-local-symbols">Local Exported Symbols</a><a id="quantumcontrol-local-symbols-1"></a><a class="docs-heading-anchor-permalink" href="#quantumcontrol-local-symbols" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.ControlProblem" href="#QuantumControl.ControlProblem"><code>QuantumControl.ControlProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A full control problem with multiple trajectories.</p><pre><code class="language-julia hljs">ControlProblem(
   trajectories,
   tlist;
   kwargs...
)</code></pre><p>The <code>trajectories</code> are a list of <a href="#QuantumControl.Trajectory"><code>Trajectory</code></a> instances, each defining an initial state and a dynamical generator for the evolution of that state. Usually, the trajectory will also include a target state (see <a href="#QuantumControl.Trajectory"><code>Trajectory</code></a>) and possibly a weight. The <code>trajectories</code> may also be given together with <code>tlist</code> as a mandatory keyword argument.</p><p>The <code>tlist</code> is the time grid on which the time evolution of the initial states of each trajectory should be propagated. It may also be given as a (mandatory) keyword argument.</p><p>The remaining <code>kwargs</code> are keyword arguments that are passed directly to the optimal control method. These typically include e.g. the optimization functional.</p><p>The control problem is solved by finding a set of controls that minimize an optimization functional over all trajectories.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/control_problem.jl#L4-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Trajectory" href="#QuantumControl.Trajectory"><code>QuantumControl.Trajectory</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Description of a state&#39;s time evolution.</p><pre><code class="language-julia hljs">Trajectory(
    initial_state,
    generator;
    target_state=nothing,
    weight=1.0,
    kwargs...
)</code></pre><p>describes the time evolution of the <code>initial_state</code> under a time-dependent dynamical <code>generator</code> (e.g., a Hamiltonian or Liouvillian).</p><p>Trajectories are central to quantum control problems: an optimization functional depends on the result of propagating one or more trajectories. For example, when optimizing for a quantum gate, the optimization considers the trajectories of all logical basis states.</p><p>In addition to the <code>initial_state</code> and <code>generator</code>, a <code>Trajectory</code> may include data relevant to the propagation and to evaluating a particular optimization functional. Most functionals have the notion of a &quot;target state&quot; that the <code>initial_state</code> should evolve towards, which can be given as the <code>target_state</code> keyword argument. In some functionals, different trajectories enter with different weights [<a href="../../references/#GoerzNJP2014">18</a>], which can be given as a <code>weight</code> keyword argument. Any other keyword arguments are also available to a functional as properties of the <code>Trajectory</code> .</p><p>A <code>Trajectory</code> can also be instantiated using all keyword arguments.</p><p><strong>Properties</strong></p><p>All keyword arguments used in the instantiation are available as properties of the <code>Trajectory</code>. At a minimum, this includes <code>initial_state</code>, <code>generator</code>, <code>target_state</code>, and <code>weight</code>.</p><p>By convention, properties with a <code>prop_</code> prefix, e.g., <code>prop_method</code>, will be taken into account when propagating the trajectory. See <a href="#QuantumControl.propagate_trajectory"><code>propagate_trajectory</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/trajectories.jl#L9-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.optimize" href="#QuantumControl.optimize"><code>QuantumControl.optimize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Optimize a quantum control problem.</p><pre><code class="language-julia hljs">result = optimize(
    problem;
    method,  # mandatory keyword argument
    check=true,
    callback=nothing,
    print_iters=true,
    kwargs...
)</code></pre><p>optimizes towards a solution of given <a href="#QuantumControl.ControlProblem"><code>problem</code></a> with the given <code>method</code>, which should be a <code>Module</code> implementing the method, e.g.,</p><pre><code class="language-julia hljs">using Krotov
result = optimize(problem; method=Krotov)</code></pre><p>If <code>check</code> is true (default), the <code>initial_state</code> and <code>generator</code> of each trajectory is checked with <a href="../quantum_propagators/#QuantumPropagators.Interfaces.check_state"><code>check_state</code></a> and <a href="#QuantumControl.Interfaces.check_generator"><code>check_generator</code></a>. Any other keyword argument temporarily overrides the corresponding keyword argument in <a href="#QuantumControl.ControlProblem"><code>problem</code></a>. These arguments are available to the optimizer, see each optimization package&#39;s documentation for details.</p><p>The <code>callback</code> can be given as a function to be called after each iteration in order to analyze the progress of the optimization or to modify the state of the optimizer or the current controls. The signature of <code>callback</code> is method-specific, but callbacks should receive a workspace objects as the first parameter as the first argument, the iteration number as the second parameter, and then additional method-specific parameters.</p><p>The <code>callback</code> function may return a tuple of values, and an optimization method should store these values fore each iteration in a <code>records</code> field in their <code>Result</code> object. The <code>callback</code> should be called once with an iteration number of <code>0</code> before the first iteration. The <code>callback</code> can also be given as a tuple of vector of functions, which are automatically combined via <a href="#QuantumControl.chain_callbacks"><code>chain_callbacks</code></a>.</p><p>If <code>print_iters</code> is <code>true</code> (default), an automatic <code>callback</code> is created via the method-specific <a href="#QuantumControl.make_print_iters"><code>make_print_iters</code></a> to print the progress of the optimization after each iteration. This automatic callback runs after any manually given <code>callback</code>.</p><p>All remaining keyword argument are method-specific. To obtain the documentation for which options a particular method uses, run, e.g.,</p><pre><code class="language-julia hljs">? optimize(problem, ::Val{:Krotov})</code></pre><p>where <code>:Krotov</code> is the name of the module implementing the method. The above is also the method signature that a <code>Module</code> wishing to implement a control method must define.</p><p>The returned <code>result</code> object is specific to the optimization method, but should be a subtype of <a href="#QuantumControl.AbstractOptimizationResult"><code>QuantumControl.AbstractOptimizationResult</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/optimize.jl#L11-L72">source</a></section><section><div><pre><code class="language-julia hljs">using Krotov
result = optimize(problem; method=Krotov, kwargs...)</code></pre><p>optimizes the given control <a href="#QuantumControl.ControlProblem"><code>problem</code></a> using Krotov&#39;s method, by minimizing the functional</p><p class="math-container">\[J(\{ϵ_l(t)\}) =
    J_T(\{|Ψ_k(T)⟩\})
    + ∑_l \int_{0}^{T} \frac{λ_{a,l}}{S_l(t)} [ϵ_l(t) - ϵ_l^{(0)}(t)]^2 \, dt\,,\]</p><p>cf. the <a href="../../#Functional">general form of a quantum control functional</a>. The &quot;reference field&quot; <span>$ϵ_l^{(0)}(t)$</span> is the guess control for that particular iteration. The above functional implies a first-order update equation</p><p class="math-container">\[Δϵ_l(t) = \frac{S_l(t)}{λ_{a,l}} \Im ∑_k \left[
\Big\langle
    \chi_k^{(0)}(t)
\Big\vert
    \frac{\partial \hat{H}_k}{\partial ϵ_l(t)}
\Big\vert
    \Psi_k(t)
\Big\rangle
\right]\,,\]</p><p>where <span>$|\chi^{(0)}_k(t)⟩$</span> is the state backward-propagated under <span>$Ĥ_k^{\dagger}(\{ϵ_l^{(0)}(t)\})$</span> with the boundary condition <span>$|\chi_k(T)⟩ = \partial J_T / \partial ⟨Ψ_k^{(0)}(T)|$</span> and <span>$Ĥ_k$</span> is the <code>generator</code> of the <span>$k$</span>&#39;th trajectory.</p><p>Note that the particular control-dependent running cost in the above functional is required to obtain the given Krotov update equation. Other running costs, or state-dependent running costs are not supported in this implementation of Krotov&#39;s method (even though <em>some</em> running costs are mathematically compatible with Krotov&#39;s method).</p><p>Returns a <a href="https://juliaquantumcontrol.github.io/Krotov.jl/stable/api/#Krotov.KrotovResult"><code>KrotovResult</code></a>.</p><p>Keyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of <code>problem</code>; any of these can be overridden with explicit keyword arguments to <code>optimize</code>.</p><p><strong>Required problem keyword arguments</strong></p><ul><li><code>J_T</code>: A function <code>J_T(Ψ, trajectories)</code> that evaluates the final time functional from a list <code>Ψ</code> of forward-propagated states and <code>problem.trajectories</code>. The function <code>J_T</code> may also take a keyword argument <code>tau</code>. If it does, a vector containing the complex overlaps of the target states (<code>target_state</code> property of each trajectory in <code>problem.trajectories</code>) with the propagated states will be passed to <code>J_T</code>.</li></ul><p><strong>Recommended problem keyword arguments</strong></p><ul><li><code>lambda_a=1.0</code>: The inverse Krotov step width λₐ for every pulse.</li><li><code>update_shape=(t-&gt;1.0)</code>: A function <code>S(t)</code> for the &quot;update shape&quot; that scales the update for every pulse.</li></ul><p>If different controls require different <code>lambda_a</code> or <code>update_shape</code>, a dict <code>pulse_options</code> must be given instead of a global <code>lambda_a</code> and <code>update_shape</code>; see below.</p><p><strong>Optional problem keyword arguments</strong></p><p>The following keyword arguments are supported (with default values):</p><ul><li><p><code>pulse_options</code>: A dictionary that maps every control (as obtained by <a href="../quantum_propagators/#QuantumPropagators.Controls.get_controls"><code>get_controls</code></a> from the <code>problem.trajectories</code>) to the following dict:</p><ul><li><code>:lambda_a</code>:  The value for inverse Krotov step width λₐ.</li><li><code>:update_shape</code>: A function <code>S(t)</code> for the &quot;update shape&quot; that scales the Krotov pulse update.</li></ul><p>This overrides the global <code>lambda_a</code> and <code>update_shape</code> arguments.</p></li><li><p><code>chi</code>: A function <code>chi(Ψ, trajectories)</code> that receives a list <code>Ψ</code> of the forward propagated states and returns a vector of states <span>$|χₖ⟩ = -∂J_T/∂⟨Ψₖ|$</span>. If not given, it will be automatically determined from <code>J_T</code> via <a href="#QuantumControl.Functionals.make_chi"><code>make_chi</code></a> with the default parameters. Similarly to <code>J_T</code>, if <code>chi</code> accepts a keyword argument <code>tau</code>, it will be passed a vector of complex overlaps.</p></li><li><p><code>sigma=nothing</code>: A function that calculates the second-order contribution. If not given, the first-order Krotov method is used.</p></li><li><p><code>iter_start=0</code>: The initial iteration number.</p></li><li><p><code>iter_stop=5000</code>: The maximum iteration number.</p></li><li><p><code>prop_method</code>: The propagation method to use for each trajectory; see below.</p></li><li><p><code>print_iters=true</code>: Whether to print information after each iteration.</p></li><li><p><code>store_iter_info=Set()</code>: Which fields from <code>print_iters</code> to store in <code>result.records</code>. A subset of <code>Set([&quot;iter.&quot;, &quot;J_T&quot;, &quot;∫gₐ(t)dt&quot;, &quot;J&quot;, &quot;ΔJ_T&quot;, &quot;ΔJ&quot;, &quot;secs&quot;])</code>.</p></li><li><p><code>callback</code>: A function (or tuple of functions) that receives the <a href="https://juliaquantumcontrol.github.io/Krotov.jl/stable/api/#Krotov.KrotovWrk">Krotov workspace</a>, the iteration number, the list of updated pulses, and the list of guess pulses as positional arguments. The function may return a tuple of values which are stored in the <a href="https://juliaquantumcontrol.github.io/Krotov.jl/stable/api/#Krotov.KrotovResult"><code>KrotovResult</code></a> object <code>result.records</code>. The function can also mutate any of its arguments, in particular the updated pulses. This may be used, e.g., to apply a spectral filter to the updated pulses or to perform similar manipulations. Note that <code>print_iters=true</code> (default) adds an automatic callback to print information after each iteration. With <code>store_iter_info</code>, that callback automatically stores a subset of the printed information.</p></li><li><p><code>check_convergence</code>: A function to check whether convergence has been reached. Receives a <a href="https://juliaquantumcontrol.github.io/Krotov.jl/stable/api/#Krotov.KrotovResult"><code>KrotovResult</code></a> object <code>result</code>, and should set <code>result.converged</code> to <code>true</code> and <code>result.message</code> to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with <code>∘</code>. The convergence check is performed after any <code>callback</code>.</p></li><li><p><code>verbose=false</code>: If <code>true</code>, print information during initialization.</p></li><li><p><code>rethrow_exceptions</code>: By default, any exception ends the optimization but still returns a <a href="https://juliaquantumcontrol.github.io/Krotov.jl/stable/api/#Krotov.KrotovResult"><code>KrotovResult</code></a> that captures the message associated with the exception. This is to avoid losing results from a long-running optimization when an exception occurs in a later iteration. If <code>rethrow_exceptions=true</code>, instead of capturing the exception, it will be thrown normally.</p></li></ul><p><strong>Trajectory propagation</strong></p><p>Krotov&#39;s method involves the forward and backward propagation for every <a href="#QuantumControl.Trajectory"><code>Trajectory</code></a> in the <code>problem</code>. The keyword arguments for each propagation (see <a href="../quantum_propagators/#QuantumPropagators.propagate"><code>propagate</code></a>) are determined from any properties of each <a href="#QuantumControl.Trajectory"><code>Trajectory</code></a> that have a <code>prop_</code> prefix, cf. <a href="#QuantumControl.init_prop_trajectory"><code>init_prop_trajectory</code></a>.</p><p>In situations where different parameters are required for the forward and backward propagation, instead of the <code>prop_</code> prefix, the <code>fw_prop_</code> and <code>bw_prop_</code> prefixes can be used, respectively. These override any setting with the <code>prop_</code> prefix. This applies both to the properties of each <a href="#QuantumControl.Trajectory"><code>Trajectory</code></a> and the problem keyword arguments.</p><p>Note that the propagation method for each propagation must be specified. In most cases, it is sufficient (and recommended) to pass a global <code>prop_method</code> problem keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/Krotov.jl/blob/f6f69017569bd28ef9d5935a573580556f39d60f/src/optimize.jl#L16-L154">source</a></section><section><div><pre><code class="language-julia hljs">using GRAPE
result = optimize(problem; method=GRAPE, kwargs...)</code></pre><p>optimizes the given control <a href="#QuantumControl.ControlProblem"><code>problem</code></a> via the GRAPE method, by minimizing the functional</p><p class="math-container">\[J(\{ϵ_{nl}\}) = J_T(\{|Ψ_k(T)⟩\}) + λ_a J_a(\{ϵ_{nl}\})\,,\]</p><p>where the final time functional <span>$J_T$</span> depends explicitly on the forward-propagated states <span>$|Ψ_k(T)⟩$</span>, where <span>$|Ψ_k(t)⟩$</span> is the time evolution of the <code>initial_state</code> in the <span>$k$</span>th&#39; trajectory in <code>problem.trajectories</code>, and the running cost <span>$J_a$</span> depends explicitly on pulse values <span>$ϵ_{nl}$</span> of the l&#39;th control discretized on the n&#39;th interval of the time grid.</p><p>It does this by calculating the gradient of the final-time functional</p><p class="math-container">\[\nabla J_T \equiv \frac{\partial J_T}{\partial ϵ_{nl}}
= -2 \Re
\underbrace{%
\underbrace{\bigg\langle χ(T) \bigg\vert \hat{U}^{(k)}_{N_T} \dots \hat{U}^{(k)}_{n+1} \bigg \vert}_{\equiv \bra{\chi(t_n)}\;\text{(bw. prop.)}}
\frac{\partial \hat{U}^{(k)}_n}{\partial ϵ_{nl}}
}_{\equiv \bra{χ_k^\prime(t_{n-1})}}
\underbrace{\bigg \vert \hat{U}^{(k)}_{n-1} \dots \hat{U}^{(k)}_1 \bigg\vert Ψ_k(t=0) \bigg\rangle}_{\equiv |\Psi(t_{n-1})⟩\;\text{(fw. prop.)}}\,,\]</p><p>where <span>$\hat{U}^{(k)}_n$</span> is the time evolution operator for the <span>$n$</span> the interval, generally assumed to be <span>$\hat{U}^{(k)}_n = \exp[-i \hat{H}_{kn} dt_n]$</span>, where <span>$\hat{H}_{kn}$</span> is the operator obtained by evaluating <code>problem.trajectories[k].generator</code> on the <span>$n$</span>&#39;th time interval.</p><p>The backward-propagation of <span>$|\chi_k(t)⟩$</span> has the boundary condition</p><p class="math-container">\[    |\chi_k(T)⟩ \equiv - \frac{\partial J_T}{\partial ⟨\Psi_k(T)|}\,.\]</p><p>The final-time gradient <span>$\nabla J_T$</span> is combined with the gradient for the running costs, and the total gradient is then fed into an optimizer (L-BFGS-B by default) that iteratively changes the values <span>$\{ϵ_{nl}\}$</span> to minimize <span>$J$</span>.</p><p>See <a href="https://juliaquantumcontrol.github.io/GRAPE.jl/stable/background/#GRAPE-Background">Background</a> for details.</p><p>Returns a <a href="https://juliaquantumcontrol.github.io/GRAPE.jl/stable/api/#GRAPE.GrapeResult"><code>GrapeResult</code></a>.</p><p>Keyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of <code>problem</code>; any of these can be overridden with explicit keyword arguments to <code>optimize</code>.</p><p><strong>Required problem keyword arguments</strong></p><ul><li><code>J_T</code>: A function <code>J_T(Ψ, trajectories)</code> that evaluates the final time functional from a list <code>Ψ</code> of forward-propagated states and <code>problem.trajectories</code>. The function <code>J_T</code> may also take a keyword argument <code>tau</code>. If it does, a vector containing the complex overlaps of the target states (<code>target_state</code> property of each trajectory in <code>problem.trajectories</code>) with the propagated states will be passed to <code>J_T</code>.</li></ul><p><strong>Optional problem keyword arguments</strong></p><ul><li><p><code>chi</code>: A function <code>chi(Ψ, trajectories)</code> that receives a list <code>Ψ</code> of the forward propagated states and returns a vector of states <span>$|χₖ⟩ = -∂J_T/∂⟨Ψₖ|$</span>. If not given, it will be automatically determined from <code>J_T</code> via <a href="#QuantumControl.Functionals.make_chi"><code>QuantumControl.Functionals.make_chi</code></a> with the default parameters. Similarly to <code>J_T</code>, if <code>chi</code> accepts a keyword argument <code>tau</code>, it will be passed a vector of complex overlaps.</p></li><li><p><code>chi_min_norm=1e-100</code>: The minimum allowable norm for any <span>$|χₖ(T)⟩$</span>. Smaller norms would mean that the gradient is zero, and will abort the optimization with an error.</p></li><li><p><code>J_a</code>: A function <code>J_a(pulsevals, tlist)</code> that evaluates running costs over the pulse values, where <code>pulsevals</code> are the vectorized values <span>$ϵ_{nl}$</span>, where <code>n</code> are in indices of the time intervals and <code>l</code> are the indices over the controls, i.e., <code>[ϵ₁₁, ϵ₂₁, …, ϵ₁₂, ϵ₂₂, …]</code> (the pulse values for each control are contiguous). If not given, the optimization will not include a running cost.</p></li><li><p><code>gradient_method=:gradgen</code>: One of <code>:gradgen</code> (default) or <code>:taylor</code>. With <code>gradient_method=:gradgen</code>, the gradient is calculated using <a href="https://github.com/JuliaQuantumControl/QuantumGradientGenerators.jl">QuantumGradientGenerators</a>. With <code>gradient_method=:taylor</code>, it is evaluated via a Taylor series, see Eq. (20) in Kuprov and Rogers,  J. Chem. Phys. 131, 234108 (2009) [<a href="../../references/#KuprovJCP2009">17</a>].</p></li><li><p><code>taylor_grad_max_order=100</code>: If given with <code>gradient_method=:taylor</code>, the maximum number of terms in the Taylor series. If <code>taylor_grad_check_convergence=true</code> (default), if the Taylor series does not convergence within the given number of terms, throw an an error. With <code>taylor_grad_check_convergence=true</code>, this is the exact order of the Taylor series.</p></li><li><p><code>taylor_grad_tolerance=1e-16</code>: If given with <code>gradient_method=:taylor</code> and <code>taylor_grad_check_convergence=true</code>, stop the Taylor series when the norm of the term falls below the given tolerance. Ignored if <code>taylor_grad_check_convergence=false</code>.</p></li><li><p><code>taylor_grad_check_convergence=true</code>: If given as <code>true</code> (default), check the convergence after each term in the Taylor series an stop as soon as the norm of the term drops below the given number. If <code>false</code>, stop after exactly <code>taylor_grad_max_order</code> terms.</p></li><li><p><code>lambda_a=1</code>: A weight for the running cost <code>J_a</code>.</p></li><li><p><code>grad_J_a</code>: A function to calculate the gradient of <code>J_a</code>. If not given, it will be automatically determined. See <a href="#QuantumControl.Functionals.make_grad_J_a"><code>make_grad_J_a</code></a> for the required interface.</p></li><li><p><code>upper_bound</code>: An upper bound for the value of any optimized control. Time-dependent upper bounds can be specified via <code>pulse_options</code>.</p></li><li><p><code>lower_bound</code>: A lower bound for the value of any optimized control. Time-dependent lower bounds can be specified via <code>pulse_options</code>.</p></li><li><p><code>pulse_options</code>: A dictionary that maps every control (as obtained by <a href="../quantum_propagators/#QuantumPropagators.Controls.get_controls"><code>get_controls</code></a> from the <code>problem.trajectories</code>) to a dict with the following possible keys:</p><ul><li><code>:upper_bounds</code>: A vector of upper bound values, one for each intervals of the time grid. Values of <code>Inf</code> indicate an unconstrained upper bound for that time interval, respectively the global <code>upper_bound</code>, if given.</li><li><code>:lower_bounds</code>: A vector of lower bound values. Values of <code>-Inf</code> indicate an unconstrained lower bound for that time interval,</li></ul></li><li><p><code>print_iters=true</code>: Whether to print information after each iteration.</p></li><li><p><code>print_iter_info=[&quot;iter.&quot;, &quot;J_T&quot;, &quot;|∇J|&quot;, &quot;|Δϵ|&quot;, &quot;ΔJ&quot;, &quot;FG(F)&quot;, &quot;secs&quot;]</code>: Which fields to print if <code>print_iters=true</code>. If given, must be a list of header labels (strings), which can be any of the following:</p><ul><li><p><code>&quot;iter.&quot;</code>: The iteration number</p></li><li><p><code>&quot;J_T&quot;</code>: The value of the final-time functional for the dynamics under the optimized pulses</p></li><li><p><code>&quot;J_a&quot;</code>: The value of the pulse-dependent running cost for the optimized pulses</p></li><li><p><code>&quot;λ_a⋅J_a&quot;</code>: The total contribution of <code>J_a</code> to the full functional <code>J</code></p></li><li><p><code>&quot;J&quot;</code>: The value of the optimization functional for the optimized pulses</p></li><li><p><code>&quot;ǁ∇J_Tǁ&quot;</code>: The ℓ²-norm of the <em>current</em> gradient of the final-time functional. Note that this is usually the gradient of the optimize pulse, not the guess pulse.</p></li><li><p><code>&quot;ǁ∇J_aǁ&quot;</code>: The ℓ²-norm of the the <em>current</em> gradient of the pulse-dependent running cost. For comparison with <code>&quot;ǁ∇J_Tǁ&quot;</code>.</p></li><li><p><code>&quot;λ_aǁ∇J_aǁ&quot;</code>: The ℓ²-norm of the the <em>current</em> gradient of the complete pulse-dependent running cost term. For comparison with <code>&quot;ǁ∇J_Tǁ&quot;</code>.</p></li><li><p><code>&quot;ǁ∇Jǁ&quot;</code>: The norm of the guess pulse gradient. Note that the <em>guess</em> pulse gradient is not the same the <em>current</em> gradient.</p></li><li><p><code>&quot;ǁΔϵǁ&quot;</code>:  The ℓ²-norm of the pulse update</p></li><li><p><code>&quot;ǁϵǁ&quot;</code>: The ℓ²-norm of optimized pulse values</p></li><li><p><code>&quot;max|Δϵ|&quot;</code> The maximum value of the pulse update (infinity norm)</p></li><li><p><code>&quot;max|ϵ|&quot;</code>: The maximum value of the pulse values (infinity norm)</p></li><li><p><code>&quot;ǁΔϵǁ/ǁϵǁ&quot;</code>: The ratio of the pulse update tothe optimized pulse values</p></li><li><p><code>&quot;∫Δϵ²dt&quot;</code>: The L²-norm of the pulse update, summed over all pulses. A convergence measure comparable (proportional) to the running cost in Krotov&#39;s method</p></li><li><p><code>&quot;ǁsǁ&quot;</code>: The norm of the search direction. Should be <code>ǁΔϵǁ</code> scaled by the step with <code>α</code>.</p></li><li><p><code>&quot;∠°&quot;</code>: The angle (in degrees) between the negative gradient <code>-∇J</code> and the search direction <code>s</code>.</p></li><li><p><code>&quot;α&quot;</code>: The step width as determined by the line search (<code>Δϵ = α⋅s</code>)</p></li><li><p><code>&quot;ΔJ_T&quot;</code>: The change in the final time functional relative to the previous iteration</p></li><li><p><code>&quot;ΔJ_a&quot;</code>:  The change in the control-dependent running cost relative to the previous iteration</p></li><li><p><code>&quot;λ_a⋅ΔJ_a&quot;</code>: The change in the control-dependent running cost term relative to the previous iteration.</p></li><li><p><code>&quot;ΔJ&quot;</code>:  The change in the total optimization functional relative to the previous iteration.</p></li><li><p><code>&quot;FG(F)&quot;</code>:  The number of functional/gradient evaluation (FG), or pure functional (F) evaluations</p></li><li><p><code>&quot;secs&quot;</code>:  The number of seconds of wallclock time spent on the iteration.</p></li><li><p><code>store_iter_info=[]</code>: Which fields to store in <code>result.records</code>, given as</p></li></ul><p>a list of header labels, see <code>print_iter_info</code>.</p></li><li><p><code>callback</code>: A function (or tuple of functions) that receives the <a href="https://juliaquantumcontrol.github.io/GRAPE.jl/stable/api/#GRAPE.GrapeWrk">GRAPE workspace</a> and the iteration number. The function may return a tuple of values which are stored in the <a href="https://juliaquantumcontrol.github.io/GRAPE.jl/stable/api/#GRAPE.GrapeResult"><code>GrapeResult</code></a> object <code>result.records</code>. The function can also mutate the workspace, in particular the updated <code>pulsevals</code>. This may be used, e.g., to apply a spectral filter to the updated pulses or to perform similar manipulations. Note that <code>print_iters=true</code> (default) adds an automatic callback to print information after each iteration. With <code>store_iter_info</code>, that callback automatically stores a subset of the available information.</p></li><li><p><code>check_convergence</code>: A function to check whether convergence has been reached. Receives a <a href="https://juliaquantumcontrol.github.io/GRAPE.jl/stable/api/#GRAPE.GrapeResult"><code>GrapeResult</code></a> object <code>result</code>, and should set <code>result.converged</code> to <code>true</code> and <code>result.message</code> to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with <code>∘</code>. The convergence check is performed after any <code>callback</code>.</p></li><li><p><code>prop_method</code>: The propagation method to use for each trajectory, see below.</p></li><li><p><code>verbose=false</code>: If <code>true</code>, print information during initialization</p></li><li><p><code>rethrow_exceptions</code>: By default, any exception ends the optimization, but still returns a <a href="https://juliaquantumcontrol.github.io/GRAPE.jl/stable/api/#GRAPE.GrapeResult"><code>GrapeResult</code></a> that captures the message associated with the exception. This is to avoid losing results from a long-running optimization when an exception occurs in a later iteration. If <code>rethrow_exceptions=true</code>, instead of capturing the exception, it will be thrown normally.</p></li></ul><p><strong>Experimental keyword arguments</strong></p><p>The following keyword arguments may change in non-breaking releases:</p><ul><li><code>x_tol</code>: Parameter for Optim.jl</li><li><code>f_tol</code>: Parameter for Optim.jl</li><li><code>g_tol</code>: Parameter for Optim.jl</li><li><code>show_trace</code>: Parameter for Optim.jl</li><li><code>extended_trace</code>:  Parameter for Optim.jl</li><li><code>show_every</code>: Parameter for Optim.jl</li><li><code>allow_f_increases</code>: Parameter for Optim.jl</li><li><code>optimizer</code>: An optional Optim.jl optimizer (<code>Optim.AbstractOptimizer</code> instance). If not given, an <a href="https://github.com/Gnimuc/LBFGSB.jl">L-BFGS-B</a> optimizer will be used.</li></ul><p><strong>Trajectory propagation</strong></p><p>GRAPE may involve three types of propagation:</p><ul><li>A forward propagation for every <a href="#QuantumControl.Trajectory"><code>Trajectory</code></a> in the <code>problem</code></li><li>A backward propagation for every trajectory</li><li>A backward propagation of a <a href="https://juliaquantumcontrol.github.io/QuantumGradientGenerators.jl/stable/api/#QuantumGradientGenerators.GradGenerator">gradient generator</a> for every trajectory.</li></ul><p>The keyword arguments for each propagation (see <a href="../quantum_propagators/#QuantumPropagators.propagate"><code>propagate</code></a>) are determined from any properties of each <a href="#QuantumControl.Trajectory"><code>Trajectory</code></a> that have a <code>prop_</code> prefix, cf. <a href="#QuantumControl.init_prop_trajectory"><code>init_prop_trajectory</code></a>.</p><p>In situations where different parameters are required for the forward and backward propagation, instead of the <code>prop_</code> prefix, the <code>fw_prop_</code> and <code>bw_prop_</code> prefix can be used, respectively. These override any setting with the <code>prop_</code> prefix. Similarly, properties for the backward propagation of the gradient generators can be set with properties that have a <code>grad_prop_</code> prefix. These prefixes apply both to the properties of each <a href="#QuantumControl.Trajectory"><code>Trajectory</code></a> and the problem keyword arguments.</p><p>Note that the propagation method for each propagation must be specified. In most cases, it is sufficient (and recommended) to pass a global <code>prop_method</code> problem keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/GRAPE.jl/blob/77d3016bf1963d431649fdc3337b5baa0e8c3a90/src/optimize.jl#L19-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.propagate_trajectories" href="#QuantumControl.propagate_trajectories"><code>QuantumControl.propagate_trajectories</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Propagate multiple trajectories in parallel.</p><pre><code class="language-julia hljs">result = propagate_trajectories(
    trajectories, tlist; use_threads=true, kwargs...
)</code></pre><p>runs <a href="#QuantumControl.propagate_trajectory"><code>propagate_trajectory</code></a> for every trajectory in <code>trajectories</code>, collects and returns a vector of results. The propagation happens in parallel if <code>use_threads=true</code> (default). All keyword parameters are passed to <a href="#QuantumControl.propagate_trajectory"><code>propagate_trajectory</code></a>, except that if <code>initial_state</code> is given, it must be a vector of initial states, one for each trajectory. Likewise, to pass pre-allocated storage arrays to <code>storage</code>, a vector of storage arrays must be passed. A simple <code>storage=true</code> will still work to return a vector of storage results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/propagate.jl#L158-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.propagate_trajectory" href="#QuantumControl.propagate_trajectory"><code>QuantumControl.propagate_trajectory</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Propagate a <a href="#QuantumControl.Trajectory"><code>Trajectory</code></a>.</p><pre><code class="language-julia hljs">propagate_trajectory(
    traj,
    tlist;
    initial_state=traj.initial_state,
    kwargs...
)</code></pre><p>propagates <code>initial_state</code> under the dynamics described by <code>traj.generator</code>. It takes the same keyword arguments as <a href="../quantum_propagators/#QuantumPropagators.propagate"><code>QuantumPropagators.propagate</code></a>, with default values from any property of <code>traj</code> with a <code>prop_</code> prefix (<code>prop_method</code>, <code>prop_inplace</code>, <code>prop_callback</code>, …). See <a href="#QuantumControl.init_prop_trajectory"><code>init_prop_trajectory</code></a> for details.</p><p>Note that <code>method</code> (a mandatory keyword argument in <a href="../quantum_propagators/#QuantumPropagators.propagate"><code>QuantumPropagators.propagate</code></a>) must be specified, either as a property <code>prop_method</code> of the trajectory, or by passing a <code>method</code> keyword argument explicitly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/propagate.jl#L9-L31">source</a></section></article><h2 id="quantumcontrol-local-unexported-symbols"><a class="docs-heading-anchor" href="#quantumcontrol-local-unexported-symbols">Local Unexported Symbols</a><a id="quantumcontrol-local-unexported-symbols-1"></a><a class="docs-heading-anchor-permalink" href="#quantumcontrol-local-unexported-symbols" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.AbstractOptimizationResult" href="#QuantumControl.AbstractOptimizationResult"><code>QuantumControl.AbstractOptimizationResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract type for the result object returned by <a href="#QuantumControl.optimize"><code>optimize</code></a>. Any optimization method implemented on top of <code>QuantumControl</code> should subtype from <code>AbstractOptimizationResult</code>. This enables conversion between the results of different methods, allowing one method to continue an optimization from another method.</p><p>In order for this to work seamlessly, result objects should use a common set of field names as much as a possible. When a result object requires fields that cannot be provided by all other result objects, it should have default values for these field, which can be defined in a custom <code>Base.convert</code> method, as, e.g.,</p><pre><code class="language-julia hljs">function Base.convert(::Type{MyResult}, result::AbstractOptimizationResult)
    defaults = Dict{Symbol,Any}(
        :f_calls =&gt; 0,
        :fg_calls =&gt; 0,
    )
    return convert(MyResult, result, defaults)
end</code></pre><p>Where <code>f_calls</code> and <code>fg_calls</code> are fields of <code>MyResult</code> that are not present in a given <code>result</code> of a different type. The three-argument <code>convert</code> is defined internally for any <code>AbstractOptimizationResult</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/result.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.chain_callbacks" href="#QuantumControl.chain_callbacks"><code>QuantumControl.chain_callbacks</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Combine multiple <code>callback</code> functions.</p><pre><code class="language-julia hljs">chain_callbacks(funcs...)</code></pre><p>combines <code>funcs</code> into a single Function that can be passes as <code>callback</code> to <a href="#QuantumControl.ControlProblem"><code>ControlProblem</code></a> or any <code>optimize</code>-function.</p><p>Each function in <code>func</code> must be a suitable <code>callback</code> by itself. This means that it should receive the optimization workspace object as its first positional parameter, then positional parameters specific to the optimization method, and then an arbitrary number of data parameters. It must return either <code>nothing</code> or a tuple of &quot;info&quot; objects (which will end up in the <code>records</code> field of the optimization result).</p><p>When chaining callbacks, the <code>funcs</code> will be called in series, and the &quot;info&quot; objects will be accumulated into a single result tuple. The combined results from previous <code>funcs</code> will be given to the subsequent <code>funcs</code> as data parameters. This allows for the callbacks in the chain to communicate.</p><p>The chain will return the final combined result tuple, or <code>nothing</code> if all <code>funcs</code> return <code>nothing</code>.</p><div class="admonition is-info" id="Note-10119ca65e75be7"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-10119ca65e75be7" title="Permalink"></a></header><div class="admonition-body"><p>When calling <a href="#QuantumControl.optimize"><code>optimize</code></a>, any <code>callback</code> that is a tuple will be automatically processed with <code>chain_callbacks</code>. Thus, <code>chain_callbacks</code> rarely has to be invoked manually.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/callbacks.jl#L36-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.init_prop_trajectory" href="#QuantumControl.init_prop_trajectory"><code>QuantumControl.init_prop_trajectory</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Initialize a propagator for a given <a href="#QuantumControl.Trajectory"><code>Trajectory</code></a>.</p><pre><code class="nohighlight hljs">propagator = init_prop_trajectory(
    traj,
    tlist;
    initial_state=traj.initial_state,
    kwargs...
)</code></pre><p>initializes a <a href="../quantum_propagators/#QuantumPropagators.AbstractPropagator"><code>Propagator</code></a> for the propagation of the <code>initial_state</code> under the dynamics described by <code>traj.generator</code>.</p><p>All keyword arguments are forwarded to <a href="../quantum_propagators/#QuantumPropagators.init_prop"><code>QuantumPropagators.init_prop</code></a>, with default values from any property of <code>traj</code> with a <code>prop_</code> prefix. That is, the keyword arguments for the underlying <a href="../quantum_propagators/#QuantumPropagators.init_prop"><code>QuantumPropagators.init_prop</code></a> are determined as follows:</p><ul><li>For any property of <code>traj</code> whose name starts with the prefix <code>prop_</code>, strip the prefix and use that property as a keyword argument for <code>init_prop</code>. For example, if <code>traj.prop_method</code> is defined, <code>method=traj.prop_method</code> will be passed to <code>init_prop</code>. Similarly, <code>traj.prop_inplace</code> would be passed as <code>inplace=traj.prop_inplace</code>, etc.</li><li>Any explicitly keyword argument to <code>init_prop_trajectory</code> overrides the values from the properties of <code>traj</code>.</li></ul><p>Note that the propagation <code>method</code> in particular must be specified, as it is a mandatory keyword argument in <a href="../quantum_propagators/#QuantumPropagators.propagate"><code>QuantumPropagators.propagate</code></a>). Thus, either <code>traj</code> must have a property <code>prop_method</code> of the trajectory, or <code>method</code> must be given as an explicit keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/propagate.jl#L62-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.make_print_iters" href="#QuantumControl.make_print_iters"><code>QuantumControl.make_print_iters</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Construct a method-specific automatic callback for printing iter information.</p><pre><code class="language-julia hljs">print_iters = make_print_iters(Method; kwargs...)</code></pre><p>constructs the automatic callback to be used by <code>optimize(problem; method=Method, print_iters=true)</code> to print information after each iteration. The keyword arguments are those used to instantiate <code>problem</code> and those explicitly passed to <a href="#QuantumControl.optimize"><code>optimize</code></a>.</p><p>Optimization methods should implement <code>make_print_iters(::Val{:Method}; kwargs...)</code> where <code>:Method</code> is the name of the module/package implementing the method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/callbacks.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.set_atexit_save_optimization" href="#QuantumControl.set_atexit_save_optimization"><code>QuantumControl.set_atexit_save_optimization</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Register a callback to dump a running optimization to disk on unexpected exit.</p><p>A long-running optimization routine may use</p><pre><code class="language-julia hljs">if !isnothing(atexit_filename)
    set_atexit_save_optimization(
        atexit_filename, result; msg_property=:message, msg=&quot;Abort: ATEXIT&quot;
    )
    # ...
    popfirst!(Base.atexit_hooks)  # remove callback
end</code></pre><p>to register a callback that writes the given <code>result</code> object to the given <code>filename</code> in JLD2 format in the event that the program terminates unexpectedly. The idea is to avoid data loss if the user presses <code>CTRL-C</code> in a non-interactive program (<code>SIGINT</code>), or if the process receives a <code>SIGTERM</code> from an HPC scheduler because the process has reached its allocated runtime limit. Note that the callback cannot protect against data loss in all possible scenarios, e.g., a <code>SIGKILL</code> will terminate the program without giving the callback a chance to run (as will yanking the power cord).</p><p>As in the above example, the optimization routine should make <code>set_atexit_save_optimization</code> conditional on an <code>atexit_filename</code> keyword argument, which is what <code>QuantumControl.@optimize_or_load</code> will pass to the optimization routine. The optimization routine must remove the callback from <code>Base.atexit_hooks</code> when it exits normally. Note that in an interactive context, <code>CTRL-C</code> will throw an <code>InterruptException</code>, but not cause a shutdown. Optimization routines that want to prevent data loss in this situation should handle the <code>InterruptException</code> and return <code>result</code>, in addition to using <code>set_atexit_save_optimization</code>.</p><p>If <code>msg_property</code> is not <code>nothing</code>, the given <code>msg</code> string will be stored in the corresponding property of the (mutable) <code>result</code> object before it is written out.</p><p>The resulting JLD2 file is compatible with <code>QuantumControl.load_optimization</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/atexit.jl#L3-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.set_default_ad_framework" href="#QuantumControl.set_default_ad_framework"><code>QuantumControl.set_default_ad_framework</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Set the default provider for automatic differentiation.</p><pre><code class="language-julia hljs">QuantumControl.set_default_ad_framework(mod; quiet=false)</code></pre><p>registers the given module (package) as the default AD framework.</p><p>This determines the default setting for the <code>automatic</code> parameter in the following functions:</p><ul><li><a href="#QuantumControl.Functionals.make_chi"><code>QuantumControl.Functionals.make_chi</code></a></li><li><a href="#QuantumControl.Functionals.make_gate_chi"><code>QuantumControl.Functionals.make_gate_chi</code></a></li><li><a href="#QuantumControl.Functionals.make_grad_J_a"><code>QuantumControl.Functionals.make_grad_J_a</code></a></li></ul><p>The given <code>mod</code> must be a supported AD framework, e.g.,</p><pre><code class="language-julia hljs">import Zygote
QuantumControl.set_default_ad_framework(Zygote)</code></pre><p>Currently, there is built-in support for <code>Zygote</code> and <code>FiniteDifferences</code>.</p><p>For other packages to be used as the default AD framework, the appropriate methods for <code>make_chi</code> etc. must be defined.</p><p>Unless <code>quiet=true</code>, calling <code>set_default_ad_framework</code> will show a message to confirm the setting.</p><p>To unset the default AD framework, use</p><pre><code class="language-julia hljs">QuantumControl.set_default_ad_framework(nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/set_default_ad_framework.jl#L2-L38">source</a></section></article><p><span>$\gdef\tgt{\text{tgt}}$</span> <span>$\gdef\tr{\operatorname{tr}}$</span> <span>$\gdef\Re{\operatorname{Re}}$</span> <span>$\gdef\Im{\operatorname{Im}}$</span></p><h2 id="quantumcontrol-submodules"><a class="docs-heading-anchor" href="#quantumcontrol-submodules">List of Submodules</a><a id="quantumcontrol-submodules-1"></a><a class="docs-heading-anchor-permalink" href="#quantumcontrol-submodules" title="Permalink"></a></h2><p><code>QuantumControl</code> has the following sub-modules:</p><ul><li><a href="#QuantumControlAmplitudesLocalAPI"><code>QuantumControl.Amplitudes</code></a></li><li><a href="#QuantumControlControlsLocalAPI"><code>QuantumControl.Controls</code></a></li><li><a href="#QuantumControlFunctionalsLocalAPI"><code>QuantumControl.Functionals</code></a></li><li><a href="#QuantumControlGeneratorsLocalAPI"><code>QuantumControl.Generators</code></a></li><li><a href="#QuantumControlInterfacesLocalAPI"><code>QuantumControl.Interfaces</code></a></li><li><a href="#QuantumControlPulseParameterizationsLocalAPI"><code>QuantumControl.PulseParameterizations</code></a></li><li><a href="#QuantumControlShapesLocalAPI"><code>QuantumControl.Shapes</code></a></li><li><a href="#QuantumControlStorageLocalAPI"><code>QuantumControl.Storage</code></a></li><li><a href="#QuantumControlWorkflowsLocalAPI"><code>QuantumControl.Workflows</code></a></li></ul><h2 id="QuantumControlAmplitudesLocalAPI"><a class="docs-heading-anchor" href="#QuantumControlAmplitudesLocalAPI"><code>QuantumControl.Amplitudes</code></a><a id="QuantumControlAmplitudesLocalAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlAmplitudesLocalAPI" title="Permalink"></a></h2><p>Re-exported Symbols:</p><ul><li><a href="../quantum_propagators/#QuantumPropagators.Amplitudes.LockedAmplitude"><code>LockedAmplitude</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Amplitudes.ShapedAmplitude"><code>ShapedAmplitude</code></a></li></ul><h2 id="QuantumControlControlsLocalAPI"><a class="docs-heading-anchor" href="#QuantumControlControlsLocalAPI"><code>QuantumControl.Controls</code></a><a id="QuantumControlControlsLocalAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlControlsLocalAPI" title="Permalink"></a></h2><p>Public Symbols:</p><ul><li><a href="#QuantumControl.Controls.get_control_deriv"><code>get_control_deriv</code></a></li><li><a href="#QuantumControl.Controls.get_control_derivs"><code>get_control_derivs</code></a></li></ul><p>Re-exported Symbols:</p><ul><li><a href="../quantum_propagators/#QuantumPropagators.Controls.ParameterizedFunction"><code>ParameterizedFunction</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Controls.discretize"><code>discretize</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Controls.discretize_on_midpoints"><code>discretize_on_midpoints</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Controls.evaluate"><code>evaluate</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Controls.evaluate!"><code>evaluate!</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Controls.get_controls"><code>get_controls</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Controls.get_parameters"><code>get_parameters</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Controls.get_tlist_midpoints"><code>get_tlist_midpoints</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Controls.substitute"><code>substitute</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Controls.t_mid"><code>t_mid</code></a></li></ul><h4 id="Public-Symbols"><a class="docs-heading-anchor" href="#Public-Symbols">Public Symbols</a><a id="Public-Symbols-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Symbols" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Controls.get_control_deriv" href="#QuantumControl.Controls.get_control_deriv"><code>QuantumControl.Controls.get_control_deriv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get the derivative of the generator <span>$G$</span> w.r.t. the control <span>$ϵ(t)$</span>.</p><pre><code class="language-julia hljs">μ  = get_control_deriv(generator, control)</code></pre><p>returns <code>nothing</code> if the <code>generator</code> (Hamiltonian or Liouvillian) does not depend on <code>control</code>, or a generator</p><p class="math-container">\[μ = \frac{∂G}{∂ϵ(t)}\]</p><p>otherwise. For linear control terms, <code>μ</code> will be a static operator, e.g. an <code>AbstractMatrix</code> or an <a href="../../glossary/#Operator"><code>Operator</code></a>. For non-linear controls, <code>μ</code> will be time-dependent, e.g. a <a href="../../glossary/#Generator"><code>Generator</code></a>. In either case, <a href="../quantum_propagators/#QuantumPropagators.Controls.evaluate"><code>evaluate</code></a> should be used to evaluate <code>μ</code> into a constant operator for particular values of the controls and a particular point in time.</p><p>For constant generators, e.g. an <a href="../../glossary/#Operator"><code>Operator</code></a>, the result is always <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/derivs.jl#L29-L51">source</a></section><section><div><pre><code class="language-julia hljs">a = get_control_deriv(ampl, control)</code></pre><p>returns the derivative <span>$∂a_l(t)/∂ϵ_{l&#39;}(t)$</span> of the given amplitude <span>$a_l(\{ϵ_{l&#39;&#39;}(t)\}, t)$</span> with respect to the given control <span>$ϵ_{l&#39;}(t)$</span>. For &quot;trivial&quot; amplitudes, where <span>$a_l(t) ≡ ϵ_l(t)$</span>, the result with be either <code>1.0</code> or <code>0.0</code> (depending on whether <code>ampl ≡ control</code>). For non-trivial amplitudes, the result may be another amplitude that depends on the controls and potentially on time, but can be evaluated to a constant with <a href="../quantum_propagators/#QuantumPropagators.Controls.evaluate"><code>evaluate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/derivs.jl#L79-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Controls.get_control_derivs" href="#QuantumControl.Controls.get_control_derivs"><code>QuantumControl.Controls.get_control_derivs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get a vector of the derivatives of <code>generator</code> w.r.t. each control.</p><pre><code class="language-julia hljs">get_control_derivs(generator, controls)</code></pre><p>return as vector containing the derivative of <code>generator</code> with respect to each control in <code>controls</code>. The elements of the vector are either <code>nothing</code> if <code>generator</code> does not depend on that particular control, or a function <code>μ(α)</code> that evaluates the derivative for a particular value of the control, see <a href="#QuantumControl.Controls.get_control_deriv"><code>get_control_deriv</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/derivs.jl#L5-L17">source</a></section></article><h2 id="QuantumControlFunctionalsLocalAPI"><a class="docs-heading-anchor" href="#QuantumControlFunctionalsLocalAPI"><code>QuantumControl.Functionals</code></a><a id="QuantumControlFunctionalsLocalAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlFunctionalsLocalAPI" title="Permalink"></a></h2><p>Public Symbols:</p><ul><li><a href="#QuantumControl.Functionals.J_T_re"><code>J_T_re</code></a></li><li><a href="#QuantumControl.Functionals.J_T_sm"><code>J_T_sm</code></a></li><li><a href="#QuantumControl.Functionals.J_T_ss"><code>J_T_ss</code></a></li><li><a href="#QuantumControl.Functionals.J_a_fluence"><code>J_a_fluence</code></a></li><li><a href="#QuantumControl.Functionals.gate_functional"><code>gate_functional</code></a></li><li><a href="#QuantumControl.Functionals.make_chi"><code>make_chi</code></a></li><li><a href="#QuantumControl.Functionals.make_gate_chi"><code>make_gate_chi</code></a></li><li><a href="#QuantumControl.Functionals.make_grad_J_a"><code>make_grad_J_a</code></a></li></ul><p>Private Symbols:</p><ul><li><a href="#QuantumControl.Functionals.F_re"><code>F_re</code></a></li><li><a href="#QuantumControl.Functionals.taus"><code>taus</code></a></li><li><a href="#QuantumControl.Functionals.F_ss"><code>F_ss</code></a></li><li><a href="#QuantumControl.Functionals.chi_ss"><code>chi_ss</code></a></li><li><a href="#QuantumControl.Functionals.grad_J_a_fluence"><code>grad_J_a_fluence</code></a></li><li><a href="#QuantumControl.Functionals.chi_sm"><code>chi_sm</code></a></li><li><a href="#QuantumControl.Functionals.F_sm"><code>F_sm</code></a></li><li><a href="#QuantumControl.Functionals.chi_re"><code>chi_re</code></a></li><li><a href="#QuantumControl.Functionals.taus!"><code>taus!</code></a></li><li><a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a></li></ul><h4 id="Public-Symbols-2"><a class="docs-heading-anchor" href="#Public-Symbols-2">Public Symbols</a><a class="docs-heading-anchor-permalink" href="#Public-Symbols-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.J_T_re" href="#QuantumControl.Functionals.J_T_re"><code>QuantumControl.Functionals.J_T_re</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Real-part functional.</p><pre><code class="language-julia hljs">J_T_re(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)</code></pre><p>calculates</p><p class="math-container">\[J_{T,\text{re}} = 1 - F_{\text{re}} \quad\in \begin{cases}
    [0, 2] &amp; \text{in Hilbert space} \\
    [0, 1] &amp; \text{in Liouville space.}
\end{cases}\]</p><p>All arguments are passed to <a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a> while evaluating <span>$F_{\text{re}}$</span> in <a href="#QuantumControl.Functionals.F_re"><code>F_re</code></a>.</p><p><strong>Reference</strong></p><ul><li>[<a href="../../references/#PalaoPRA2003">12</a>] Palao and Kosloff,  Phys. Rev. A 68, 062308 (2003)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L753-L775">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.J_T_sm" href="#QuantumControl.Functionals.J_T_sm"><code>QuantumControl.Functionals.J_T_sm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Square-modulus functional.</p><pre><code class="language-julia hljs">J_T_sm(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)</code></pre><p>calculates</p><p class="math-container">\[J_{T,\text{sm}} = 1 - F_{\text{sm}} \quad\in [0, 1].\]</p><p>All arguments are passed to <a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a> while evaluating <span>$F_{\text{sm}}$</span> in <a href="#QuantumControl.Functionals.F_sm"><code>F_sm</code></a>.</p><p><strong>Reference</strong></p><ul><li>[<a href="../../references/#PalaoPRA2003">12</a>] Palao and Kosloff,  Phys. Rev. A 68, 062308 (2003)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L657-L676">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.J_T_ss" href="#QuantumControl.Functionals.J_T_ss"><code>QuantumControl.Functionals.J_T_ss</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>State-to-state phase-insensitive functional.</p><pre><code class="language-julia hljs">J_T_ss(Ψ, trajectories; tau=taus(Ψ, trajectories); τ=tau)</code></pre><p>calculates</p><p class="math-container">\[J_{T,\text{ss}} = 1 - F_{\text{ss}} \in [0, 1].\]</p><p>All arguments are passed to <a href="#QuantumControl.Functionals.F_ss"><code>F_ss</code></a>.</p><p><strong>Reference</strong></p><ul><li>[<a href="../../references/#PalaoPRA2003">12</a>] Palao and Kosloff,  Phys. Rev. A 68, 062308 (2003)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L567-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.J_a_fluence" href="#QuantumControl.Functionals.J_a_fluence"><code>QuantumControl.Functionals.J_a_fluence</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Running cost for the pulse fluence.</p><pre><code class="language-julia hljs">J_a = J_a_fluence(pulsevals, tlist)</code></pre><p>calculates</p><p class="math-container">\[J_a = \sum_l \int_0^T |ϵ_l(t)|^2 dt = \left(\sum_{nl} |ϵ_{nl}|^2 \right) dt\]</p><p>where <span>$ϵ_{nl}$</span> are the values in the (vectorized) <code>pulsevals</code>, <code>n</code> is the index of the intervals of the time grid, and <span>$dt$</span> is the time step, taken from the first time interval of <code>tlist</code> and assumed to be uniform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L916-L932">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.gate_functional" href="#QuantumControl.Functionals.gate_functional"><code>QuantumControl.Functionals.gate_functional</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Convert a functional from acting on a gate to acting on propagated states.</p><pre><code class="nohighlight hljs">J_T = gate_functional(J_T_U; kwargs...)</code></pre><p>constructs a functional <code>J_T</code> that meets the requirements for for Krotov/GRAPE and <a href="#QuantumControl.Functionals.make_chi"><code>make_chi</code></a>. That is, the output <code>J_T</code> takes positional positional arguments <code>Ψ</code> and <code>trajectories</code>. The input functional <code>J_T_U</code> is assumed to have the signature <code>J_T_U(U; kwargs...)</code> where <code>U</code> is a matrix with elements <span>$U_{ij} = ⟨Ψ_i|Ψ_j⟩$</span>, where <span>$|Ψ_i⟩$</span> is the <code>initial_state</code> of the i&#39;th <code>trajectories</code> (assumed to be the i&#39;th canonical basis state) and <span>$|Ψ_j⟩$</span> is the result of forward-propagating <span>$|Ψ_j⟩$</span>. That is, <code>U</code> is the projection of the time evolution operator into the subspace defined by the basis in the <code>initial_states</code> of the  <code>trajectories</code>.</p><p><strong>See also</strong></p><ul><li><a href="#QuantumControl.Functionals.make_gate_chi"><code>make_gate_chi</code></a> — create a corresponding <code>chi</code> function that acts more efficiently than the general <a href="#QuantumControl.Functionals.make_chi"><code>make_chi</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L817-L838">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.make_chi" href="#QuantumControl.Functionals.make_chi"><code>QuantumControl.Functionals.make_chi</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Return a function that calculates <span>$|χ_k⟩ = -∂J_T/∂⟨Ψ_k|$</span>.</p><pre><code class="language-julia hljs">chi = make_chi(
    J_T,
    trajectories;
    mode=:any,
    automatic=:default,
    via=:automatic,  # one of :automatic, :tau, :states
)</code></pre><p>creates a function <code>chi(Ψ, trajectories)</code> or <code>chi(Ψ, trajectories; tau)</code> that returns a vector of states <code>χ</code> with <span>$|χ_k⟩ = -∂J_T/∂⟨Ψ_k|$</span>, where <span>$|Ψ_k⟩$</span> is the k&#39;th element of <code>Ψ</code>. These are the states used as the boundary condition for the backward propagation propagation in Krotov&#39;s method and GRAPE.</p><p>The resulting <code>chi</code> function takes the keyword argument <code>tau</code> if and only if <code>via=:tau</code> or <code>via=:automatic</code> (default) if the following conditions are met:</p><ul><li>All <code>trajectories</code> have a defined <code>target_state</code> component (not <code>nothing</code>)</li><li><code>J_T</code> takes <code>tau</code> as a keyword argument (determined via introspection)</li></ul><p>Both of these conditions are <em>requirements</em> for <code>via=:tau</code>.</p><p>Each <span>$|χₖ⟩$</span> is defined as a matrix calculus <a href="https://www.ekinakyurek.me/complex-derivatives-wirtinger/">Wirtinger derivative</a>,</p><p class="math-container">\[|χ_k(T)⟩ = -\frac{∂J_T}{∂⟨Ψ_k|} = -\frac{1}{2} ∇_{Ψ_k} J_T\,;\qquad
∇_{Ψ_k} J_T ≡ \frac{∂J_T}{\Re[Ψ_k]} + i \frac{∂J_T}{\Im[Ψ_k]}\,.\]</p><p>The function <code>J_T</code> must take a vector of states <code>Ψ</code> and a vector of <code>trajectories</code> as positional parameters. If <code>via=:tau</code>, it must also a vector <code>tau</code> as a keyword argument, see e.g. <code>J_T_sm</code>). that contains the overlap of the states <code>Ψ</code> with the target states from the <code>trajectories</code></p><p>The derivative can be calculated analytically of automatically (via automatic differentiation) depending on the value of <code>mode</code>. For <code>mode=:any</code>, an analytic derivative is returned if available, with a fallback to an automatic derivative.</p><p>If <code>mode=:analytic</code>, return an analytically known <span>$-∂J_T/∂⟨Ψ_k|$</span>, e.g.,</p><ul><li><a href="#QuantumControl.Functionals.J_T_sm"><code>QuantumControl.Functionals.J_T_sm</code></a> → <a href="#QuantumControl.Functionals.chi_sm"><code>QuantumControl.Functionals.chi_sm</code></a>,</li><li><a href="#QuantumControl.Functionals.J_T_re"><code>QuantumControl.Functionals.J_T_re</code></a> → <a href="#QuantumControl.Functionals.chi_re"><code>QuantumControl.Functionals.chi_re</code></a>,</li><li><a href="#QuantumControl.Functionals.J_T_ss"><code>QuantumControl.Functionals.J_T_ss</code></a> → <a href="#QuantumControl.Functionals.chi_ss"><code>QuantumControl.Functionals.chi_ss</code></a>.</li></ul><p>and throw an error if no analytic derivative is known.</p><p>If <code>mode=:automatic</code>, return an automatic derivative (even if an analytic derivative is known). The calculation of an automatic derivative  (whether via <code>mode=:any</code> or <code>mode=:automatic</code>) requires that a suitable framework (e.g., <code>Zygote</code> or <code>FiniteDifferences</code>) has been loaded. The loaded module must be passed as <code>automatic</code> keyword argument. Alternatively, it can be registered as a default value for <code>automatic</code> by calling <code>QuantumControl.set_default_ad_framework</code>.</p><p>When evaluating <span>$|χ_k⟩$</span> automatically, if <code>via=:states</code> is given , <span>$|χ_k(T)⟩$</span> is calculated directly as defined above from the gradient with respect to the states <span>$\{|Ψ_k(T)⟩\}$</span>.</p><p>If <code>via=:tau</code> is given instead, the functional <span>$J_T$</span> is considered a function of overlaps <span>$τ_k = ⟨Ψ_k^\tgt|Ψ_k(T)⟩$</span>. This requires that all <code>trajectories</code> define a <code>target_state</code> and that <code>J_T</code> calculates the value of the functional solely based on the values of <code>tau</code> passed as a keyword argument.  With only the complex conjugate <span>$τ̄_k = ⟨Ψ_k(T)|Ψ_k^\tgt⟩$</span> having an explicit dependency on <span>$⟨Ψ_k(T)|$</span>,  the chain rule in this case is</p><p class="math-container">\[|χ_k(T)⟩
= -\frac{∂J_T}{∂⟨Ψ_k|}
= -\left(
    \frac{∂J_T}{∂τ̄_k}
    \frac{∂τ̄_k}{∂⟨Ψ_k|}
  \right)
= - \frac{1}{2} (∇_{τ_k} J_T) |Ψ_k^\tgt⟩\,.\]</p><p>Again, we have used the definition of the Wirtinger derivatives,</p><p class="math-container">\[\begin{align*}
    \frac{∂J_T}{∂τ_k}
    &amp;≡ \frac{1}{2}\left(
        \frac{∂ J_T}{∂ \Re[τ_k]}
        - i \frac{∂ J_T}{∂ \Im[τ_k]}
    \right)\,,\\
    \frac{∂J_T}{∂τ̄_k}
    &amp;≡ \frac{1}{2}\left(
        \frac{∂ J_T}{∂ \Re[τ_k]}
        + i \frac{∂ J_T}{∂ \Im[τ_k]}
    \right)\,,
\end{align*}\]</p><p>and the definition of the Zygote gradient with respect to a complex scalar,</p><p class="math-container">\[∇_{τ_k} J_T = \left(
    \frac{∂ J_T}{∂ \Re[τ_k]}
    + i \frac{∂ J_T}{∂ \Im[τ_k]}
\right)\,.\]</p><div class="admonition is-success" id="Tip-22a4b1e00a91b2f7"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-22a4b1e00a91b2f7" title="Permalink"></a></header><div class="admonition-body"><p>In order to extend <code>make_chi</code> with an analytic implementation for a new <code>J_T</code> function, define a new method <code>make_analytic_chi</code> like so:</p><pre><code class="language-julia hljs">QuantumControl.Functionals.make_analytic_chi(::typeof(J_T_sm), trajectories) = chi_sm</code></pre><p>which links <code>make_chi</code> for <a href="#QuantumControl.Functionals.J_T_sm"><code>QuantumControl.Functionals.J_T_sm</code></a> to <a href="#QuantumControl.Functionals.chi_sm"><code>QuantumControl.Functionals.chi_sm</code></a>.</p></div></div><div class="admonition is-warning" id="Warning-7c5452369e0162fb"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-7c5452369e0162fb" title="Permalink"></a></header><div class="admonition-body"><p>Zygote is notorious for being buggy (silently returning incorrect gradients). Always test automatic derivatives against finite differences and/or other automatic differentiation frameworks.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L90-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.make_gate_chi" href="#QuantumControl.Functionals.make_gate_chi"><code>QuantumControl.Functionals.make_gate_chi</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Return a function to evaluate <span>$|χ_k⟩ = -∂J_T(Û)/∂⟨Ψ_k|$</span> via the chain rule.</p><pre><code class="language-julia hljs">chi = make_gate_chi(J_T_U, trajectories; automatic=:default, kwargs...)</code></pre><p>returns a function equivalent to</p><pre><code class="language-julia hljs">chi = make_chi(
    gate_functional(J_T_U; kwargs...),
    trajectories;
    mode=:automatic,
    automatic,
)</code></pre><p class="math-container">\[\begin{split}
    |χ_k⟩
    &amp;= -\frac{∂}{∂⟨Ψ_k|} J_T \\
    &amp;= - \frac{1}{2} \sum_i (∇_U J_T)_{ik} \frac{∂ U_{ik}}{∂⟨Ψ_k|} \\
    &amp;= - \frac{1}{2} \sum_i (∇_U J_T)_{ik} |Ψ_i⟩
\end{split}\]</p><p>where <span>$|Ψ_i⟩$</span> is the basis state stored as the <code>initial_state</code> of the i&#39;th trajectory, see <a href="#QuantumControl.Functionals.gate_functional"><code>gate_functional</code></a>.</p><p>The gradient <span>$∇_U J_T$</span> is obtained via automatic differentiation (AD). This requires that an AD package has been loaded (e.g., <code>using Zygote</code>). This package must either be passed as the <code>automatic</code> keyword argument, or the package must be set as the default AD provider using <a href="#QuantumControl.set_default_ad_framework"><code>QuantumControl.set_default_ad_framework</code></a>.</p><p>Compared to the more general <a href="#QuantumControl.Functionals.make_chi"><code>make_chi</code></a> with <code>mode=:automatic</code>, <code>make_gate_chi</code> will generally have a slightly smaller numerical overhead, as it pushes the use of automatic differentiation down by one level.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L851-L890">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.make_grad_J_a" href="#QuantumControl.Functionals.make_grad_J_a"><code>QuantumControl.Functionals.make_grad_J_a</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Return a function to evaluate <span>$∂J_a/∂ϵ_{ln}$</span> for a pulse value running cost.</p><pre><code class="language-julia hljs">grad_J_a = make_grad_J_a(
    J_a,
    tlist;
    mode=:any,
    automatic=:default,
)</code></pre><p>returns a function so that <code>∇J_a = grad_J_a(pulsevals, tlist)</code> sets that returns a vector <code>∇J_a</code> containing the vectorized elements <span>$∂J_a/∂ϵ_{ln}$</span>. The function <code>J_a</code> must have the interface <code>J_a(pulsevals, tlist)</code>, see, e.g., <a href="#QuantumControl.Functionals.J_a_fluence"><code>J_a_fluence</code></a>.</p><p>The parameters <code>mode</code> and <code>automatic</code> are handled as in <a href="#QuantumControl.Functionals.make_chi"><code>make_chi</code></a>, where <code>mode</code> is one of <code>:any</code>, <code>:analytic</code>, <code>:automatic</code>, and <code>automatic</code> is he loaded module of an automatic differentiation framework, where <code>:default</code> refers to the framework set with <code>QuantumControl.set_default_ad_framework</code>.</p><div class="admonition is-success" id="Tip-1a522a7f0e9a36e6"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-1a522a7f0e9a36e6" title="Permalink"></a></header><div class="admonition-body"><p>In order to extend <code>make_grad_J_a</code> with an analytic implementation for a new <code>J_a</code> function, define a new method <code>make_analytic_grad_J_a</code> like so:</p><pre><code class="language-julia hljs">make_analytic_grad_J_a(::typeof(J_a_fluence), tlist) = grad_J_a_fluence</code></pre><p>which links <code>make_grad_J_a</code> for <a href="#QuantumControl.Functionals.J_a_fluence"><code>J_a_fluence</code></a> to <a href="#QuantumControl.Functionals.grad_J_a_fluence"><code>grad_J_a_fluence</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L363-L396">source</a></section></article><h4 id="Private-Symbols"><a class="docs-heading-anchor" href="#Private-Symbols">Private Symbols</a><a id="Private-Symbols-1"></a><a class="docs-heading-anchor-permalink" href="#Private-Symbols" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.F_re" href="#QuantumControl.Functionals.F_re"><code>QuantumControl.Functionals.F_re</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Real-part fidelity.</p><pre><code class="language-julia hljs">F_re(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)</code></pre><p>calculates</p><p class="math-container">\[F_{\text{re}}
    = \Re[f_{τ}]
    = \Re\left[
        \frac{1}{N} \sum_{k=1}^{N} w_k τ_k
    \right]
    \quad\in \begin{cases}
    [-1, 1] &amp; \text{in Hilbert space} \\
    [0, 1] &amp; \text{in Liouville space.}
\end{cases}\]</p><p>with <span>$w_k$</span> the weight for the k&#39;th trajectory and <span>$τ_k$</span> the overlap of the k&#39;th propagated state with the k&#39;th target state, and <span>$N$</span> the number of trajectories.</p><p>All arguments are passed to <a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a> to evaluate <span>$f_τ$</span>.</p><p><strong>Reference</strong></p><ul><li>[<a href="../../references/#PalaoPRA2003">12</a>] Palao and Kosloff,  Phys. Rev. A 68, 062308 (2003)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L718-L748">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.taus" href="#QuantumControl.Functionals.taus"><code>QuantumControl.Functionals.taus</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Overlaps of target states with propagates states</p><pre><code class="language-julia hljs">τ = taus(Ψ, trajectories)</code></pre><p>calculates a vector of values <span>$τ_k = ⟨Ψ_k^{tgt}|Ψ_k⟩$</span> where <span>$|Ψ_k^{tgt}⟩$</span> is the <code>traj.target_state</code> of the <span>$k$</span>&#39;th element of <code>trajectories</code> and <span>$|Ψₖ⟩$</span> is the <span>$k$</span>&#39;th element of <code>Ψ</code>.</p><p>The definition of the τ values with <span>$Ψ_k^{tgt}$</span> on the left (overlap of target states with propagated states, as opposed to overlap of propagated states with target states) matches Refs. [<a href="../../references/#PalaoPRA2003">12</a>] and [<a href="../../references/#GoerzQ2022">19</a>].</p><p>The function requires that each trajectory defines a target state. See also <a href="#QuantumControl.Functionals.taus!"><code>taus!</code></a> for an in-place version that includes well-defined error handling for any trajectories whose <code>target_state</code> property is <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L31-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.F_ss" href="#QuantumControl.Functionals.F_ss"><code>QuantumControl.Functionals.F_ss</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>State-to-state phase-insensitive fidelity.</p><pre><code class="language-julia hljs">F_ss(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)</code></pre><p>calculates</p><p class="math-container">\[F_{\text{ss}} = \frac{1}{N} \sum_{k=1}^{N} w_k |τ_k|^2 \quad\in [0, 1]\]</p><p>with <span>$N$</span>, <span>$w_k$</span> and <span>$τ_k$</span> as in <a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a>.</p><p><strong>Reference</strong></p><ul><li>[<a href="../../references/#PalaoPRA2003">12</a>] Palao and Kosloff,  Phys. Rev. A 68, 062308 (2003)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L536-L554">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.chi_ss" href="#QuantumControl.Functionals.chi_ss"><code>QuantumControl.Functionals.chi_ss</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Backward boundary states <span>$|χ⟩$</span> for functional <a href="#QuantumControl.Functionals.J_T_ss"><code>J_T_ss</code></a>.</p><pre><code class="language-julia hljs">χ = chi_ss(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)</code></pre><p>calculates the vector of states <code>χ</code> according to</p><p class="math-container">\[|χ_k⟩
= -\frac{∂ J_{T,\text{ss}}}{∂ ⟨Ψ_k(T)|}
= \frac{1}{N} w_k τ_k |Ψ^{\tgt}_k⟩\,,\]</p><p>with <span>$|Ψ^{\tgt}_k⟩$</span>, <span>$τ_k$</span> and <span>$w_k$</span> as defined in <a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a>.</p><p>Note: this function can be obtained with <code>make_chi(J_T_ss, trajectories)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L590-L608">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.grad_J_a_fluence" href="#QuantumControl.Functionals.grad_J_a_fluence"><code>QuantumControl.Functionals.grad_J_a_fluence</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Analytic derivative for <a href="#QuantumControl.Functionals.J_a_fluence"><code>J_a_fluence</code></a>.</p><pre><code class="language-julia hljs">∇J_a = grad_J_a_fluence(pulsevals, tlist)</code></pre><p>returns the <code>∇J_a</code>, which contains the (vectorized) elements <span>$2 ϵ_{nl} dt$</span>, where <span>$ϵ_{nl}$</span> are the (vectorized) elements of <code>pulsevals</code> and <span>$dt$</span> is the time step, taken from the first time interval of <code>tlist</code> and assumed to be uniform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L938-L949">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.chi_sm" href="#QuantumControl.Functionals.chi_sm"><code>QuantumControl.Functionals.chi_sm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Backward boundary states <span>$|χ⟩$</span> for functional <a href="#QuantumControl.Functionals.J_T_sm"><code>J_T_sm</code></a>.</p><pre><code class="language-julia hljs">χ = chi_sm(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)</code></pre><p>calculates the vector of states <code>χ</code> according to</p><p class="math-container">\[|χ_k⟩
= -\frac{\partial J_{T,\text{sm}}}{\partial ⟨Ψ_k(T)|}
= \frac{1}{N^2} w_k \sum_{j}^{N} w_j τ_j |Ψ_k^{\tgt}⟩\]</p><p>with <span>$|Ψ^{\tgt}_k⟩$</span>, <span>$τ_j$</span> and <span>$w_k$</span> as defined in <a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a>.</p><p>Note: this function can be obtained with <code>make_chi(J_T_sm, trajectories)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L681-L699">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.F_sm" href="#QuantumControl.Functionals.F_sm"><code>QuantumControl.Functionals.F_sm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Square-modulus fidelity.</p><pre><code class="language-julia hljs">F_sm(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)</code></pre><p>calculates</p><p class="math-container">\[F_{\text{sm}}
    = |f_τ|^2
    = \left\vert\frac{1}{N} \sum_{k=1}^{N} w_k τ_k\right\vert^2
    = \frac{1}{N^2} \sum_{k=1}^{N} \sum_{j=1}^{N} w_k w_j τ̄_k τ_j
    \quad\in [0, 1]\,,\]</p><p>with <span>$w_k$</span> the weight for the k&#39;th trajectory and <span>$τ_k$</span> the overlap of the k&#39;th propagated state with the k&#39;th target state, <span>$τ̄_k$</span> the complex conjugate of <span>$τ_k$</span>, and <span>$N$</span> the number of trajectories.</p><p>All arguments are passed to <a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a> to evaluate <span>$f_τ$</span>.</p><p><strong>Reference</strong></p><ul><li>[<a href="../../references/#PalaoPRA2003">12</a>] Palao and Kosloff,  Phys. Rev. A 68, 062308 (2003)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L626-L652">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.chi_re" href="#QuantumControl.Functionals.chi_re"><code>QuantumControl.Functionals.chi_re</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Backward boundary states <span>$|χ⟩$</span> for functional <a href="#QuantumControl.Functionals.J_T_re"><code>J_T_re</code></a>.</p><pre><code class="language-julia hljs">χ chi_re(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)</code></pre><p>calculates the vector of states <code>χ</code> according to</p><p class="math-container">\[|χ_k⟩
= -\frac{∂ J_{T,\text{re}}}{∂ ⟨Ψ_k(T)|}
= \frac{1}{2N} w_k |Ψ^{\tgt}_k⟩\]</p><p>with <span>$|Ψ^{\tgt}_k⟩$</span> and <span>$w_k$</span> as defined in <a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a>.</p><p>Note: this function can be obtained with <code>make_chi(J_T_re, trajectories)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L780-L799">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.taus!" href="#QuantumControl.Functionals.taus!"><code>QuantumControl.Functionals.taus!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Overlaps of target states with propagates states, calculated in-place.</p><pre><code class="language-julia hljs">taus!(τ, Ψ, trajectories; ignore_missing_target_state=false)</code></pre><p>overwrites the complex vector <code>τ</code> with the results of <a href="#QuantumControl.Functionals.taus"><code>taus(Ψ, trajectories)</code></a>.</p><p>Throws an <code>ArgumentError</code> if any of trajectories have a <code>target_state</code> of <code>nothing</code>. If <code>ignore_missing_target_state=true</code>, values in <code>τ</code> instead will remain unchanged for any trajectories with a missing target state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L58-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Functionals.f_tau" href="#QuantumControl.Functionals.f_tau"><code>QuantumControl.Functionals.f_tau</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Average complex overlap of the target states with forward-propagated states.</p><pre><code class="language-julia hljs">f_tau(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)</code></pre><p>calculates</p><p class="math-container">\[f_τ = \frac{1}{N} \sum_{k=1}^{N} w_k τ_k\]</p><p>with</p><p class="math-container">\[τ_k = ⟨Ψ_k^\tgt|Ψ_k(T)⟩\]</p><p>in Hilbert space, or</p><p class="math-container">\[τ_k = \tr[ρ̂_k^{\tgt\,\dagger} ρ̂_k(T)]\]</p><p>in Liouville space, where <span>$|Ψ_k⟩$</span> or <span>$ρ̂_k$</span> are the elements of <code>Ψ</code>, and <span>$|Ψ_k^\tgt⟩$</span> or <span>$ρ̂_k^\tgt$</span> are the target states from the <code>target_state</code> field of the <code>trajectories</code>. If <code>tau</code>/<code>τ</code> is given as a keyword argument, it must contain the values <code>τ_k</code> according to the above definition. Otherwise, the <span>$τ_k$</span> values will be calculated internally, see <a href="#QuantumControl.Functionals.taus"><code>taus</code></a>.</p><p><span>$N$</span> is the number of trajectories, and <span>$w_k$</span> is the <code>weight</code> attribute for each trajectory. The weights are not automatically normalized, they are assumed to have values such that the resulting <span>$f_τ$</span> lies in the unit circle of the complex plane. Usually, this means that the weights should sum to <span>$N$</span>.</p><p><strong>Reference</strong></p><ul><li>[<a href="../../references/#PalaoPRA2003">12</a>] Palao and Kosloff,  Phys. Rev. A 68, 062308 (2003)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/functionals.jl#L478-L519">source</a></section></article><h2 id="QuantumControlGeneratorsLocalAPI"><a class="docs-heading-anchor" href="#QuantumControlGeneratorsLocalAPI"><code>QuantumControl.Generators</code></a><a id="QuantumControlGeneratorsLocalAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlGeneratorsLocalAPI" title="Permalink"></a></h2><p>Re-exported Symbols:</p><ul><li><a href="../quantum_propagators/#QuantumPropagators.Generators.Generator"><code>Generator</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Generators.Operator"><code>Operator</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Generators.ScaledOperator"><code>ScaledOperator</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Generators.hamiltonian"><code>hamiltonian</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Generators.liouvillian"><code>liouvillian</code></a></li></ul><h2 id="QuantumControlInterfacesLocalAPI"><a class="docs-heading-anchor" href="#QuantumControlInterfacesLocalAPI"><code>QuantumControl.Interfaces</code></a><a id="QuantumControlInterfacesLocalAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlInterfacesLocalAPI" title="Permalink"></a></h2><p>Public Symbols:</p><ul><li><a href="#QuantumControl.Interfaces.check_amplitude"><code>check_amplitude</code></a></li><li><a href="#QuantumControl.Interfaces.check_generator"><code>check_generator</code></a></li></ul><p>Re-exported Symbols:</p><ul><li><a href="../quantum_propagators/#QuantumPropagators.Interfaces.check_control"><code>check_control</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Interfaces.check_operator"><code>check_operator</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Interfaces.check_parameterized"><code>check_parameterized</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Interfaces.check_parameterized_function"><code>check_parameterized_function</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Interfaces.check_state"><code>check_state</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Interfaces.supports_inplace"><code>supports_inplace</code></a></li></ul><h4 id="Public-Symbols-3"><a class="docs-heading-anchor" href="#Public-Symbols-3">Public Symbols</a><a class="docs-heading-anchor-permalink" href="#Public-Symbols-3" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Interfaces.check_amplitude" href="#QuantumControl.Interfaces.check_amplitude"><code>QuantumControl.Interfaces.check_amplitude</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Check an amplitude in a <a href="../../glossary/#Generator"><code>Generator</code></a> in the context of optimal control.</p><pre><code class="nohighlight hljs">@test check_amplitude(
    ampl; tlist, for_gradient_optimization=true, quiet=false
)</code></pre><p>verifies that the given <code>ampl</code> is a valid element in the list of <code>amplitudes</code> of a <a href="../../glossary/#Generator"><code>Generator</code></a> object. This checks all the conditions of <a href="../quantum_propagators/#QuantumPropagators.Interfaces.check_amplitude"><code>QuantumPropagators.Interfaces.check_amplitude</code></a>. In addition, the following conditions must be met.</p><p>If <code>for_gradient_optimization</code>:</p><ul><li>The function <a href="#QuantumControl.Controls.get_control_deriv"><code>get_control_deriv(ampl, control)</code></a> must be defined</li><li>If <code>ampl</code> does not depend on <code>control</code>, <a href="#QuantumControl.Controls.get_control_deriv"><code>get_control_deriv(ampl, control)</code></a> must return <code>0.0</code></li><li>If <code>ampl</code> depends on <code>control</code>, <a href="#QuantumControl.Controls.get_control_deriv"><code>u = get_control_deriv(ampl, control)</code></a> must return an object <code>u</code> so that <code>evaluate(u, tlist, n)</code> returns a Number. In most cases, <code>u</code> itself will be a Number. For more unusual amplitudes, e.g., an amplitude with a non-linear dependency on the controls, <code>u</code> may be another amplitude. The controls in <code>u</code> (as obtained by <a href="../quantum_propagators/#QuantumPropagators.Controls.get_controls"><code>QuantumPropagators.Controls.get_controls</code></a>) must be a subset of the controls in <code>ampl</code>.</li></ul><p>The function returns <code>true</code> for a valid amplitude and <code>false</code> for an invalid amplitude. Unless <code>quiet=true</code>, it will log an error to indicate which of the conditions failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/interfaces/amplitude.jl#L7-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Interfaces.check_generator" href="#QuantumControl.Interfaces.check_generator"><code>QuantumControl.Interfaces.check_generator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Check the dynamical <code>generator</code> in the context of optimal control.</p><pre><code class="nohighlight hljs">@test check_generator(
    generator; state, tlist,
    for_expval=true, for_pwc=true, for_time_continuous=false,
    for_parameterization=false, for_gradient_optimization=true,
    atol=1e-15, quiet=false
)</code></pre><p>verifies the given <code>generator</code>. This checks all the conditions of <a href="../quantum_propagators/#QuantumPropagators.Interfaces.check_generator"><code>QuantumPropagators.Interfaces.check_generator</code></a>. In addition, the following conditions must be met.</p><p>If <code>for_gradient_optimization</code>:</p><ul><li><a href="#QuantumControl.Controls.get_control_derivs"><code>get_control_derivs(generator, controls)</code></a> must be defined and return a vector containing the result of <a href="#QuantumControl.Controls.get_control_deriv"><code>get_control_deriv(generator, control)</code></a> for every <code>control</code> in <code>controls</code>.</li><li><a href="#QuantumControl.Controls.get_control_deriv"><code>get_control_deriv(generator, control)</code></a> must return an object that passes the less restrictive <a href="../quantum_propagators/#QuantumPropagators.Interfaces.check_generator"><code>QuantumPropagators.Interfaces.check_generator</code></a> if <code>control</code> is in <code>get_controls(generator)</code>. The controls in the derivative (if any) must be a subset of the controls in <code>generator.</code></li><li><a href="#QuantumControl.Controls.get_control_deriv"><code>get_control_deriv(generator, control)</code></a> must return <code>nothing</code> if <code>control</code> is not in <a href="../quantum_propagators/#QuantumPropagators.Controls.get_controls"><code>get_controls(generator)</code></a></li><li>If <code>generator</code> is a <a href="../../glossary/#Generator"><code>Generator</code></a> instance, every <code>ampl</code> in <code>generator.amplitudes</code> must pass <a href="#QuantumControl.Interfaces.check_amplitude"><code>check_amplitude(ampl; tlist)</code></a>.</li></ul><p>The function returns <code>true</code> for a valid generator and <code>false</code> for an invalid generator. Unless <code>quiet=true</code>, it will log an error to indicate which of the conditions failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/interfaces/generator.jl#L8-L45">source</a></section></article><h2 id="QuantumControlPulseParameterizationsLocalAPI"><a class="docs-heading-anchor" href="#QuantumControlPulseParameterizationsLocalAPI"><code>QuantumControl.PulseParameterizations</code></a><a id="QuantumControlPulseParameterizationsLocalAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlPulseParameterizationsLocalAPI" title="Permalink"></a></h2><p>Public Symbols:</p><ul><li><a href="#QuantumControl.PulseParameterizations.LogisticParameterization"><code>LogisticParameterization</code></a></li><li><a href="#QuantumControl.PulseParameterizations.LogisticSqParameterization"><code>LogisticSqParameterization</code></a></li><li><a href="#QuantumControl.PulseParameterizations.ParameterizedAmplitude"><code>ParameterizedAmplitude</code></a></li><li><a href="#QuantumControl.PulseParameterizations.SquareParameterization"><code>SquareParameterization</code></a></li><li><a href="#QuantumControl.PulseParameterizations.TanhParameterization"><code>TanhParameterization</code></a></li><li><a href="#QuantumControl.PulseParameterizations.TanhSqParameterization"><code>TanhSqParameterization</code></a></li></ul><p>Private Symbols:</p><ul><li><a href="#QuantumControl.PulseParameterizations.PulseParameterization"><code>PulseParameterization</code></a></li></ul><h4 id="Public-Symbols-4"><a class="docs-heading-anchor" href="#Public-Symbols-4">Public Symbols</a><a class="docs-heading-anchor-permalink" href="#Public-Symbols-4" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.PulseParameterizations.LogisticParameterization" href="#QuantumControl.PulseParameterizations.LogisticParameterization"><code>QuantumControl.PulseParameterizations.LogisticParameterization</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parameterization with a Logistic function that enforces <code>a_min &lt; a(t) &lt; a_max</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/pulse_parameterizations.jl#L107-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.PulseParameterizations.LogisticSqParameterization" href="#QuantumControl.PulseParameterizations.LogisticSqParameterization"><code>QuantumControl.PulseParameterizations.LogisticSqParameterization</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parameterization with a Logistic-Square function that enforces <code>0 ≤ a(t) &lt; a_max</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/pulse_parameterizations.jl#L135-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.PulseParameterizations.ParameterizedAmplitude" href="#QuantumControl.PulseParameterizations.ParameterizedAmplitude"><code>QuantumControl.PulseParameterizations.ParameterizedAmplitude</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An amplitude determined by a pulse parameterization.</p><p>That is, <span>$a(t) = a(ϵ(t))$</span> with a bijective mapping between the value of <span>$a(t)$</span> and <span>$ϵ(t)$</span>, e.g. <span>$a(t) = ϵ^2(t)$</span> (a <a href="#QuantumControl.PulseParameterizations.SquareParameterization"><code>SquareParameterization</code></a>). Optionally, the amplitude may be multiplied with an additional shape function, cf. <a href="../quantum_propagators/#QuantumPropagators.Amplitudes.ShapedAmplitude"><code>ShapedAmplitude</code></a>.</p><pre><code class="language-julia hljs">ampl = ParameterizedAmplitude(control; parameterization)</code></pre><p>initializes <span>$a(t) = a(ϵ(t)$</span> where <span>$ϵ(t)$</span> is the <code>control</code>, and the mandatory keyword argument <code>parameterization</code> is a <a href="#QuantumControl.PulseParameterizations.PulseParameterization"><code>PulseParameterization</code></a>. The <code>control</code> must either be a vector of values discretized to the midpoints of a time grid, or a callable <code>control(t)</code>.</p><pre><code class="language-julia hljs">ampl = ParameterizedAmplitude(control; parameterization, shape=shape)</code></pre><p>initializes <span>$a(t) = S(t) a(ϵ(t))$</span> where <span>$S(t)$</span> is the given <code>shape</code>. It must be a vector if <code>control</code> is a vector, or a callable <code>shape(t)</code> if <code>control</code> is a callable.</p><pre><code class="language-julia hljs">ampl = ParameterizedAmplitude(control, tlist; parameterization, shape=shape)</code></pre><p>discretizes <code>control</code> and <code>shape</code> (if given) to the midpoints of <code>tlist</code> before initialization.</p><pre><code class="language-julia hljs">ampl = ParameterizedAmplitude(
    amplitude, tlist; parameterization, shape=shape, parameterize=true
)</code></pre><p>initializes <span>$ã(t) = S(t) a(t)$</span> where <span>$a(t)$</span> is the input <code>amplitude</code>. First, if <code>amplitude</code> is a callable <code>amplitude(t)</code>, it is discretized to the midpoints of <code>tlist</code>. Then, a <code>control</code> <span>$ϵ(t)$</span> is calculated so that <span>$a(t) ≈ a(ϵ(t))$</span>. Clippling may occur if the values in <code>amplitude</code> cannot represented with the given <code>parameterization</code>. Lastly, <code>ParameterizedAmplitude(control; parameterization, shape)</code> is initialized with the calculated <code>control</code>.</p><p>Note that the <code>tlist</code> keyword argument is required when <code>parameterize=true</code> is given, even if <code>amplitude</code> is already a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/pulse_parameterizations.jl#L168-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.PulseParameterizations.SquareParameterization" href="#QuantumControl.PulseParameterizations.SquareParameterization"><code>QuantumControl.PulseParameterizations.SquareParameterization</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parameterization a(t) = ϵ²(t), enforcing pulse values <span>$a(t) ≥ 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/pulse_parameterizations.jl#L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.PulseParameterizations.TanhParameterization" href="#QuantumControl.PulseParameterizations.TanhParameterization"><code>QuantumControl.PulseParameterizations.TanhParameterization</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parameterization with a tanh function that enforces <code>a_min &lt; a(t) &lt; a_max</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/pulse_parameterizations.jl#L57-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.PulseParameterizations.TanhSqParameterization" href="#QuantumControl.PulseParameterizations.TanhSqParameterization"><code>QuantumControl.PulseParameterizations.TanhSqParameterization</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parameterization with a tanh² function that enforces <code>0 ≤ a(t) &lt; a_max</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/pulse_parameterizations.jl#L83-L85">source</a></section></article><h4 id="Private-Symbols-2"><a class="docs-heading-anchor" href="#Private-Symbols-2">Private Symbols</a><a class="docs-heading-anchor-permalink" href="#Private-Symbols-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.PulseParameterizations.PulseParameterization" href="#QuantumControl.PulseParameterizations.PulseParameterization"><code>QuantumControl.PulseParameterizations.PulseParameterization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Specification for a &quot;time-local&quot; pulse parameterization.</p><p>The parameterization is given as a collection of three functions:</p><ul><li><span>$a(ϵ(t))$</span></li><li><span>$ϵ(a(t))$</span></li><li><span>$∂a/∂ϵ$</span> as a function of <span>$ϵ(t)$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/pulse_parameterizations.jl#L20-L28">source</a></section></article><h2 id="QuantumControlShapesLocalAPI"><a class="docs-heading-anchor" href="#QuantumControlShapesLocalAPI"><code>QuantumControl.Shapes</code></a><a id="QuantumControlShapesLocalAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlShapesLocalAPI" title="Permalink"></a></h2><p>Re-exported Symbols:</p><ul><li><a href="../quantum_propagators/#QuantumPropagators.Shapes.blackman"><code>blackman</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Shapes.box"><code>box</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Shapes.flattop"><code>flattop</code></a></li></ul><h2 id="QuantumControlStorageLocalAPI"><a class="docs-heading-anchor" href="#QuantumControlStorageLocalAPI"><code>QuantumControl.Storage</code></a><a id="QuantumControlStorageLocalAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlStorageLocalAPI" title="Permalink"></a></h2><p>Re-exported Symbols:</p><ul><li><a href="../quantum_propagators/#QuantumPropagators.Storage.get_from_storage"><code>get_from_storage</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Storage.get_from_storage!"><code>get_from_storage!</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Storage.init_storage"><code>init_storage</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Storage.map_observable"><code>map_observable</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Storage.map_observables"><code>map_observables</code></a></li><li><a href="../quantum_propagators/#QuantumPropagators.Storage.write_to_storage!"><code>write_to_storage!</code></a></li></ul><h2 id="QuantumControlWorkflowsLocalAPI"><a class="docs-heading-anchor" href="#QuantumControlWorkflowsLocalAPI"><code>QuantumControl.Workflows</code></a><a id="QuantumControlWorkflowsLocalAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlWorkflowsLocalAPI" title="Permalink"></a></h2><p>Public Symbols:</p><ul><li><a href="#QuantumControl.Workflows.@optimize_or_load"><code>@optimize_or_load</code></a></li><li><a href="#QuantumControl.Workflows.load_optimization"><code>load_optimization</code></a></li><li><a href="#QuantumControl.Workflows.run_or_load"><code>run_or_load</code></a></li><li><a href="#QuantumControl.Workflows.save_optimization"><code>save_optimization</code></a></li></ul><h4 id="Public-Symbols-5"><a class="docs-heading-anchor" href="#Public-Symbols-5">Public Symbols</a><a class="docs-heading-anchor-permalink" href="#Public-Symbols-5" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Workflows.@optimize_or_load" href="#QuantumControl.Workflows.@optimize_or_load"><code>QuantumControl.Workflows.@optimize_or_load</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Run <a href="#QuantumControl.optimize"><code>optimize</code></a> and store the result, or load the result if it exists.</p><pre><code class="language-julia hljs">result = @optimize_or_load(
    file,
    problem;
    method,
    force=false,
    verbose=true,
    metadata=nothing,
    logfile=nothing,
    kwargs...
)</code></pre><p>runs <code>result = optimize(problem; method, kwargs...)</code> and stores <code>result</code> in <code>file</code> in the JLD2 format. Note that the <code>method</code> keyword argument is mandatory.</p><p>In addition to the <code>result</code>, the data in the output <code>file</code> can also contain metadata. By default, this is &quot;script&quot; with the file name and line number of where <code>@optimize_or_load</code> was called, as well as data from the dict <code>metadata</code> mapping arbitrary (string) keys to values. Lastly, the data contains truncated captured output (up to 1kB of both the beginning and end of the output) from the optimization.</p><p>If <code>logfile</code> is given as the path to a file, both <code>stdout</code> and <code>stderr</code> from <code>optimize</code> are redirected into the given file.</p><p>If <code>file</code> already exists (and <code>force=false</code>), load the <code>result</code> from that file instead of running the optimization, and print any (truncated) captured output.</p><p>All other <code>kwargs</code> are passed directly to <a href="#QuantumControl.optimize"><code>optimize</code></a>.</p><p>For methods that support this, <code>@optimize_or_load</code> will set up a callback to dump the optimization result to <code>file</code> in case of an unexpected program shutdown, see <a href="#QuantumControl.set_atexit_save_optimization"><code>set_atexit_save_optimization</code></a>.</p><p><strong>Related Functions</strong></p><ul><li><a href="#QuantumControl.Workflows.run_or_load"><code>run_or_load</code></a>  — a function for more general long-running calculations.</li><li><a href="#QuantumControl.Workflows.load_optimization"><code>load_optimization</code></a>: Function to load a file produced by <code>@optimize_or_load</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/workflows.jl#L323-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Workflows.load_optimization" href="#QuantumControl.Workflows.load_optimization"><code>QuantumControl.Workflows.load_optimization</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Load a previously stored optimization.</p><pre><code class="language-julia hljs">result = load_optimization(file; verbose=false, kwargs...)</code></pre><p>recovers a <code>result</code> previously stored by <a href="#QuantumControl.Workflows.@optimize_or_load"><code>@optimize_or_load</code></a> or <a href="#QuantumControl.Workflows.save_optimization"><code>save_optimization</code></a>.</p><pre><code class="language-julia hljs">result, metadata = load_optimization(file; return_metadata=true, kwargs...)</code></pre><p>also obtains a metadata dict, see <a href="#QuantumControl.Workflows.@optimize_or_load"><code>@optimize_or_load</code></a>. This dict maps string keys to values.</p><p>Calling <code>load_optimization</code> with <code>verbose=true</code> will <code>@info</code> the metadata after loading the file</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/workflows.jl#L430-L449">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Workflows.run_or_load" href="#QuantumControl.Workflows.run_or_load"><code>QuantumControl.Workflows.run_or_load</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Run some code and write the result to file, or load from the file if it exists.</p><pre><code class="language-julia hljs">data = run_or_load(
    file;
    save=(endswith(file, &quot;.jld2&quot;) ? JLD2.save_object : FileIO.save),
    load=(endswith(file, &quot;.jld2&quot;) ? JLD2.load_object : FileIO.load),
    force=false,
    verbose=true,
    kwargs...
) do
    data = Dict()  # ...  # something that can be saved to / loaded from file
    return data
end</code></pre><p>runs the code in the block and stores <code>data</code> in the given <code>file</code>. If <code>file</code> already exists, skip running the code and instead return the data in <code>file</code>.</p><p>If <code>force</code> is <code>True</code>, run the code whether or not <code>file</code> exists, potentially overwriting it.</p><p>With <code>verbose=true</code>, information about the status of <code>file</code> will be shown as <code>@info</code>.</p><p>The <code>data</code> returned by the code block must be compatible with the format of <code>file</code> and the <code>save</code>/<code>load</code> functions. When using <code>JLD2.save_object</code> and <code>JLD2.load_object</code>, almost any data can be written, so this should be particularly safe. More generally, when using <code>FileIO.save</code> and <code>FileIO.load</code>, see the <a href="https://juliaio.github.io/FileIO.jl/stable/registry/">FileIO registry</a> for details. A common examples would be a <a href="https://dataframes.juliadata.org/stable/"><code>DataFrame</code></a> being written to a <code>.csv</code> file.</p><p><strong>See also</strong></p><ul><li><a href="#QuantumControl.Workflows.@optimize_or_load"><code>@optimize_or_load</code></a> — for wrapping around <a href="#QuantumControl.optimize"><code>optimize</code></a></li><li><a href="https://juliadynamics.github.io/DrWatson.jl/stable/save/#DrWatson.@produce_or_load"><code>DrWatson.@produce_or_load</code></a> — a similar but more opinionated function with automatic naming</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/workflows.jl#L13-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.Workflows.save_optimization" href="#QuantumControl.Workflows.save_optimization"><code>QuantumControl.Workflows.save_optimization</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Write an optimization result to file.</p><pre><code class="language-julia hljs">save_optimization(file, result; metadata=nothing)</code></pre><p>writes the result obtained from a call to <code>optimize</code> to the given <code>file</code> in JLD2 format. If given, <code>metadata</code> is a dict of additional data that will be stored with the result. The <code>metadata</code> dict should use strings as keys.</p><p><strong>See also</strong></p><ul><li><a href="#QuantumControl.Workflows.load_optimization"><code>load_optimization</code></a>: Function to load a file produced by <a href="#QuantumControl.Workflows.@optimize_or_load"><code>@optimize_or_load</code></a> or <a href="#QuantumControl.Workflows.save_optimization"><code>save_optimization</code></a></li><li><a href="#QuantumControl.Workflows.@optimize_or_load"><code>@optimize_or_load</code></a>: Run <a href="#QuantumControl.optimize"><code>optimize</code></a> and <a href="#QuantumControl.Workflows.save_optimization"><code>save_optimization</code></a> in one go.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/efa08e787a4adaeac293ce982d719bbad93d0818/src/workflows.jl#L400-L417">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quantum_control/">« QuantumControl</a><a class="docs-footer-nextpage" href="../quantum_propagators/">QuantumPropagators »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/QuantumControl.jl">QuantumControl.jl</a> v0.11.3 docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 1 October 2025 03:59">Wednesday 1 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

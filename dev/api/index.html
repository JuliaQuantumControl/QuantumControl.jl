<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · QuantumControl.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://juliaquantumcontrol.github.io/QuantumControl.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumControl.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../manual/">User Manual</a></li><li><a class="tocitem" href="../howto/">Howto</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#QuantumControl"><span>QuantumControl</span></a></li><li><a class="tocitem" href="#Krotov"><span>Krotov</span></a></li><li><a class="tocitem" href="#QuantumControlBase"><span>QuantumControlBase</span></a></li><li><a class="tocitem" href="#QuantumPropagators"><span>QuantumPropagators</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/master/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><ul><li><a href="#API">API</a></li><ul><li><a href="#QuantumControl">QuantumControl</a></li><ul><li><a href="#QuantumControl.shapes"><code>QuantumControl.shapes</code></a></li><li><a href="#QuantumControl.functionals"><code>QuantumControl.functionals</code></a></li></ul><li><a href="#Krotov">Krotov</a></li><ul><li><a href="#Public">Public</a></li><li><a href="#Private">Private</a></li></ul><li><a href="#QuantumControlBase">QuantumControlBase</a></li><ul><li><a href="#Public-2">Public</a></li><li><a href="#Private-2">Private</a></li></ul><li><a href="#QuantumPropagators">QuantumPropagators</a></li><ul><li><a href="#Public-3">Public</a></li><li><a href="#Private-3">Private</a></li></ul><li><a href="#Index">Index</a></li></ul></ul><h2 id="QuantumControl"><a class="docs-heading-anchor" href="#QuantumControl">QuantumControl</a><a id="QuantumControl-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.optimize" href="#QuantumControl.optimize"><code>QuantumControl.optimize</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Optimize a quantum control problem.</p><pre><code class="language-julia hljs">opt_result = optimize(problem; method=&lt;method&gt;, kwargs...)</code></pre><p>optimizes towards a solution of given <code>problem</code> with the given optimization <code>method</code>. All keyword arguments update (overwrite) parameters in <code>problem</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/36d38bb46a50df5dcf3fce86770b371200753be6/src/optimize.jl#L3-L12">source</a></section><section><div><pre><code class="language-julia hljs">opt_result = optimize(problem; method=:krotov, kwargs...)</code></pre><p>optimizes <code>problem</code> using Krotov&#39;s method, see <a href="#Krotov.optimize_pulses"><code>Krotov.optimize_pulses</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/36d38bb46a50df5dcf3fce86770b371200753be6/src/optimize.jl#L18-L25">source</a></section></article><p>All other types and methods in <code>QuantumControl</code> or its submodules are re-exported from lower level packages (<code>QuantumControlBase</code>, <code>QuantumPropagators</code>, etc.):</p><ul><li><a href="#QuantumControlBase.ControlProblem"><code>ControlProblem</code></a></li><li><a href="#QuantumControlBase.Objective"><code>Objective</code></a></li><li><a href="#QuantumControlBase.WeightedObjective"><code>WeightedObjective</code></a></li><li><a href="#QuantumControlBase.liouvillian"><code>liouvillian</code></a></li><li><a href="#QuantumPropagators.propagate"><code>propagate</code></a></li><li><a href="#QuantumPropagators.propstep!"><code>propstep!</code></a></li></ul><h3 id="QuantumControl.shapes"><a class="docs-heading-anchor" href="#QuantumControl.shapes"><code>QuantumControl.shapes</code></a><a id="QuantumControl.shapes-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControl.shapes" title="Permalink"></a></h3><ul><li><a href="#QuantumControlBase.flattop-Tuple{Any}"><code>QuantumControl.shapes.flattop</code></a></li><li><a href="#QuantumControlBase.box-Tuple{Any, Any, Any}"><code>QuantumControl.shapes.box</code></a></li><li><a href="#QuantumControlBase.blackman-Tuple{Any, Any, Any}"><code>QuantumControl.shapes.blackman</code></a></li></ul><h3 id="QuantumControl.functionals"><a class="docs-heading-anchor" href="#QuantumControl.functionals"><code>QuantumControl.functionals</code></a><a id="QuantumControl.functionals-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControl.functionals" title="Permalink"></a></h3><ul><li><a href="#QuantumControlBase.F_ss-Tuple{Any, Any}"><code>QuantumControl.functionals.F_ss</code></a></li><li><a href="#QuantumControlBase.J_T_ss-Tuple{Any, Any}"><code>QuantumControl.functionals.J_T_ss</code></a></li><li><a href="#QuantumControlBase.chi_ss!-Tuple{Any, Any, Any}"><code>QuantumControl.functionals.chi_ss!</code></a></li><li><a href="#QuantumControlBase.F_sm-Tuple{Any, Any}"><code>QuantumControl.functionals.F_sm</code></a></li><li><a href="#QuantumControlBase.J_T_sm-Tuple{Any, Any}"><code>QuantumControl.functionals.J_T_sm</code></a></li><li><a href="#QuantumControlBase.chi_sm!-Tuple{Any, Any, Any}"><code>QuantumControl.functionals.chi_sm!</code></a></li><li><a href="#QuantumControlBase.F_re-Tuple{Any, Any}"><code>QuantumControl.functionals.F_re</code></a></li><li><a href="#QuantumControlBase.J_T_re-Tuple{Any, Any}"><code>QuantumControl.functionals.J_T_re</code></a></li><li><a href="#QuantumControlBase.chi_re!-Tuple{Any, Any, Any}"><code>QuantumControl.functionals.chi_re!</code></a></li></ul><h2 id="Krotov"><a class="docs-heading-anchor" href="#Krotov">Krotov</a><a id="Krotov-1"></a><a class="docs-heading-anchor-permalink" href="#Krotov" title="Permalink"></a></h2><h3 id="Public"><a class="docs-heading-anchor" href="#Public">Public</a><a id="Public-1"></a><a class="docs-heading-anchor-permalink" href="#Public" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Krotov.SquareParametrization" href="#Krotov.SquareParametrization"><code>Krotov.SquareParametrization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parametrization ϵ(t) = u²(t), enforcing pulse values ≥ 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/1495b3030e64ab37a5830d2d6b0525a7341ab904/src/parametrization.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krotov.TanhParametrization" href="#Krotov.TanhParametrization"><code>Krotov.TanhParametrization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parametrization with a tanh function that enforces ϵ<em>min &lt; ϵ(t) &lt; ϵ</em>max.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/1495b3030e64ab37a5830d2d6b0525a7341ab904/src/parametrization.jl#L35-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krotov.TanhSqParametrization" href="#Krotov.TanhSqParametrization"><code>Krotov.TanhSqParametrization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parametrization with a tanh² function that enforces <span>$0 ≤ ϵ(t) &lt; ϵ_max$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/1495b3030e64ab37a5830d2d6b0525a7341ab904/src/parametrization.jl#L60-L62">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Krotov.LogisticParametrization, Krotov.LogisticSqParametrization</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Krotov.optimize_pulses" href="#Krotov.optimize_pulses"><code>Krotov.optimize_pulses</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Use Krotov&#39;s method to optimize the given optimization problem.</p><pre><code class="language-julia hljs">result = optimize_pulses(problem; kwargs...)</code></pre><p>optimizes the given control problem, see <a href="#QuantumControlBase.ControlProblem"><code>QuantumControlBase.ControlProblem</code></a>.</p><p>Keyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of <code>problem</code>. Any <code>kwargs</code> passed directly to <code>optimize_pulses</code> will update (overwrite) the parameters in <code>problem</code>.</p><p><strong>Required problem keyword arguments</strong></p><ul><li><code>J_T</code>: A function <code>J_T(ϕ, objectives)</code> that evaluates the final time functional from a list <code>ϕ</code> of forward-propagated states and <code>problem.objectives</code>.</li><li><code>chi</code>: A function <code>chi!(χ, ϕ, objectives)</code> what receives a list <code>ϕ</code> of the forward propagates state and must set <span>$χₖ=∂J_T/∂⟨ϕₖ|$</span>.</li></ul><p><strong>Optional problem keyword arguments</strong></p><p>The following keyword arguments are supported (with default values):</p><ul><li><code>sigma=nothing</code>: Function that calculate the second-order contribution. If  not given, the first-order Krotov method is used.</li><li><code>iter_start=0</code>: the initial iteration number</li><li><code>iter_stop=5000</code>: the maximum iteration number</li><li><code>prop_method=:auto</code>: The propagation method to use</li><li><code>update_hook</code>: A function that receives the Krotov workspace, the iteration  number, the list of updated pulses and the list of guess pulses as  positional arguments. The function may mutate any of its arguments. This may  be used e.g. to apply a spectral filter to the updated pulses, or to update  propagation workspaces inside the Krotov workspace.</li><li><code>info_hook</code>: A function that receives the same argumens as <code>update_hook</code>, in  order to write information about the current iteration to the screen or to a  file. The default <code>info_hook</code> prints a table with convergence information to  the screen. Runs after <code>update_hook</code>. The <code>info_hook</code> function may return a  tuple, which is stored in the list of <code>records</code> inside the  <a href="#Krotov.KrotovResult"><code>KrotovResult</code></a> object.</li><li><code>check_convergence</code>: a function to check whether convergence has been reached. Receives a <a href="#Krotov.KrotovResult"><code>KrotovResult</code></a> object <code>result</code>, and should set <code>result.converged</code> to <code>true</code> and <code>result.message</code> to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with <code>∘</code>. The convergence check is performed after any calls to <code>update_hook</code> and <code>info_hook</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/1495b3030e64ab37a5830d2d6b0525a7341ab904/src/optimize.jl#L215-L264">source</a></section></article><h3 id="Private"><a class="docs-heading-anchor" href="#Private">Private</a><a id="Private-1"></a><a class="docs-heading-anchor-permalink" href="#Private" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Krotov.KrotovResult" href="#Krotov.KrotovResult"><code>Krotov.KrotovResult</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Result object returned by <a href="#Krotov.optimize_pulses"><code>optimize_pulses</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/1495b3030e64ab37a5830d2d6b0525a7341ab904/src/optimize.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krotov.PulseParametrization" href="#Krotov.PulseParametrization"><code>Krotov.PulseParametrization</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Specification for a &quot;time-local&quot; pulse parametrization.</p><p>The parametrization is given as a collection of three functions:</p><ul><li><span>$ϵ(u(t))$</span></li><li><span>$u(ϵ(t))$</span></li><li><span>$∂ϵ/∂u$</span> as a function of <span>$u(t)$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/1495b3030e64ab37a5830d2d6b0525a7341ab904/src/parametrization.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krotov.NoParametrization-Tuple{}" href="#Krotov.NoParametrization-Tuple{}"><code>Krotov.NoParametrization</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parametrization where <span>$ϵ(t) ≡ u(t)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/1495b3030e64ab37a5830d2d6b0525a7341ab904/src/parametrization.jl#L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krotov.print_table-Tuple{Any, Any, Vararg{Any, N} where N}" href="#Krotov.print_table-Tuple{Any, Any, Vararg{Any, N} where N}"><code>Krotov.print_table</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default info_hook</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/1495b3030e64ab37a5830d2d6b0525a7341ab904/src/optimize.jl#L484">source</a></section></article><h2 id="QuantumControlBase"><a class="docs-heading-anchor" href="#QuantumControlBase">QuantumControlBase</a><a id="QuantumControlBase-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBase" title="Permalink"></a></h2><h3 id="Public-2"><a class="docs-heading-anchor" href="#Public-2">Public</a><a class="docs-heading-anchor-permalink" href="#Public-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.ControlProblem" href="#QuantumControlBase.ControlProblem"><code>QuantumControlBase.ControlProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A full control problem with multiple objectives.</p><pre><code class="language-julia hljs">ControlProblem(
   objectives=&lt;list of objectives&gt;,
   pulse_options=&lt;dict of controls to pulse options&gt;,
   tlist=&lt;time grid&gt;,
   kwargs...
)</code></pre><p>Note that the control problem can only be instantiated via keyword arguments.</p><p>The <code>objectives</code> are a list of <a href="#QuantumControlBase.AbstractControlObjective"><code>AbstractControlObjective</code></a> instances, each defining an initial state and a dynamical generator for the evolution of that state. Usually, the objective will also include a target state (see <a href="#QuantumControlBase.Objective"><code>Objective</code></a>) and possibly a weight (see <a href="#QuantumControlBase.WeightedObjective"><code>WeightedObjective</code></a>.</p><p>The <code>pulse_options</code> are a dictionary (<code>IdDict</code>) mapping controls that occur in the <code>objectives</code> to properties specific to the control method.</p><p>The <code>tlist</code> is the time grid on which the time evolution of the initial states of each objective should be propagated.</p><p>The remaining <code>kwargs</code> are keyword arguments that are passed directly to the optimal control method. These typically include e.g. the optimization functional.</p><p>The control problem is solved by finding a set of controls that simultaneously fulfill all objectives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/controlproblem.jl#L68-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Objective" href="#QuantumControlBase.Objective"><code>QuantumControlBase.Objective</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Standard optimization objective.</p><pre><code class="language-julia hljs">Objective(;
    initial_state=&lt;initial_state&gt;,
    generator=&lt;genenerator&gt;,
    target_state=&lt;target_state&gt;
)</code></pre><p>describes an optimization objective where the time evoluation of the given <code>initial_state</code> under the given <code>generator</code> aims towards <code>target_state</code>. The <code>generator</code> here is e.g. a time-dependent Hamiltonian or Liouvillian.</p><p>The most common control problems in quantum control, e.g. state-to-state transitions or quantum gate implementations can be expressed by simultaneously fulfilling multiple objectives of this type.</p><p>Note that the objective can only be instantiated via keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/controlproblem.jl#L11-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.WeightedObjective" href="#QuantumControlBase.WeightedObjective"><code>QuantumControlBase.WeightedObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Standard optimization objective with a weight.</p><pre><code class="language-julia hljs">WeightedObjective(;
    initial_state=&lt;initial_state&gt;,
    generator=&lt;genenerator&gt;,
    target_state=&lt;target_state&gt;,
    weight=&lt;weight&gt;
)</code></pre><p>initializes a control objective like <a href="#QuantumControlBase.Objective"><code>Objective</code></a>, but with an additional <code>weight</code> parameter (a float generally between 0 and 1) that weights the objective relative to other objectives that are part of the same control problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/controlproblem.jl#L41-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.F_re-Tuple{Any, Any}" href="#QuantumControlBase.F_re-Tuple{Any, Any}"><code>QuantumControlBase.F_re</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Real-part fidelity.</p><pre><code class="language-julia hljs">F_re(ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/functionals.jl#L123-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.F_sm-Tuple{Any, Any}" href="#QuantumControlBase.F_sm-Tuple{Any, Any}"><code>QuantumControlBase.F_sm</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Square-modulus fidelity.</p><pre><code class="language-julia hljs">F_sm(ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/functionals.jl#L72-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.F_ss-Tuple{Any, Any}" href="#QuantumControlBase.F_ss-Tuple{Any, Any}"><code>QuantumControlBase.F_ss</code></a> — <span class="docstring-category">Method</span></header><section><div><p>State-to-state phase-insensitive fidelity.</p><pre><code class="language-julia hljs">F_ss(ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/functionals.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.J_T_re-Tuple{Any, Any}" href="#QuantumControlBase.J_T_re-Tuple{Any, Any}"><code>QuantumControlBase.J_T_re</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Real-part functional.</p><pre><code class="language-julia hljs">J_T_re(ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/functionals.jl#L134-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.J_T_sm-Tuple{Any, Any}" href="#QuantumControlBase.J_T_sm-Tuple{Any, Any}"><code>QuantumControlBase.J_T_sm</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Square-modulus functional.</p><pre><code class="language-julia hljs">J_T_sm(ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/functionals.jl#L83-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.J_T_ss-Tuple{Any, Any}" href="#QuantumControlBase.J_T_ss-Tuple{Any, Any}"><code>QuantumControlBase.J_T_ss</code></a> — <span class="docstring-category">Method</span></header><section><div><p>State-to-state phase-insensitive functional.</p><pre><code class="language-julia hljs">J_T_ss(ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/functionals.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.blackman-Tuple{Any, Any, Any}" href="#QuantumControlBase.blackman-Tuple{Any, Any, Any}"><code>QuantumControlBase.blackman</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Blackman window shape.</p><pre><code class="language-julia hljs">blackman(t, t₀, T; a=0.16)</code></pre><p>calculates</p><p class="math-container">\[B(t; t_0, T) =
    \frac{1}{2}\left(
        1 - a - \cos\left(2π \frac{t - t_0}{T - t_0}\right)
        + a \cos\left(4π \frac{t - t_0}{T - t_0}\right)
    \right)\,,\]</p><p>for a scalar <code>t</code>, with <span>$a$</span> = 0.16.</p><p>See <a href="http://en.wikipedia.org/wiki/Window_function#Blackman_windows">http://en.wikipedia.org/wiki/Window_function#Blackman_windows</a></p><p>A Blackman shape looks nearly identical to a Gaussian with a 6-sigma interval between <code>t₀</code> and <code>T</code>.  Unlike the Gaussian, however, it will go exactly to zero at the edges. Thus, Blackman pulses are often preferable to Gaussians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/shapes.jl#L73-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.box-Tuple{Any, Any, Any}" href="#QuantumControlBase.box-Tuple{Any, Any, Any}"><code>QuantumControlBase.box</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Box shape (Theta-function).</p><pre><code class="language-julia hljs">box(t, t₀, T)</code></pre><p>evaluates the Heaviside (Theta-) function <span>$\Theta(t) = 1$</span> for <span>$t_0 \le t \le T$</span>; and <span>$\Theta(t) = 0$</span> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/shapes.jl#L61-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.chi_re!-Tuple{Any, Any, Any}" href="#QuantumControlBase.chi_re!-Tuple{Any, Any, Any}"><code>QuantumControlBase.chi_re!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Krotov-states χ for functional <a href="#QuantumControlBase.J_T_re-Tuple{Any, Any}"><code>J_T_re</code></a>.</p><pre><code class="language-julia hljs">chi_re!(χ, ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/functionals.jl#L145-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.chi_sm!-Tuple{Any, Any, Any}" href="#QuantumControlBase.chi_sm!-Tuple{Any, Any, Any}"><code>QuantumControlBase.chi_sm!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Krotov-states χ for functional <a href="#QuantumControlBase.J_T_sm-Tuple{Any, Any}"><code>J_T_sm</code></a>.</p><pre><code class="language-julia hljs">chi_sm!(χ, ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/functionals.jl#L94-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.chi_ss!-Tuple{Any, Any, Any}" href="#QuantumControlBase.chi_ss!-Tuple{Any, Any, Any}"><code>QuantumControlBase.chi_ss!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Krotov-states χ for functional <a href="#QuantumControlBase.J_T_ss-Tuple{Any, Any}"><code>J_T_ss</code></a>.</p><pre><code class="language-julia hljs">chi_ss!(χ, ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/functionals.jl#L51-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.discretize-Tuple{Function, Any}" href="#QuantumControlBase.discretize-Tuple{Function, Any}"><code>QuantumControlBase.discretize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate <code>control</code> at every point of <code>tlist</code>.</p><pre><code class="language-julia hljs">values = discretize(control, tlist; via_midpoints=true)</code></pre><p>discretizes the given <code>control</code> to a Vector of values defined on the points of <code>tlist</code>.</p><p>If <code>control</code> is a function, it will will first be evaluated at the midpoint of <code>tlist</code>, see <a href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a>, and then the values on the midpoints are converted to values on <code>tlist</code>. This discretization is more stable than directly evaluationg the control function at the values of <code>tlist</code>, and ensures that repeated round-trips between <a href="#QuantumControlBase.discretize-Tuple{Function, Any}"><code>discretize</code></a> and <a href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a> can be done safely, see the note in the documentation of <a href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a>.</p><p>The latter can still be achieved by passing <code>via_midpoints=false</code>. While such a direct discretization is suitable e.g. for plotting, but it is unsuitable for round-trips between <a href="#QuantumControlBase.discretize-Tuple{Function, Any}"><code>discretize</code></a> and <a href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a>  (constant controls on <code>tlist</code> may result in a zig-zag on the intervals of <code>tlist</code>).</p><p>If <code>control</code> is a vector, it will be returned un-modified if it is of the same length as <code>tlist</code>. Otherwise, <code>control</code> must have one less value than <code>tlist</code>, and is assumed to be defined on the midpoins of <code>tlist</code>. In that case, <a href="#QuantumControlBase.discretize-Tuple{Function, Any}"><code>discretize</code></a> acts as the inverse of <a href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a>. See <a href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a> for how control values on <code>tlist</code> and control values on the intervals of <code>tlist</code> are related.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/controls.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function" href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>QuantumControlBase.discretize_on_midpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate <code>control</code> at the midpoints of <code>tlist</code>.</p><pre><code class="nohighlight hljs">values = discretize_on_midpoints(control, tlist)</code></pre><p>discretizes the given <code>control</code> to a Vector of values on the midpoints of <code>tlist</code>. Hence, the resulting <code>values</code> will contain one less value than <code>tlist</code>.</p><p>If <code>control</code> is a vector of values defined on <code>tlist</code> (i.e., of the same length as <code>tlist</code>), it will be converted to a vector of values on the intervals of <code>tlist</code>. The value for the first and last &quot;midpoint&quot; will remain the original values at the beginning and end of <code>tlist</code>, in order to ensure exact bounary conditions. For all other midpoints, the value for that midpoint will be calculated by &quot;un-averaging&quot;.</p><p>For example, for a <code>control</code> and <code>tlist</code> of length 5, consider the following diagram:</p><pre><code class="nohighlight hljs">tlist index:       1   2   3   4   5
tlist:             ⋅   ⋅   ⋅   ⋅   ⋅   input values cᵢ (i ∈ 1..5)
                   |̂/ ̄ ̄ ̂\ / ̂\ / ̂ ̄ ̄\|̂
midpoints:         x     x   x     x   output values pᵢ (i ∈ 1..4)
midpoints index:   1     2   3     4</code></pre><p>We will have <span>$p₁=c₁$</span> for the first value, <span>$p₄=c₅$</span> for the last value. For all other points, the control values <span>$cᵢ = \frac{p_{i-1} + p_{i}}{2}$</span> are the average of the values on the midpoints. This implies the &quot;un-averaging&quot; for the midpoint values <span>$pᵢ = 2 c_{i} - p_{i-1}$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>An arbitrary input <code>control</code> array may not be compatible with the above averaging formula. In this case, the conversion will be &quot;lossy&quot; (<a href="#QuantumControlBase.discretize-Tuple{Function, Any}"><code>discretize</code></a> will not recover the original <code>control</code> array; the difference should be considered a &quot;discretization error&quot;). However, any <em>further</em> round-trip conversions between points and intervals are bijective and preserve the boundary conditions. In this case, the <a href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a> and <a href="#QuantumControlBase.discretize-Tuple{Function, Any}"><code>discretize</code></a> methods are each other&#39;s inverse. This also implies that for an optimal control procedure, it is safe to modify <em>midpoint</em> values. Modifying the the values on the time grid directly on the other hand may accumulate discretization errors.</p></div></div><p>If <code>control</code> is a vector of one less length than <code>tlist</code>, it will be returned unchanged, under the assumption that the input is already properly discretized.</p><p>If <code>control</code> is a function, the function will be directly evaluated at the midpoints marked as <code>x</code> in the above diagram..</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/controls.jl#L61-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.flattop-Tuple{Any}" href="#QuantumControlBase.flattop-Tuple{Any}"><code>QuantumControlBase.flattop</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Flat shape (one) with a switch-on/switch-off from zero.</p><pre><code class="language-julia hljs">flattop(t; t₀, T, t_rise, t_fall=t_rise, func=:blackman)</code></pre><p>evaluates a shape function that starts at 0 at <span>$t=t₀$</span>, and ramps to to 1 during the <code>t_rise</code> interval. The function then remains at value 1, before ramping down to 0 again during the interval <code>t_fall</code> before <code>T</code>. For <span>$t &lt; t₀$</span> and <span>$t &gt; T$</span>, the shape is zero.</p><p>The default switch-on/-off shape is half of a Blackman window (see <a href="#QuantumControlBase.blackman-Tuple{Any, Any, Any}"><code>blackman</code></a>).</p><p>For <code>func=:sinsq</code>, the switch-on/-off shape is a sine-squared curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/shapes.jl#L4-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.getcontrols-Tuple{Tuple}" href="#QuantumControlBase.getcontrols-Tuple{Tuple}"><code>QuantumControlBase.getcontrols</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Extract a Tuple of controls.</p><pre><code class="language-julia hljs">controls = getcontrols(generator)</code></pre><p>extracts the controls from a single dynamical generator.</p><pre><code class="language-julia hljs">controls = getcontrols(objectives)</code></pre><p>extracts the controls from a list of objectives (i.e., from each objective&#39;s <code>generator</code>)</p><p>In either case, controls that occur multiple times, either in a single generator, or throughout the different objectives, will occur only once in the result.</p><p>By default, assumes that any <code>generator</code> is a nested Tuple, e.g. <code>(H0, (H1, ϵ1), (H2, ϵ2), ...)</code> and extracts (ϵ1, ϵ2)</p><p>Each control must be a valid argument for <code>discretize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/controls.jl#L145-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.liouvillian" href="#QuantumControlBase.liouvillian"><code>QuantumControlBase.liouvillian</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a Liouvillian super-operator.</p><pre><code class="language-julia hljs">ℒ = liouvillian(Ĥ, c_ops=(); convention=:LvN)</code></pre><p>calculates the sparse Liouvillian super-operator <code>ℒ</code> from the Hamiltonian <code>Ĥ</code> and a list <code>c_ops</code> of Lindblad operators.</p><p>With <code>convention=:LvN</code>, applying the resulting <code>ℒ</code> to a vectorized density matrix <code>ρ⃗</code> calculates <span>$\frac{d}{dt} \vec{\rho}(t) = ℒ \vec{\rho}(t)$</span> equivalent to the Liouville-von-Neumann equation for the density matrix <span>$ρ̂$</span>,</p><p class="math-container">\[\frac{d}{dt} ρ̂(t)
= -i [Ĥ, ρ̂(t)] + \sum_k\left(
    Â_k ρ̂ Â_k^\dagger
    - \frac{1}{2} A_k^\dagger Â_k ρ̂
    - \frac{1}{2} ρ̂ Â_k^\dagger Â_k
  \right)\,,\]</p><p>where the Lindblad operators <span>$Â_k$</span> are the elements of <code>c_ops</code>.</p><p>The Hamiltonian <span>$Ĥ$</span> may be time-dependent, using a nested-tuple format by default, e.g., <code>(Ĥ₀, (H₁, ϵ₁), (H₂, ϵ₂))</code>, where <code>ϵ₁</code> and <code>ϵ₂</code> are functions of time. In this case, the resulting <code>ℒ</code> will also be in nested tuple format, <code>ℒ = (ℒ₀, (ℒ₁, ϵ₁), (ℒ₂, ϵ₂))</code>, where the initial element contains the superoperator <code>ℒ₀</code> for the static component of the Liouvillian, i.e., the commutator with the drift Hamiltonian <code>Ĥ₀</code>, plus the dissipator (sum over <span>$k$</span>), as a sparse matrix. Time-dependent Lindblad operators are not supported. The remaining elements are tuples <code>(ℒ₁, ϵ₁)</code> and <code>(ℒ₂, ϵ₂)</code> corresponding to the commutators with the two control Hamiltonians, where <code>ℒ₁</code> and <code>ℒ₂</code> again are sparse matrices.</p><p>If <span>$Ĥ$</span> is not time-dependent, the resulting <code>ℒ</code> will be a single-element tuple containing the Liouvillian as a sparse matrix, <code>ℒ = (ℒ₀, )</code>.</p><p>With <code>convention=:TDSE</code>, the Liouvillian will be constructed for the equation of motion <span>$-i \hbar \frac{d}{dt} \vec{\rho}(t) = ℒ \vec{\rho}(t)$</span> to match exactly the form of the time-dependent Schrödinger equation. While this notation is not standard in the literature of open quantum systems, it has the benefit that the resulting <code>ℒ</code> can be used in a numerical propagator for a (non-Hermitian) Schrödinger equation without any change. Thus, for numerical applications, <code>convention=:TDSE</code> is generally preferred. The returned <code>ℒ</code> between the two conventions differs only by a factor of <span>$i$</span>, since we generally assume <span>$\hbar=1$</span>.</p><p>The <code>convention</code> keyword argument is mandatory, to force a conscious choice.</p><p>See <a href="https://arxiv.org/abs/1312.0111v2">Goerz et. al. &quot;Optimal control theory for a unitary operation under dissipative evolution&quot;, arXiv 1312.0111v2, Appendix B.2</a> for the explicit construction of the Liouvillian superoperator as a sparse matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/liouvillian.jl#L61-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.obj_genfunc-Tuple{QuantumControlBase.AbstractControlObjective, Any}" href="#QuantumControlBase.obj_genfunc-Tuple{QuantumControlBase.AbstractControlObjective, Any}"><code>QuantumControlBase.obj_genfunc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a <code>genfunc</code> suitable for <a href="@ref"><code>propagate</code></a> from an objective.</p><pre><code class="language-julia hljs">genfunc = obj_genfunc(obj, tlist; controls_map=IdDict())</code></pre><p>can be passed to <a href="@ref"><code>propagate</code></a> to propagate under the dynamical generator in <code>obj</code>. If given, <code>controls_map</code> defines replacements for the control</p><p>If given, <code>control_map</code> defines replacements for the controls in <code>obj.generator</code>. This allows, e.g., to replace the controls with those resulting from an optimization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/propagate.jl#L5-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.setcontrolvals!-Union{Tuple{D}, Tuple{Any, Tuple, D}} where D&lt;:AbstractDict" href="#QuantumControlBase.setcontrolvals!-Union{Tuple{D}, Tuple{Any, Tuple, D}} where D&lt;:AbstractDict"><code>QuantumControlBase.setcontrolvals!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>In-place version of <a href="#QuantumControlBase.setcontrolvals-Union{Tuple{D}, Tuple{Tuple, D}} where D&lt;:AbstractDict"><code>setcontrolvals</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/controls.jl#L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.setcontrolvals-Union{Tuple{D}, Tuple{Tuple, D}} where D&lt;:AbstractDict" href="#QuantumControlBase.setcontrolvals-Union{Tuple{D}, Tuple{Tuple, D}} where D&lt;:AbstractDict"><code>QuantumControlBase.setcontrolvals</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct <code>G</code> by plugging values into a general generator.</p><pre><code class="language-julia hljs">G = setcontrolvals(generator, vals_dict)
setcontrolvals!(G, generator, vals_dict)</code></pre><p>evaluates the <em>specific</em> dynamical generator <code>G</code> by plugging in values into the general <code>generator</code> according to <code>vals_dict</code>.</p><p>The <code>vals_dict</code> is a dictionary (<code>IdDict</code>) mapping controls as returned by <code>getcontrols(generator)</code> to values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/controls.jl#L207-L220">source</a></section></article><h3 id="Private-2"><a class="docs-heading-anchor" href="#Private-2">Private</a><a class="docs-heading-anchor-permalink" href="#Private-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.AbstractControlObjective" href="#QuantumControlBase.AbstractControlObjective"><code>QuantumControlBase.AbstractControlObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Base class for a single optimization objective.</p><p>All objectives must have a field <code>initial_state</code> and a field <code>generator</code>, at minimum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/controlproblem.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.adjoint" href="#Base.adjoint"><code>Base.adjoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adjoint(objective)</code></pre><p>Adjoint of a control objective. The adjoint objective contains the adjoint of the dynamical generator <code>obj.generator</code>, and adjoints of the <code>obj.initial_state</code> / <code>obj.target_state</code> if these exist and have an adjoint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/controlproblem.jl#L131-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.f_tau" href="#QuantumControlBase.f_tau"><code>QuantumControlBase.f_tau</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Average complex overlap of the target states with forward-propagated states.</p><pre><code class="language-julia hljs">f_tau(ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/functionals.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.initobjpropwrk" href="#QuantumControlBase.initobjpropwrk"><code>QuantumControlBase.initobjpropwrk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wrk = initobjpropwrk(obj, tlist, method; kwargs...)</code></pre><p>initializes a workspace for the propagation of an<a href="#QuantumControlBase.AbstractControlObjective"><code>AbstractControlObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/propagate.jl#L102-L109">source</a></section></article><h2 id="QuantumPropagators"><a class="docs-heading-anchor" href="#QuantumPropagators">QuantumPropagators</a><a id="QuantumPropagators-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumPropagators" title="Permalink"></a></h2><h3 id="Public-3"><a class="docs-heading-anchor" href="#Public-3">Public</a><a class="docs-heading-anchor-permalink" href="#Public-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.specrange" href="#QuantumPropagators.specrange"><code>QuantumPropagators.specrange</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculate the spectral range of a Hamiltonian <code>H</code> on the real axis.</p><pre><code class="language-julia hljs">E_min, E_max = specrange(H; method=:auto, kwargs...)</code></pre><p>calculates the approximate lowest and highest eigenvalues of <code>H</code>. Any imaginary part in the eigenvalues is ignored: the routine is intended for (although not strictly limited to) a Hermitian <code>H</code>.</p><p>This delegates to</p><pre><code class="language-julia hljs">specrange(H, method; kwargs...)</code></pre><p>for the different methods.</p><p>The default <code>method=:auto</code> chooses the best method for the given <code>H</code>. This is <code>:diag</code> for small matrices, and <code>:arnoldi</code> otherwise. Keyword arguments not relevant to the underlying implementation will be ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/specrad.jl#L1-L23">source</a></section><section><div><pre><code class="language-julia hljs">E_min, E_max = specrange(H, :arnoldi; state=random_state(H), m_min=20,
                         m_max=60, prec=1e-3, nom_min=1e-15, enlarge=true)</code></pre><p>uses <a href="https://en.wikipedia.org/wiki/Arnoldi_iteration">Arnoldi iteration</a> with <code>state</code> as the starting vector. It approximates the eigenvalues of <code>H</code> with between <code>m_min</code> and <code>m_max</code> Ritz values, until the lowest and highest eigenvalue are stable to a releative precision of <code>prec</code>. The <code>norm_min</code> parameter is passed to the underlying <a href="#QuantumPropagators.arnoldi!-Union{Tuple{T}, Tuple{Matrix{ComplexF64}, Array{T, N} where N, Int64, T, Any}, Tuple{Matrix{ComplexF64}, Array{T, N} where N, Int64, T, Any, Float64}} where T"><code>arnoldi!</code></a>.</p><p>If <code>enlarge=true</code> (default) the returned <code>E_min</code> and <code>E_max</code> will be enlarged via a heuristic to slightly over-estimate the spectral radius instead of under-estimating it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/specrad.jl#L42-L57">source</a></section><section><div><pre><code class="language-julia hljs">E_min, E_max = specrange(H, :diag)</code></pre><p>uses exact diagonization via the standard <code>eigenvals</code> function to obtain the smallest and largest eigenvalue. This should only be used for relatively small matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/specrad.jl#L80-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.cheby_coeffs" href="#QuantumPropagators.cheby_coeffs"><code>QuantumPropagators.cheby_coeffs</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculate Chebychev coefficients.</p><p>Return an array of coefficiencts larger than <code>limit</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Δ</code>: the spectral radius of the underlying operator</li><li><code>dt</code>: the time step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/cheby.jl#L7-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.cheby_coeffs!" href="#QuantumPropagators.cheby_coeffs!"><code>QuantumPropagators.cheby_coeffs!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculate Chebychev coefficients in-place.</p><pre><code class="language-julia hljs">n = cheby_coeffs!(coeffs, Δ, dt, limit=1e-12)</code></pre><p>overwrites the first <code>n</code> values in <code>coeffs</code> with new coefficients larger than <code>limit</code> for the given new spectral radius <code>Δ</code> and time step <code>dt</code>. The <code>coeffs</code> array will be resized if necessary, and may length &gt; <code>n</code> on exit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/cheby.jl#L33-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.ChebyWrk" href="#QuantumPropagators.ChebyWrk"><code>QuantumPropagators.ChebyWrk</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Workspace for the Chebychev propagation routine.</p><pre><code class="language-julia hljs">    ChebyWrk(Ψ, Δ, E_min, dt; limit=1e-12)</code></pre><p>initializes the workspace for the propagation of a state similar to Ψ under a Hamiltonian with eigenvalues between <code>E_min</code> and <code>E_min + Δ</code>, and a time step dt. Chebychev coefficients smaller than the given <code>limit</code> are discarded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/cheby.jl#L64-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.cheby!" href="#QuantumPropagators.cheby!"><code>QuantumPropagators.cheby!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Evaluate <code>Ψ = exp(-i H dt) Ψ</code> in-place.</p><pre><code class="language-julia hljs">cheby!(Ψ, H, dt, wrk; E_min=nothing, check_normalization=false)</code></pre><p>Args:</p><ul><li><code>Ψ</code>: on input, initial vector. Will be overwritten with result.</li><li><code>H</code>: Hermitian operator</li><li><code>dt</code>: time step</li><li><code>wrk</code>: internal workspace</li><li><code>E_min</code>: minimum eigenvalue of H, to be used instead of the <code>E_min</code> from the  initialization of <code>wrk</code>. The same <code>wrk</code> may be used for different values  <code>E_min</code>, as long as the spectra radius <code>Δ</code> and the time step <code>dt</code> are the  same as those used for the initialization of <code>wrk</code>.</li><li><code>check_normalizataion</code>: perform checks that the H does not exceed the spectral radius for which the the workspace was initialized.</li></ul><p>The routine will not allocate any internal storage. This implementation requires <code>copyto!</code> <code>lmul!</code>, and <code>axpy!</code> to be implemented for <code>Ψ</code>, and the three-argument <code>mul!</code> for <code>Ψ</code> and <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/cheby.jl#L99-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.NewtonWrk" href="#QuantumPropagators.NewtonWrk"><code>QuantumPropagators.NewtonWrk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">    NewtonWrk(v0, m_max=10)</code></pre><p>Workspace for the Newton-with-restarted-Arnoldi propagation routine.</p><p>Initializes the workspace for the propagation of a vector <code>v0</code>, using a maximum Krylov dimension of <code>m_max</code> in each restart iteration. Note that <code>m_max</code> should be smaller than the length of <code>v0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/newton.jl#L7-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.newton!" href="#QuantumPropagators.newton!"><code>QuantumPropagators.newton!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newton!(Ψ, H, dt, wrk; func=(z -&gt; exp(-1im*z)), norm_min=1e-14, relerr=1e-12,
        max_restarts=50)</code></pre><p>Evaluate <code>Ψ = func(H*dt) Ψ</code> using a Newton-with-restarted-Arnoldi scheme.</p><p><strong>Arguments</strong></p><ul><li><code>Ψ</code>: The state to propagate, will be overwritten in-place with the propagated state</li><li><code>H</code>: Operator acting on <code>Ψ</code>. Together with <code>dt</code>, this is the argument to <code>func</code></li><li><code>dt</code>: Implicit time step. Together with <code>H</code>, this is the argument to <code>func</code></li><li><code>wkr</code>: Work array, initialized with <a href="#QuantumPropagators.NewtonWrk"><code>NewtonWrk</code></a></li><li><code>func</code>: The function to apply to <code>H dt</code>, taking a single (scalar) complex-valued argument <code>z</code> in place of <code>H dt</code>. The default <code>func</code> is to evaluate the time evoluation operator for the Schrödinger equation</li><li><code>norm_min</code>: the minium norm at which to consider a state similar to <code>Ψ</code> as zero</li><li><code>relerr</code>: The relative error defining the convergence condition for the restart iteration. Propagation stops when the norm of the accumulated <code>Ψ</code> is stable up to the given relative error</li><li><code>max_restart</code>: The maximum number of restart iterations. Exceeding <code>max_restart</code> will throw an <code>AssertionError</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/newton.jl#L192-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.ExpPropWrk" href="#QuantumPropagators.ExpPropWrk"><code>QuantumPropagators.ExpPropWrk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">    ExpPropWrk(v0)</code></pre><p>Workspace for propagation via direct matrix exponentiation.</p><p>Initializes the workspace for the propagation of a vector <code>v0</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/expprop.jl#L7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.expprop!" href="#QuantumPropagators.expprop!"><code>QuantumPropagators.expprop!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expprop!(Ψ, H, dt, wrk; func=(H_dt -&gt; exp(-1im * H_dt)))</code></pre><p>Evaluate <code>Ψ = func(H*dt) Ψ</code> by directly evaluating <code>U = func(H*dt)</code>, i.e. by matrix exponentiation for the default <code>func</code>, and then multiplying <code>U</code> and <code>Ψ</code> in-place with <code>mul!</code>.</p><p>The workspace <code>wrk</code> must be initialized with <a href="#QuantumPropagators.ExpPropWrk"><code>ExpPropWrk</code></a> to provide storage for a temporary state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/expprop.jl#L24-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.init_storage" href="#QuantumPropagators.init_storage"><code>QuantumPropagators.init_storage</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Create a <code>storage</code> array for <a href="#QuantumPropagators.propagate"><code>propagate</code></a>.</p><pre><code class="language-julia hljs">storage = init_storage(state, tlist)</code></pre><p>creates a storage array suitable for storing a <code>state</code> for each point in <code>tlist</code>.</p><pre><code class="language-julia hljs">storage = init_storage(state, tlist, observables))</code></pre><p>creates a storage array suitable for the data generated by the <code>observables</code> applied to <code>state</code>, see <a href="#QuantumPropagators.map_observables"><code>map_observables</code></a>, for each point in <code>tlist</code>.</p><pre><code class="language-julia hljs">storage = init_storage(data, nt))</code></pre><p>creates a storage arrays suitable for storing <code>data</code> nt times, where <code>nt=length(tlist)</code>. By default, this will be a vector of <code>typeof(data)</code> and length <code>nt</code>, or a <code>n × nt</code> Matrix with the same <code>eltype</code> as <code>data</code> if <code>data</code> is a Vector of length <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/storage.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.map_observables" href="#QuantumPropagators.map_observables"><code>QuantumPropagators.map_observables</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Obtain &quot;observable&quot; data from <code>state</code>.</p><pre><code class="language-julia hljs">data = map_observables(observables, state)</code></pre><p>calculates the data for a tuple of <code>observables</code> applied to <code>state</code>. For a single observable (tuple of length 1), simply return the result of <a href="#QuantumPropagators.map_observable"><code>map_observable</code></a>.</p><p>For multiple observables, return the tuple resulting from applying <a href="#QuantumPropagators.map_observable"><code>map_observable</code></a> for each observable. If the tuple is &quot;uniform&quot; (all elements are of the same type, e.g. if each observable calculates the expectation value of a Hermitian operator), it is converted to a Vector. This allows for compact storage in a storage array, see <a href="#QuantumPropagators.init_storage"><code>init_storage</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/storage.jl#L42-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.map_observable" href="#QuantumPropagators.map_observable"><code>QuantumPropagators.map_observable</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Apply a single <code>observable</code> to <code>state</code>.</p><pre><code class="language-julia hljs">data = map_observable(observable, state)</code></pre><p>By default, <code>observable</code> is assumed to be callable, and the above is equivalent to <code>data = observable(state)</code>.</p><p>If <code>observable</code> is a matrix and <code>state</code> is a vector evaluate the expectation value of the observable as <code>dot(state, observable, state)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/storage.jl#L74-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.write_to_storage!" href="#QuantumPropagators.write_to_storage!"><code>QuantumPropagators.write_to_storage!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Place data into <code>storage</code> for time slot <code>i</code>.</p><pre><code class="language-julia hljs">    write_to_storage!(storage, i, state, observables)</code></pre><p>For a <code>storage</code> array created by <a href="#QuantumPropagators.init_storage"><code>init_storage</code></a>, store the data obtains from <a href="#QuantumPropagators.map_observables"><code>map_observables</code></a> into the <code>storage</code> for time slot <code>i</code>. This delegates to the more general</p><pre><code class="language-julia hljs">    write_to_storage!(storage, i, data)</code></pre><p>Conceptually, this corresponds roughly to <code>storage[i] = data</code>, but <code>storage</code> may have its own idea on how to store data for a specific time slot. For example, with the default <a href="#QuantumPropagators.init_storage"><code>init_storage</code></a> Vector data will be stored in a matrix, and <code>write_to_storage!</code> will in this case write data to the i&#39;th column of the matrix.</p><p>For a given type of <code>storage</code> and <code>data</code>, it is the developer&#39;s responsibility that <code>init_storage</code> and <code>write_to_storage!</code> are compatible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/storage.jl#L96-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.get_from_storage!" href="#QuantumPropagators.get_from_storage!"><code>QuantumPropagators.get_from_storage!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Obtain data from storage</p><pre><code class="language-julia hljs">get_from_storage!(state, storage, i)</code></pre><p>extracts data from the <code>storage</code> for the i&#39;th time slot. Invese of <a href="#QuantumPropagators.write_to_storage!"><code>write_to_storage!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/storage.jl#L133-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.initpropwrk" href="#QuantumPropagators.initpropwrk"><code>QuantumPropagators.initpropwrk</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Initialize a workspace for propagation.</p><pre><code class="language-julia hljs">wrk = initpropwrk(state, tlist, method=:auto, generator...; kwargs...)</code></pre><p>The resulting <code>wrk</code> can be passed to <a href="#QuantumPropagators.propagate"><code>propagate</code></a> or <a href="#QuantumPropagators.propstep!"><code>propstep!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: An exemplary state for the propagation (e.g., the initial state)</li><li><code>tlist</code>: The time grid over which <a href="#QuantumPropagators.propagate"><code>propagate</code></a> will be called. Must include at least to points in order to determine the propagation time step to prepare. If the propagation will be over a <code>tlist</code> with a variable <code>dt</code>, the full <code>tlist</code> must be passed here.</li><li><code>generator</code>: An exemplary (non-time-dependent) dynamical generator. For full generality (if <code>method=:cheby</code>), the given <code>generator</code> should have a spectral range sufficiently large to encompass the entire propagation. If given multiple times, a spectral envelope enclosing all the generators will be determined automatically. In this case, you should pass the generators with the extremal values of all the controls.</li><li><code>method</code>: The propagation method to use. The default value of <code>:auto</code> attempts to choose the best method available, based on the properties of the given <code>state</code>, <code>tlist</code>, and <code>generator</code>. Alternative values are <code>:cheby</code> and <code>:newton</code>, and <code>:expprop</code>.</li><li><code>specrad_method</code>: for <code>method=:cheby</code>, method to use for estimating the  spectral radius, see <a href="#QuantumPropagators.specrange"><code>specrange</code></a>. Defaults to <code>:auto</code>.</li><li><code>tolerance</code>: for <code>method=:cheby</code>, a tolerance factor for the estimated spectral radius. That is, Chebychev coefficients will be calculated for a spectral radius increased by the <code>tolerance</code> factor compared to the specral radius estimated for the <code>generator</code>.</li></ul><p>All other <code>kwargs</code> are filtered and passed to the contructor for returned workspace, e.g. <code>limit</code> for <code>method=:cheby</code> or <code>m_max</code> for <code>method=:newton</code>. For <code>method=:cheby</code>, they additionally passed to <a href="#QuantumPropagators.specrange"><code>specrange</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/propagate.jl#L4-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.propstep!" href="#QuantumPropagators.propstep!"><code>QuantumPropagators.propstep!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Perform a single propagation step in-place.</p><pre><code class="language-julia hljs">propstep!(state, generator, dt, wrk;, kwargs...)</code></pre><p>The propagation method is determined by <code>wrk</code>, see <a href="#QuantumPropagators.initpropwrk"><code>initpropwrk</code></a>. The <code>kwargs</code> are forwarded to the underlying method</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/propagate.jl#L142-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.propagate" href="#QuantumPropagators.propagate"><code>QuantumPropagators.propagate</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Propagate a state over an entire time grid.</p><pre><code class="language-julia hljs">state_out = propagate(
    state, genfunc, tlist; method=:auto,
    backwards=false; storage=nothing, observables=(&lt;store state&gt;, ),
    hook=nothing, showprogress=false, kwargs...)</code></pre><p>propagates <code>state</code> over the time grid in <code>tlist</code>, using piecewise-constant dynamical generators (Hamiltonians or Liouvillians) determined by <code>genfunc</code>, and returns the resulting propagated state. The propagation is performed by calling <a href="#QuantumPropagators.propstep!"><code>propstep!</code></a> for every interval in <code>tlist</code>.</p><p>For the i&#39;th time interval, <code>genfunc(tlist, i)</code> must return the generator for that time interval. Generally, when approximating a time-continuous dynamical generator as piecewise-constant on the time grid, it should be evaluated at the <em>midpoint</em> of the interval. A possible exception is the first and last interval, which may be better evaluated at <code>tlist[1]</code> and <code>tlist[end]</code> to ensure exact boundary conditions like control fields that are exactly zero.</p><p>In addition to the two positional parameters indicating the time interval, <code>genfunc</code> will also receive the <code>state</code> (the input state for the propagation step), <code>backwards</code>, <code>storage</code>, <code>observables</code>, and <code>init</code> as keyword arguments. These additional parameters may be used for unusual equations of motion beyond the standard Schrödinger or Liouville-von-Neumann equation, e.g. <code>state</code> would enter the <code>genfunc</code> for a Gross–Pitaevskii equation. For standard equations of motion that do not use the additional parameters, it is best to capture the keyword arguments to <code>genfunc</code> with a definition like</p><pre><code class="language-julia hljs">genfunc(tlist, i; kwargs...) = ...</code></pre><p>For valid propagation <code>method</code>s, see <a href="#QuantumPropagators.initpropwrk"><code>initpropwrk</code></a>.</p><p>In general, there is no requirement that <code>tlist</code> has a constant time step, although some propagation methods (most notably <a href="#QuantumPropagators.cheby!"><code>cheby!</code></a>) only support a uniform time grid.</p><p>If <code>storage</code> is given as an Array, it will be filled with data determined by the <code>observables</code>. The default &quot;observable&quot; results in the propagated states at every point in time being stored. The <code>storage</code> array should be created with <a href="#QuantumPropagators.init_storage"><code>init_storage</code></a>. See its documentation for details.</p><p>The <code>storage</code> parameter may also be given as <code>true</code>, and a new storage array will be created internally with <a href="#QuantumPropagators.init_storage"><code>init_storage</code></a> and returned instead of the propagated state:</p><pre><code class="language-julia hljs">data = propagate(
    state, genfunc, tlist; method=:auto
    backwards=false; storage=true, observables=observables,
    hook=nothing, showprogress=false, kwargs...)</code></pre><p>If <code>backwards</code> is <code>true</code>, the input state is assumed to be at time <code>tlist[end]</code>, and the propagation progresses backwards in time (with a negative time step <code>dt</code>). If <code>storage</code> is given, it will be filled back-to-front during the backwards propagation.</p><p>If <code>hook</code> is given as a callable, it will be called after each propagation step, as <code>hook(state, generator, tlist, i, wrk, observables)</code> where <code>i</code> is the index of the time interval on <code>tlist</code> covered by the propagation step (0 for the initial state, respectives <code>lastindex(tlist)</code> for the backward propagation).  The <code>hook</code> is called before calculating any observables. Example usage includes writing data to file, or modyfing <code>state</code>, e.g. removing amplitude from the lowest and highest level to mitigate &quot;truncation error&quot;.</p><p>If <code>showprogress</code> is given as <code>true</code>, a progress bar will be shown for long-running propagationn. In order to customize the progress bar, <code>showprogress</code> may also be a function that receives <code>length(tlist)</code> and returns a <code>ProgressMeter.Progress</code> instance.</p><p>The <code>propagate</code> routine returns the propagated state at <code>tlist[end]</code>, respectively <code>tlist[1]</code> if <code>backwards=true</code>, or a storage array with the stored states / observable data if <code>storage=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/propagate.jl#L178-L257">source</a></section><section><div><p>Propagate with the dynamical generator of a control objective.</p><pre><code class="language-julia hljs">propagate(obj, tlist; method=:auto, initial_state=obj.initial_state,
          controls_map=IdDict(), kwargs...)</code></pre><p>propagates <code>initial_state</code> under the dynamics described by <code>obj.generator</code>.</p><p>The optional dict <code>control_map</code> may be given to replace the controls in <code>obj.generator</code> (as obtained by <a href="#QuantumControlBase.getcontrols-Tuple{Tuple}"><code>getcontrols</code></a>) with custom functions or vectors, e.g. with the controls resulting from optimization.</p><p>All other <code>kwargs</code> are forwarded to the underlying <code>propagate</code> method for <code>obj.initial_state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/d3b1bd45a06b177e892394ba7cc685190f306ac4/src/propagate.jl#L42-L58">source</a></section></article><h3 id="Private-3"><a class="docs-heading-anchor" href="#Private-3">Private</a><a class="docs-heading-anchor-permalink" href="#Private-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.arnoldi!-Union{Tuple{T}, Tuple{Matrix{ComplexF64}, Array{T, N} where N, Int64, T, Any}, Tuple{Matrix{ComplexF64}, Array{T, N} where N, Int64, T, Any, Float64}} where T" href="#QuantumPropagators.arnoldi!-Union{Tuple{T}, Tuple{Matrix{ComplexF64}, Array{T, N} where N, Int64, T, Any}, Tuple{Matrix{ComplexF64}, Array{T, N} where N, Int64, T, Any, Float64}} where T"><code>QuantumPropagators.arnoldi!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">m = arnoldi!(Hess, q, m, Ψ, H, dt=1.0; extended=true, norm_min=1e-15)</code></pre><p>Calculate the Hessenberg matrix and Arnoldi vectors of <code>H dt</code>, from <code>Ψ</code>.</p><p>For a given order <code>m</code>, the <code>m×m</code> Hessemberg matrix is calculated and stored in in the pre-allocated <code>Hess</code>. Further  an array of <code>m</code> normalized Arnoldi vectors is stored in in the pre-allocated <code>q</code>, plus one additional unnormalized Arnoldi vector.  The unnormalized <code>m+1</code>st vector could be used to easily extend a given <code>m×m</code> Hessenberg matrix to a <code>(m+1)×(m+1)</code> matrix.</p><p>If the extended Hessenberg matrix is requested (<code>extended=true</code>, default), the <code>m+1</code>st Arnoldi vector is also normalized, and it&#39;s norm will be stored in <code>m+1, m</code> entry of the (extended) Hessenberg matrix, which is an <code>(m+1)×(m+1)</code> matrix.</p><p>Return the size <code>m</code> of the calculated Hessenberg matrix. This will usually be the input <code>m</code>, except when the Krylov dimension of <code>H</code> starting from <code>Ψ</code> is less then <code>m</code>. E.g., if <code>Ψ</code> is an eigenstate of <code>H</code>, the returned <code>m</code> will be 1.</p><p>See <a href="http://en.wikipedia.org/wiki/Arnoldi_iteration">http://en.wikipedia.org/wiki/Arnoldi_iteration</a> for a description of the algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>Hess::Matrix{ComplexF64}</code>: Pre-allocated storage for the Hessemberg matrix.  Can be uninitialized on input. The matrix must be at least of size <code>m×m</code>, or  <code>(m+1)×(m+1)</code> if <code>extended=true</code>. On output, the <code>m×m</code> sub-matrix of <code>Hess</code>  (with the returned output <code>m</code>) will contain the Hessenberg matrix, and all  other elements of <code>Hess</code> be be set to zero.</li><li><code>q</code>: Pre-allocated array of states similar to <code>Ψ</code>, as storage for the calculated Arnoldi vectors. These may be un-initialized on input. Must be at least of length <code>m+1</code></li><li><code>m</code>: The requested dimensions of the output Hessenberg matrix.</li><li><code>Ψ</code>: The starting vector for the Arnoldi procedure. This can be of any type,  as long as <code>Φ = H * Ψ</code> results in a vector similar to <code>Ψ</code>, there is an inner  products of <code>Φ</code> and <code>Ψ</code> (<code>Ψ⋅Φ</code> is defined), and <code>norm(Ψ)</code> is defined.</li><li><code>H</code>: The operator (up to <code>dt</code>) for which to calculate the Arnoldi procedure. Can be of any type, as long as <code>H * Ψ</code> is defined.</li><li><code>dt</code>: The implicit time step; the total operator for which to calculate the Arnoldi procedure is <code>H * dt</code></li><li><code>extended</code>: If <code>true</code> (default), calculate the extended Hessenberg matrix, and normalized the final Arnoldi vector</li><li><code>norm_min</code>: the minimum value of the norm of <code>Ψ</code> at which <code>Ψ</code> should be  considered the zero vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/arnoldi.jl#L1-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.diagonalize_hessenberg_matrix-Tuple{Any, Any}" href="#QuantumPropagators.diagonalize_hessenberg_matrix-Tuple{Any, Any}"><code>QuantumPropagators.diagonalize_hessenberg_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagonalize_hessenberg_matrix(Hess, m; accumulate=false)</code></pre><p>Diagonalize the m × m top left submatrix of the given Hessenberg matrix.</p><p>If <code>accumulate</code> is <code>true</code>, return the concatenated eigenvalues for <code>Hess[1:1,1:1]</code> to <code>Hess[1:m,1:m]</code>, that is, all sumatrices of size 1 through <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/arnoldi.jl#L111-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.extend_arnoldi!" href="#QuantumPropagators.extend_arnoldi!"><code>QuantumPropagators.extend_arnoldi!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Extend dimension of Hessenberg matrix by one.</p><pre><code class="language-julia hljs">extend_arnoldi!(Hess, q, m, H, dt; norm_min=1e-15)</code></pre><p>extends the entries in <code>Hess</code> from size (m-1)×(m-1) to size m×m, and the list <code>q</code> of Arnoldi vectors from m to (m+1). It is assumed that the input <code>Hess</code> was created by a call to <a href="#QuantumPropagators.arnoldi!-Union{Tuple{T}, Tuple{Matrix{ComplexF64}, Array{T, N} where N, Int64, T, Any}, Tuple{Matrix{ComplexF64}, Array{T, N} where N, Int64, T, Any, Float64}} where T"><code>arnoldi!</code></a> with <code>extended=false</code> or a previous call to <code>extend_arnoldi!</code>. Note that <code>Hess</code> itself is not resized, so it must be allocated to size m×m or greater on input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/arnoldi.jl#L82-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.extend_leja!-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Any, OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Any}" href="#QuantumPropagators.extend_leja!-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Any, OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Any}"><code>QuantumPropagators.extend_leja!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extend_leja!(leja, n, newpoints, n_use)</code></pre><p>Given an array of <code>n</code> (ordered) Leja points, extract <code>n_use</code> points from <code>newpoints</code>, and append them to the existing Leja points. The array <code>leja</code> should be sufficiently large to hold the new Leja points, which are appended after index <code>n_old</code>. It will be re-allocated if necessary and may have a size of up to <code>2*(n+n_use)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>leja</code>: Array of leja values. Must contain the &quot;old&quot; leja values to be kept  in <code>leja(0:n-1)</code>. On output, <code>n_use</code> new leja points will be in  <code>leja(n+:n+n_use-1)</code>, for the original value of <code>n</code>.  The <code>leja</code> array must  use zero-based indexing.</li><li><code>n</code>: On input, number of &quot;old&quot; leja points in <code>leja</code>. On output, total number of leja points (i.e. <code>n=n+n_use</code>)</li><li><code>newpoints</code>: On input, candidate points for new leja points.  The <code>n_use</code> best values will be chosen and added to <code>leja</code>. On output, the values of <code>new_points</code> are undefined.</li><li><code>n_use</code>: Number of points that should be added to <code>leja</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/newton.jl#L58-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.extend_newton_coeffs!-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Int64, OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Any, Int64, Float64}" href="#QuantumPropagators.extend_newton_coeffs!-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Int64, OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Any, Int64, Float64}"><code>QuantumPropagators.extend_newton_coeffs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extend_newton_coeffs!(a, n_a, leja, func, n_leja, radius)</code></pre><p>Extend the array <code>a</code> of existing Newton coefficients for the expansion of the <code>func</code> from <code>n_a</code> coefficients to <code>n_leja</code> coefficients. Return a new value <code>n_a=n_a+n_leja</code> with the total number of Newton coefficients in the updated <code>a</code>.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: On input, a zero-based array of length <code>n_a</code> or greater, containing Newton coefficients. On output, array containing a total <code>n_leja</code> coefficients. The array <code>a</code> will be resized if necessary, and may have a length greater than <code>n_leja</code> on output</li><li><code>n_a</code>:  The number of Newton coefficients in <code>a</code>, on input. Elements of <code>a</code>  beyond the first <code>n_a</code> elements will be overwritten.</li><li><code>leja</code>: Array of normalized Leja points, containing at least <code>n_leja</code> elements.</li><li><code>func</code>: Function for which to calcluate Newton coeffiecients</li><li><code>n_leja</code>: The number of elements in <code>leja</code> to use for calculating new coefficients, and the total number of Newton coefficients on output</li><li><code>radius</code>: Normalization radius for divided differences</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/newton.jl#L131-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.random_state-Tuple{AbstractMatrix{T} where T}" href="#QuantumPropagators.random_state-Tuple{AbstractMatrix{T} where T}"><code>QuantumPropagators.random_state</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Random normalized quantum state.</p><pre><code class="language-julia hljs">    Ψ = random_state(H)</code></pre><p>returns a random normalized state compatible with the Hamiltonian <code>H</code>. This is intended to provide a starting vector for estimating the spectral radius of <code>H</code> via an Arnoldi method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/specrad.jl#L95-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.ritzvals" href="#QuantumPropagators.ritzvals"><code>QuantumPropagators.ritzvals</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculate a vector for Ritz values converged to a given precision.</p><pre><code class="language-julia hljs">R = ritzvals(G, state, m_min, m_max=2*m_min; prec=1e-5, norm_min=1e-15)</code></pre><p>calculates a complex vector <code>R</code> of at least <code>m_min</code> and at most <code>m_max</code> Ritz values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/bc66f681156a2282c802464152d63bfa854c0a37/src/specrad.jl#L113-L122">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Krotov.KrotovResult"><code>Krotov.KrotovResult</code></a></li><li><a href="#Krotov.PulseParametrization"><code>Krotov.PulseParametrization</code></a></li><li><a href="#QuantumControlBase.AbstractControlObjective"><code>QuantumControlBase.AbstractControlObjective</code></a></li><li><a href="#QuantumControlBase.ControlProblem"><code>QuantumControlBase.ControlProblem</code></a></li><li><a href="#QuantumControlBase.Objective"><code>QuantumControlBase.Objective</code></a></li><li><a href="#QuantumControlBase.WeightedObjective"><code>QuantumControlBase.WeightedObjective</code></a></li><li><a href="#QuantumPropagators.ChebyWrk"><code>QuantumPropagators.ChebyWrk</code></a></li><li><a href="#QuantumPropagators.ExpPropWrk"><code>QuantumPropagators.ExpPropWrk</code></a></li><li><a href="#QuantumPropagators.NewtonWrk"><code>QuantumPropagators.NewtonWrk</code></a></li><li><a href="#Base.adjoint"><code>Base.adjoint</code></a></li><li><a href="#Krotov.NoParametrization-Tuple{}"><code>Krotov.NoParametrization</code></a></li><li><a href="#Krotov.SquareParametrization"><code>Krotov.SquareParametrization</code></a></li><li><a href="#Krotov.TanhParametrization"><code>Krotov.TanhParametrization</code></a></li><li><a href="#Krotov.TanhSqParametrization"><code>Krotov.TanhSqParametrization</code></a></li><li><a href="#Krotov.optimize_pulses"><code>Krotov.optimize_pulses</code></a></li><li><a href="#Krotov.print_table-Tuple{Any, Any, Vararg{Any, N} where N}"><code>Krotov.print_table</code></a></li><li><a href="#QuantumControl.optimize"><code>QuantumControl.optimize</code></a></li><li><a href="#QuantumControlBase.F_re-Tuple{Any, Any}"><code>QuantumControlBase.F_re</code></a></li><li><a href="#QuantumControlBase.F_sm-Tuple{Any, Any}"><code>QuantumControlBase.F_sm</code></a></li><li><a href="#QuantumControlBase.F_ss-Tuple{Any, Any}"><code>QuantumControlBase.F_ss</code></a></li><li><a href="#QuantumControlBase.J_T_re-Tuple{Any, Any}"><code>QuantumControlBase.J_T_re</code></a></li><li><a href="#QuantumControlBase.J_T_sm-Tuple{Any, Any}"><code>QuantumControlBase.J_T_sm</code></a></li><li><a href="#QuantumControlBase.J_T_ss-Tuple{Any, Any}"><code>QuantumControlBase.J_T_ss</code></a></li><li><a href="#QuantumControlBase.blackman-Tuple{Any, Any, Any}"><code>QuantumControlBase.blackman</code></a></li><li><a href="#QuantumControlBase.box-Tuple{Any, Any, Any}"><code>QuantumControlBase.box</code></a></li><li><a href="#QuantumControlBase.chi_re!-Tuple{Any, Any, Any}"><code>QuantumControlBase.chi_re!</code></a></li><li><a href="#QuantumControlBase.chi_sm!-Tuple{Any, Any, Any}"><code>QuantumControlBase.chi_sm!</code></a></li><li><a href="#QuantumControlBase.chi_ss!-Tuple{Any, Any, Any}"><code>QuantumControlBase.chi_ss!</code></a></li><li><a href="#QuantumControlBase.discretize-Tuple{Function, Any}"><code>QuantumControlBase.discretize</code></a></li><li><a href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>QuantumControlBase.discretize_on_midpoints</code></a></li><li><a href="#QuantumControlBase.f_tau"><code>QuantumControlBase.f_tau</code></a></li><li><a href="#QuantumControlBase.flattop-Tuple{Any}"><code>QuantumControlBase.flattop</code></a></li><li><a href="#QuantumControlBase.getcontrols-Tuple{Tuple}"><code>QuantumControlBase.getcontrols</code></a></li><li><a href="#QuantumControlBase.initobjpropwrk"><code>QuantumControlBase.initobjpropwrk</code></a></li><li><a href="#QuantumControlBase.liouvillian"><code>QuantumControlBase.liouvillian</code></a></li><li><a href="#QuantumControlBase.obj_genfunc-Tuple{QuantumControlBase.AbstractControlObjective, Any}"><code>QuantumControlBase.obj_genfunc</code></a></li><li><a href="#QuantumControlBase.setcontrolvals-Union{Tuple{D}, Tuple{Tuple, D}} where D&lt;:AbstractDict"><code>QuantumControlBase.setcontrolvals</code></a></li><li><a href="#QuantumControlBase.setcontrolvals!-Union{Tuple{D}, Tuple{Any, Tuple, D}} where D&lt;:AbstractDict"><code>QuantumControlBase.setcontrolvals!</code></a></li><li><a href="#QuantumPropagators.arnoldi!-Union{Tuple{T}, Tuple{Matrix{ComplexF64}, Array{T, N} where N, Int64, T, Any}, Tuple{Matrix{ComplexF64}, Array{T, N} where N, Int64, T, Any, Float64}} where T"><code>QuantumPropagators.arnoldi!</code></a></li><li><a href="#QuantumPropagators.cheby!"><code>QuantumPropagators.cheby!</code></a></li><li><a href="#QuantumPropagators.cheby_coeffs"><code>QuantumPropagators.cheby_coeffs</code></a></li><li><a href="#QuantumPropagators.cheby_coeffs!"><code>QuantumPropagators.cheby_coeffs!</code></a></li><li><a href="#QuantumPropagators.diagonalize_hessenberg_matrix-Tuple{Any, Any}"><code>QuantumPropagators.diagonalize_hessenberg_matrix</code></a></li><li><a href="#QuantumPropagators.expprop!"><code>QuantumPropagators.expprop!</code></a></li><li><a href="#QuantumPropagators.extend_arnoldi!"><code>QuantumPropagators.extend_arnoldi!</code></a></li><li><a href="#QuantumPropagators.extend_leja!-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Any, OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Any}"><code>QuantumPropagators.extend_leja!</code></a></li><li><a href="#QuantumPropagators.extend_newton_coeffs!-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Int64, OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Any, Int64, Float64}"><code>QuantumPropagators.extend_newton_coeffs!</code></a></li><li><a href="#QuantumPropagators.get_from_storage!"><code>QuantumPropagators.get_from_storage!</code></a></li><li><a href="#QuantumPropagators.init_storage"><code>QuantumPropagators.init_storage</code></a></li><li><a href="#QuantumPropagators.initpropwrk"><code>QuantumPropagators.initpropwrk</code></a></li><li><a href="#QuantumPropagators.map_observable"><code>QuantumPropagators.map_observable</code></a></li><li><a href="#QuantumPropagators.map_observables"><code>QuantumPropagators.map_observables</code></a></li><li><a href="#QuantumPropagators.newton!"><code>QuantumPropagators.newton!</code></a></li><li><a href="#QuantumPropagators.propagate"><code>QuantumPropagators.propagate</code></a></li><li><a href="#QuantumPropagators.propstep!"><code>QuantumPropagators.propstep!</code></a></li><li><a href="#QuantumPropagators.random_state-Tuple{AbstractMatrix{T} where T}"><code>QuantumPropagators.random_state</code></a></li><li><a href="#QuantumPropagators.ritzvals"><code>QuantumPropagators.ritzvals</code></a></li><li><a href="#QuantumPropagators.specrange"><code>QuantumPropagators.specrange</code></a></li><li><a href="#QuantumPropagators.write_to_storage!"><code>QuantumPropagators.write_to_storage!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../howto/">« Howto</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.7 on <span class="colophon-date" title="Saturday 2 October 2021 04:44">Saturday 2 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

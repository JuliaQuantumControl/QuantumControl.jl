<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Local Submodules · QuantumControl.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliaquantumcontrol.github.io/QuantumControl.jl/api/quantum_control_reference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QuantumControl.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../glossary/">Glossary</a></li><li><a class="tocitem" href="../../manual/">User Manual</a></li><li><a class="tocitem" href="../../howto/">Howto</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/">List of Examples</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../quantum_control/">QuantumControl</a></li><li class="is-active"><a class="tocitem" href>Local Submodules</a><ul class="internal"><li><a class="tocitem" href="#QuantumControlFunctionalsLocalAPI"><span><code>QuantumControl.Functionals</code></span></a></li><li><a class="tocitem" href="#QuantumControlPulseParametrizationsLocalAPI"><span><code>QuantumControl.PulseParametrizations</code></span></a></li><li><a class="tocitem" href="#QuantumControlWorkflowsLocalAPI"><span><code>QuantumControl.Workflows</code></span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Subpackages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../quantum_propagators/">QuantumPropagators</a></li><li><a class="tocitem" href="../quantum_control_base/">QuantumControlBase</a></li><li><a class="tocitem" href="../krotov/">Krotov</a></li><li><a class="tocitem" href="../grape/">GRAPE</a></li></ul></li><li><a class="tocitem" href="../quantum_control_index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Local Submodules</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Local Submodules</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/master/docs/generate_api.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Local-Submodules"><a class="docs-heading-anchor" href="#Local-Submodules">Local Submodules</a><a id="Local-Submodules-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Submodules" title="Permalink"></a></h1><p>The following submodules of <code>QuantumControl</code> are defined <em>locally</em> (as opposed to being re-exported from sub-packages).</p><p><span>$\gdef\tgt{\text{tgt}}$</span> <span>$\gdef\tr{\operatorname{tr}}$</span> <span>$\gdef\Re{\operatorname{Re}}$</span> <span>$\gdef\Im{\operatorname{Im}}$</span></p><ul><li><a href="#QuantumControlFunctionalsLocalAPI"><code>QuantumControl.Functionals</code></a></li><li><a href="#QuantumControlPulseParametrizationsLocalAPI"><code>QuantumControl.PulseParametrizations</code></a></li><li><a href="#QuantumControlWorkflowsLocalAPI"><code>QuantumControl.Workflows</code></a></li></ul><h2 id="QuantumControlFunctionalsLocalAPI"><a class="docs-heading-anchor" href="#QuantumControlFunctionalsLocalAPI"><code>QuantumControl.Functionals</code></a><a id="QuantumControlFunctionalsLocalAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlFunctionalsLocalAPI" title="Permalink"></a></h2><p>Public Members:</p><ul><li><a href="#QuantumControl.Functionals.J_T_re"><code>J_T_re</code></a></li><li><a href="#QuantumControl.Functionals.J_T_sm"><code>J_T_sm</code></a></li><li><a href="#QuantumControl.Functionals.J_T_ss"><code>J_T_ss</code></a></li><li><a href="#QuantumControl.Functionals.J_a_fluence"><code>J_a_fluence</code></a></li><li><a href="#QuantumControl.Functionals.gate_functional"><code>gate_functional</code></a></li><li><a href="#QuantumControl.Functionals.make_gate_chi"><code>make_gate_chi</code></a></li></ul><p>Re-exported Members:</p><ul><li><a href="../quantum_control_base/#QuantumControlBase.make_chi"><code>make_chi</code></a></li><li><a href="../quantum_control_base/#QuantumControlBase.make_grad_J_a"><code>make_grad_J_a</code></a></li></ul><p>Private Members:</p><ul><li><a href="#QuantumControl.Functionals.chi_sm!"><code>chi_sm!</code></a></li><li><a href="#QuantumControl.Functionals.grad_J_a_fluence!"><code>grad_J_a_fluence!</code></a></li><li><a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a></li><li><a href="#QuantumControl.Functionals.F_re"><code>F_re</code></a></li><li><a href="#QuantumControl.Functionals.F_ss"><code>F_ss</code></a></li><li><a href="#QuantumControl.Functionals.chi_ss!"><code>chi_ss!</code></a></li><li><a href="#QuantumControl.Functionals.chi_re!"><code>chi_re!</code></a></li><li><a href="#QuantumControl.Functionals.F_sm"><code>F_sm</code></a></li></ul><h4 id="Public-members"><a class="docs-heading-anchor" href="#Public-members">Public members</a><a id="Public-members-1"></a><a class="docs-heading-anchor-permalink" href="#Public-members" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.Functionals.J_T_re" href="#QuantumControl.Functionals.J_T_re"><code>QuantumControl.Functionals.J_T_re</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Real-part functional.</p><pre><code class="language-julia hljs">J_T_re(ϕ, objectives; τ=nothing)</code></pre><p>calculates</p><p class="math-container">\[J_{T,\text{re}} = 1 - F_{\text{re}} \quad\in \begin{cases}
    [0, 2] &amp; \text{in Hilbert space} \\
    [0, 1] &amp; \text{in Liouville space.}
\end{cases}\]</p><p>All arguments are passed to <a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a> while evaluating <span>$F_{\text{re}}$</span> in <a href="#QuantumControl.Functionals.F_re"><code>F_re</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/functionals.jl#L275-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.Functionals.J_T_sm" href="#QuantumControl.Functionals.J_T_sm"><code>QuantumControl.Functionals.J_T_sm</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Square-modulus functional.</p><pre><code class="language-julia hljs">J_T_sm(ϕ, objectives; τ=nothing)</code></pre><p>calculates</p><p class="math-container">\[J_{T,\text{sm}} = 1 - F_{\text{sm}} \quad\in [0, 1].\]</p><p>All arguments are passed to <a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a> while evaluating <span>$F_{\text{sm}}$</span> in <a href="#QuantumControl.Functionals.F_sm"><code>F_sm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/functionals.jl#L181-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.Functionals.J_T_ss" href="#QuantumControl.Functionals.J_T_ss"><code>QuantumControl.Functionals.J_T_ss</code></a> — <span class="docstring-category">Function</span></header><section><div><p>State-to-state phase-insensitive functional.</p><pre><code class="language-julia hljs">J_T_ss(ϕ, objectives; τ=nothing)</code></pre><p>calculates</p><p class="math-container">\[J_{T,\text{ss}} = 1 - F_{\text{ss}} \in [0, 1].\]</p><p>All arguments are passed to <a href="#QuantumControl.Functionals.F_ss"><code>F_ss</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/functionals.jl#L100-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.Functionals.J_a_fluence" href="#QuantumControl.Functionals.J_a_fluence"><code>QuantumControl.Functionals.J_a_fluence</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Running cost for the pulse fluence.</p><pre><code class="language-julia hljs">J_a = J_a_fluence(pulsevals, tlist)</code></pre><p>calculates</p><p class="math-container">\[J_a = \sum_l \int_0^T |ϵ_l(t)|^2 dt = \left(\sum_{ln} |ϵ_{ln}|^2 \right) dt\]</p><p>where <span>$ϵ_{ln}$</span> are the values in the (vectorized) <code>pulsevals</code>, <code>n</code> is the index of the intervals of the time grid, and <span>$dt$</span> is the time step, taken from the first time interval of <code>tlist</code> and assumed to be uniform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/functionals.jl#L429-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.Functionals.gate_functional" href="#QuantumControl.Functionals.gate_functional"><code>QuantumControl.Functionals.gate_functional</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Convert a functional from acting on a gate to acting on propagated states.</p><pre><code class="nohighlight hljs">J_T = gate_functional(J_T_U; kwargs...)</code></pre><p>constructs a functional <code>J_T</code> that meets the requirements for for Krotov/GRAPE and <a href="../quantum_control_base/#QuantumControlBase.make_chi"><code>make_chi</code></a>. That is, the output <code>J_T</code> takes positional positional arguments <code>ϕ</code> and <code>objectives</code>. The input functional <code>J_T_U</code> is assumed to have the signature <code>J_T_U(U; kwargs...)</code> where <code>U</code> is a matrix with elements <span>$U_{ij} = ⟨Ψ_i|ϕ_j⟩$</span>, where <span>$|Ψ_i⟩$</span> is the <code>initial_state</code> of the i&#39;th <code>objectives</code> (assumed to be the i&#39;th canonical basis state) and <span>$|ϕ_j⟩$</span> is the result of forward-propagating <span>$|Ψ_j⟩$</span>. That is, <code>U</code> is the projection of the time evolution operator into the subspace defined by the basis in the <code>initial_states</code> of the  <code>objectives</code>.</p><p><strong>See also</strong></p><ul><li><a href="#QuantumControl.Functionals.make_gate_chi"><code>make_gate_chi</code></a> — create a corresponding <code>chi</code> function that acts more efficiently than the general <a href="../quantum_control_base/#QuantumControlBase.make_chi"><code>make_chi</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/functionals.jl#L334-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.Functionals.make_gate_chi" href="#QuantumControl.Functionals.make_gate_chi"><code>QuantumControl.Functionals.make_gate_chi</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return a function to evaluate <span>$|χ_k⟩ = -∂J_T(Û)/∂⟨ϕ_k|$</span> via the chain rule.</p><pre><code class="language-julia hljs">chi! = make_gate_chi(J_T_U, objectives; use_finite_differences=false, kwargs...)</code></pre><p>returns a function equivalent to</p><pre><code class="language-julia hljs">chi! = make_chi(gate_functional(J_T_U; kwargs...), objectives)</code></pre><p class="math-container">\[\begin{split}
    |χ_k⟩
    &amp;= -\frac{∂}{∂⟨ϕ_k|} J_T \\
    &amp;= - \frac{1}{2} \sum_i (∇_U J_T)_{ik} \frac{∂ U_{ik}}{∂⟨ϕ_k|} \\
    &amp;= - \frac{1}{2} \sum_i (∇_U J_T)_{ik} |Ψ_i⟩
\end{split}\]</p><p>where <span>$|Ψ_i⟩$</span> is the basis state stored as the <code>initial_state</code> of the i&#39;th <code>objective</code>, see <a href="#QuantumControl.Functionals.gate_functional"><code>gate_functional</code></a>.</p><p>The gradient <span>$∇_U J_T$</span> is obtained via automatic differentiation, or via finite differences if <code>use_finite_differences=true</code>.</p><p>Compared to the more general <a href="../quantum_control_base/#QuantumControlBase.make_chi"><code>make_chi</code></a>, <code>make_gate_chi</code> will generally have a slightly smaller numerical overhead, as it pushes the use of automatic differentiation down by one level.</p><p>With <code>use_finite_differences=true</code>, this routine serves to test and debug gradients for gate functionals obtained by automatic differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/functionals.jl#L368-L402">source</a></section></article><h4 id="Private-members"><a class="docs-heading-anchor" href="#Private-members">Private members</a><a id="Private-members-1"></a><a class="docs-heading-anchor-permalink" href="#Private-members" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.Functionals.chi_sm!" href="#QuantumControl.Functionals.chi_sm!"><code>QuantumControl.Functionals.chi_sm!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Backward boundary states <span>$|χ⟩$</span> for functional <a href="#QuantumControl.Functionals.J_T_sm"><code>J_T_sm</code></a>.</p><pre><code class="language-julia hljs">chi_sm!(χ, ϕ, objectives; τ=nothing)</code></pre><p>sets the elements of <code>χ</code> according to</p><p class="math-container">\[|χ_k⟩
= -\frac{\partial J_{T,\text{sm}}}{\partial ⟨ϕ_k(T)|}
= \frac{1}{N^2} w_k \sum_{j}^{N} w_j τ_j |ϕ_k^{\tgt}⟩\]</p><p>with <span>$|ϕ^{\tgt}_k⟩$</span>, <span>$τ_j$</span> and <span>$w_k$</span> as defined in <a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a>.</p><p>Note: this function can be obtained with <code>make_chi(J_T_sm, objectives)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/functionals.jl#L201-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.Functionals.grad_J_a_fluence!" href="#QuantumControl.Functionals.grad_J_a_fluence!"><code>QuantumControl.Functionals.grad_J_a_fluence!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Analytic derivative for <a href="#QuantumControl.Functionals.J_a_fluence"><code>J_a_fluence</code></a>.</p><pre><code class="language-julia hljs">grad_J_a_fluence!(∇J_a, pulsevals, tlist)</code></pre><p>sets the (vectorized) elements of <code>∇J_a</code> to <span>$2 ϵ_{ln} dt$</span>, where <span>$ϵ_{ln}$</span> are the (vectorized) elements of <code>pulsevals</code> and <span>$dt$</span> is the time step, taken from the first time interval of <code>tlist</code> and assumed to be uniform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/functionals.jl#L451-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.Functionals.f_tau" href="#QuantumControl.Functionals.f_tau"><code>QuantumControl.Functionals.f_tau</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Average complex overlap of the target states with forward-propagated states.</p><pre><code class="language-julia hljs">f_tau(ϕ, objectives; τ=nothing)</code></pre><p>calculates</p><p class="math-container">\[f_τ = \frac{1}{N} \sum_{k=1}^{N} w_k τ_k\]</p><p>with</p><p class="math-container">\[τ_k = ⟨ϕ_k^\tgt|ϕ_k(T)⟩\]</p><p>in Hilbert space, or</p><p class="math-container">\[τ_k = \tr[ρ̂_k^{\tgt\,\dagger} ρ̂_k(T)]\]</p><p>in Liouville space, where <span>$|ϕ_k⟩$</span> or <span>$ρ̂_k$</span> are the elements of <code>ϕ</code>, and <span>$|ϕ_k^\tgt⟩$</span> or <span>$ρ̂_k^\tgt$</span> are the target states from the <code>target_state</code> field of the <code>objectives</code>. If <code>τ</code> is given as a keyword argument, it must contain the values <code>τ_k</code> according to the above definition. Otherwise, the <span>$τ_k$</span> values will be calculated internally.</p><p><span>$N$</span> is the number of objectives, and <span>$w_k$</span> is the <code>weight</code> attribute for each objective. The weights are not automatically normalized, they are assumed to have values such that the resulting <span>$f_τ$</span> lies in the unit circle of the complex plane. Usually, this means that the weights should sum to <span>$N$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/functionals.jl#L19-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.Functionals.F_re" href="#QuantumControl.Functionals.F_re"><code>QuantumControl.Functionals.F_re</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Real-part fidelity.</p><pre><code class="language-julia hljs">F_re(ϕ, objectives; τ=nothing)</code></pre><p>calculates</p><p class="math-container">\[F_{\text{re}}
    = \Re[f_{τ}]
    = \Re\left[
        \frac{1}{N} \sum_{k=1}^{N} w_k τ_k
    \right]
    \quad\in \begin{cases}
    [-1, 1] &amp; \text{in Hilbert space} \\
    [0, 1] &amp; \text{in Liouville space.}
\end{cases}\]</p><p>with <span>$w_k$</span> the weight for the k&#39;th objective and <span>$τ_k$</span> the overlap of the k&#39;th propagated state with the k&#39;th target state, and <span>$N$</span> the number of objectives.</p><p>All arguments are passed to <a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a> to evaluate <span>$f_τ$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/functionals.jl#L244-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.Functionals.F_ss" href="#QuantumControl.Functionals.F_ss"><code>QuantumControl.Functionals.F_ss</code></a> — <span class="docstring-category">Function</span></header><section><div><p>State-to-state phase-insensitive fidelity.</p><pre><code class="language-julia hljs">F_ss(ϕ, objectives; τ=nothing)</code></pre><p>calculates</p><p class="math-container">\[F_{\text{ss}} = \frac{1}{N} \sum_{k=1}^{N} w_k |τ_k|^2 \quad\in [0, 1]\]</p><p>with <span>$N$</span>, <span>$w_k$</span> and <span>$τ_k$</span> as in <a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/functionals.jl#L72-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.Functionals.chi_ss!" href="#QuantumControl.Functionals.chi_ss!"><code>QuantumControl.Functionals.chi_ss!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Backward boundary states <span>$|χ⟩$</span> for functional <a href="#QuantumControl.Functionals.J_T_ss"><code>J_T_ss</code></a>.</p><pre><code class="language-julia hljs">chi_ss!(χ, ϕ, objectives; τ=nothing)</code></pre><p>sets the elements of <code>χ</code> according to</p><p class="math-container">\[|χ_k⟩
= -\frac{∂ J_{T,\text{ss}}}{∂ ⟨ϕ_k(T)|}
= \frac{1}{N} w_k τ_k |ϕ^{\tgt}_k⟩\,,\]</p><p>with <span>$|ϕ^{\tgt}_k⟩$</span>, <span>$τ_k$</span> and <span>$w_k$</span> as defined in <a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a>.</p><p>Note: this function can be obtained with <code>make_chi(J_T_ss, objectives)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/functionals.jl#L119-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.Functionals.chi_re!" href="#QuantumControl.Functionals.chi_re!"><code>QuantumControl.Functionals.chi_re!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Backward boundary states <span>$|χ⟩$</span> for functional <a href="#QuantumControl.Functionals.J_T_re"><code>J_T_re</code></a>.</p><pre><code class="language-julia hljs">chi_re!(χ, ϕ, objectives; τ=nothing)</code></pre><p>sets the elements of <code>χ</code> according to</p><p class="math-container">\[|χ_k⟩
= -\frac{∂ J_{T,\text{re}}}{∂ ⟨ϕ_k(T)|}
= \frac{1}{2N} w_k |ϕ^{\tgt}_k⟩\]</p><p>with <span>$|ϕ^{\tgt}_k⟩$</span> and <span>$w_k$</span> as defined in <a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a>.</p><p>Note: this function can be obtained with <code>make_chi(J_T_re, objectives)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/functionals.jl#L298-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.Functionals.F_sm" href="#QuantumControl.Functionals.F_sm"><code>QuantumControl.Functionals.F_sm</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Square-modulus fidelity.</p><pre><code class="language-julia hljs">F_sm(ϕ, objectives; τ=nothing)</code></pre><p>calculates</p><p class="math-container">\[F_{\text{sm}}
    = |f_τ|^2
    = \left\vert\frac{1}{N} \sum_{k=1}^{N} w_k τ_k\right\vert^2
    = \frac{1}{N^2} \sum_{k=1}^{N} \sum_{j=1}^{N} w_k w_j τ̄_k τ_j
    \quad\in [0, 1]\,,\]</p><p>with <span>$w_k$</span> the weight for the k&#39;th objective and <span>$τ_k$</span> the overlap of the k&#39;th propagated state with the k&#39;th target state, <span>$τ̄_k$</span> the complex conjugate of <span>$τ_k$</span>, and <span>$N$</span> the number of objectives.</p><p>All arguments are passed to <a href="#QuantumControl.Functionals.f_tau"><code>f_tau</code></a> to evaluate <span>$f_τ$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/functionals.jl#L154-L176">source</a></section></article><h2 id="QuantumControlPulseParametrizationsLocalAPI"><a class="docs-heading-anchor" href="#QuantumControlPulseParametrizationsLocalAPI"><code>QuantumControl.PulseParametrizations</code></a><a id="QuantumControlPulseParametrizationsLocalAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlPulseParametrizationsLocalAPI" title="Permalink"></a></h2><p>Public Members:</p><ul><li><a href="#QuantumControl.PulseParametrizations.LogisticParametrization"><code>LogisticParametrization</code></a></li><li><a href="#QuantumControl.PulseParametrizations.LogisticSqParametrization"><code>LogisticSqParametrization</code></a></li><li><a href="#QuantumControl.PulseParametrizations.ParametrizedAmplitude"><code>ParametrizedAmplitude</code></a></li><li><a href="#QuantumControl.PulseParametrizations.SquareParametrization"><code>SquareParametrization</code></a></li><li><a href="#QuantumControl.PulseParametrizations.TanhParametrization"><code>TanhParametrization</code></a></li><li><a href="#QuantumControl.PulseParametrizations.TanhSqParametrization"><code>TanhSqParametrization</code></a></li></ul><p>Private Members:</p><ul><li><a href="#QuantumControl.PulseParametrizations.PulseParametrization"><code>PulseParametrization</code></a></li></ul><h4 id="Public-members-2"><a class="docs-heading-anchor" href="#Public-members-2">Public members</a><a class="docs-heading-anchor-permalink" href="#Public-members-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.PulseParametrizations.LogisticParametrization" href="#QuantumControl.PulseParametrizations.LogisticParametrization"><code>QuantumControl.PulseParametrizations.LogisticParametrization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parametrization with a Logistic function that enforces <code>a_min &lt; a(t) &lt; a_max</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/pulse_parametrizations.jl#L107-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.PulseParametrizations.LogisticSqParametrization" href="#QuantumControl.PulseParametrizations.LogisticSqParametrization"><code>QuantumControl.PulseParametrizations.LogisticSqParametrization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parametrization with a Logistic-Square function that enforces <code>0 ≤ a(t) &lt; a_max</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/pulse_parametrizations.jl#L135-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.PulseParametrizations.ParametrizedAmplitude" href="#QuantumControl.PulseParametrizations.ParametrizedAmplitude"><code>QuantumControl.PulseParametrizations.ParametrizedAmplitude</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An amplitude determined by a pulse parametrization.</p><p>That is, <span>$a(t) = a(ϵ(t))$</span> with a bijective mapping between the value of <span>$a(t)$</span> and <span>$ϵ(t)$</span>, e.g. <span>$a(t) = ϵ^2(t)$</span> (a <a href="#QuantumControl.PulseParametrizations.SquareParametrization"><code>SquareParametrization</code></a>). Optionally, the amplitude may be multiplied with an additional shape function, cf. <a href="../quantum_propagators/#QuantumPropagators.Amplitudes.ShapedAmplitude"><code>ShapedAmplitude</code></a>.</p><pre><code class="language-julia hljs">ampl = ParametrizedAmplitude(control; parametrization)</code></pre><p>initilizes <span>$a(t) = a(ϵ(t)$</span> where <span>$ϵ(t)$</span> is the <code>control</code>, and the mandatory keyword argument <code>parametrization</code> is a <a href="#QuantumControl.PulseParametrizations.PulseParametrization"><code>PulseParametrization</code></a>. The <code>control</code> must either be a vector of values discretized to the midpoints of a time grid, or a callable <code>control(t)</code>.</p><pre><code class="language-julia hljs">ampl = ParametrizedAmplitude(control; parametrization, shape=shape)</code></pre><p>initializes <span>$a(t) = S(t) a(ϵ(t))$</span> where <span>$S(t)$</span> is the given <code>shape</code>. It must be a vector if <code>control</code> is a vector, or a callable <code>shape(t)</code> if <code>control</code> is a callable.</p><pre><code class="language-julia hljs">ampl = ParametrizedAmplitude(control, tlist; parametrization, shape=shape)</code></pre><p>discretizes <code>control</code> and <code>shape</code> (if given) to the midpoints of <code>tlist</code> before initialization.</p><pre><code class="language-julia hljs">ampl = ParametrizedAmplitude(
    amplitude, tlist; parametrization, shape=shape, parametrize=true
)</code></pre><p>initializes <span>$ã(t) = S(t) a(t)$</span> where <span>$a(t)$</span> is the input <code>amplitude</code>. First, if <code>amplitude</code> is a callable <code>amplitude(t)</code>, it is discretized to the midpoints of <code>tlist</code>. Then, a <code>control</code> <span>$ϵ(t)$</span> is calculated so that <span>$a(t) ≈ a(ϵ(t))$</span>. Clippling may occur if the values in <code>amplitude</code> cannot represented with the given <code>parametrization</code>. Lastly, <code>ParametrizedAmplitude(control; parametrization, shape)</code> is initialized with the calculated <code>control</code>.</p><p>Note that the <code>tlist</code> keyword argument is required when <code>parametrize=true</code> is given, even if <code>amplitude</code> is already a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/pulse_parametrizations.jl#L168-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.PulseParametrizations.SquareParametrization" href="#QuantumControl.PulseParametrizations.SquareParametrization"><code>QuantumControl.PulseParametrizations.SquareParametrization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parametrization a(t) = ϵ²(t), enforcing pulse values <span>$a(t) ≥ 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/pulse_parametrizations.jl#L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.PulseParametrizations.TanhParametrization" href="#QuantumControl.PulseParametrizations.TanhParametrization"><code>QuantumControl.PulseParametrizations.TanhParametrization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parametrization with a tanh function that enforces <code>a_min &lt; a(t) &lt; a_max</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/pulse_parametrizations.jl#L57-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.PulseParametrizations.TanhSqParametrization" href="#QuantumControl.PulseParametrizations.TanhSqParametrization"><code>QuantumControl.PulseParametrizations.TanhSqParametrization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parametrization with a tanh² function that enforces <code>0 ≤ a(t) &lt; a_max</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/pulse_parametrizations.jl#L83-L85">source</a></section></article><h4 id="Private-members-2"><a class="docs-heading-anchor" href="#Private-members-2">Private members</a><a class="docs-heading-anchor-permalink" href="#Private-members-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.PulseParametrizations.PulseParametrization" href="#QuantumControl.PulseParametrizations.PulseParametrization"><code>QuantumControl.PulseParametrizations.PulseParametrization</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Specification for a &quot;time-local&quot; pulse parametrization.</p><p>The parametrization is given as a collection of three functions:</p><ul><li><span>$a(ϵ(t))$</span></li><li><span>$ϵ(a(t))$</span></li><li><span>$∂a/∂ϵ$</span> as a function of <span>$ϵ(t)$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/pulse_parametrizations.jl#L20-L28">source</a></section></article><h2 id="QuantumControlWorkflowsLocalAPI"><a class="docs-heading-anchor" href="#QuantumControlWorkflowsLocalAPI"><code>QuantumControl.Workflows</code></a><a id="QuantumControlWorkflowsLocalAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlWorkflowsLocalAPI" title="Permalink"></a></h2><p>Public Members:</p><ul><li><a href="#QuantumControl.Workflows.@optimize_or_load"><code>@optimize_or_load</code></a></li><li><a href="#QuantumControl.Workflows.load_optimization"><code>load_optimization</code></a></li><li><a href="#QuantumControl.Workflows.run_or_load"><code>run_or_load</code></a></li></ul><h4 id="Public-members-3"><a class="docs-heading-anchor" href="#Public-members-3">Public members</a><a class="docs-heading-anchor-permalink" href="#Public-members-3" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.Workflows.@optimize_or_load" href="#QuantumControl.Workflows.@optimize_or_load"><code>QuantumControl.Workflows.@optimize_or_load</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Run <a href="../quantum_control_base/#QuantumControlBase.optimize"><code>optimize</code></a> and store the result, or load the result if it exists.</p><pre><code class="language-julia hljs">result = @optimize_or_load(
    file,
    problem;
    method,
    force=false,
    verbose=true,
    metadata=nothing,
    kwargs...
)</code></pre><p>runs <code>result = optimize(problem; method, kwargs...)</code> and stores <code>result</code> in <code>file</code> in the JLD2 format. Note that the <code>method</code> keyword argument is mandatory. In addition to the <code>result</code>, the data in the output <code>file</code> can also contain metadata. By default, this is &quot;script&quot; with the file name and line number of where <code>@optimize_or_load</code> was called, as well as data from the dict <code>metadata</code> mapping arbitrary (string) keys to values.</p><p>If <code>file</code> already exists (and <code>force=false</code>), load the <code>result</code> from that file instead of running the optimization.</p><p>All other <code>kwargs</code> are passed directly to <a href="../quantum_control_base/#QuantumControlBase.optimize"><code>optimize</code></a>.</p><p><strong>Related Functions</strong></p><ul><li><a href="#QuantumControl.Workflows.run_or_load"><code>run_or_load</code></a>  — a function for more general long-running calculations.</li><li><a href="#QuantumControl.Workflows.load_optimization"><code>load_optimization</code></a>: Function to load a file produced by <code>@optimize_or_load</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/workflows.jl#L184-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.Workflows.load_optimization" href="#QuantumControl.Workflows.load_optimization"><code>QuantumControl.Workflows.load_optimization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Load a previously stored optimization.</p><pre><code class="language-julia hljs">result = load_optimization(file; verbose=true, kwargs...)</code></pre><p>recovers a <code>result</code> previously stored by <a href="#QuantumControl.Workflows.@optimize_or_load"><code>@optimize_or_load</code></a>.</p><pre><code class="language-julia hljs">result, metadata = load_optimization(file; return_metadata=true, kwargs...)</code></pre><p>also obtains a metadata dict, see <a href="#QuantumControl.Workflows.@optimize_or_load"><code>@optimize_or_load</code></a>. This dict maps string keys to values.</p><p>Calling <code>load_optimization</code> with <code>verbose=true</code> (default) will show the metadata after loading the file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/workflows.jl#L249-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControl.Workflows.run_or_load" href="#QuantumControl.Workflows.run_or_load"><code>QuantumControl.Workflows.run_or_load</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Run some code and write the result to file, or load from the file if it exists.</p><pre><code class="language-julia hljs">data = run_or_load(
    file;
    save=(endswith(file, &quot;.jld2&quot;) ? JLD2.save_object : FileIO.save),
    load=(endswith(file, &quot;.jld2&quot;) ? JLD2.load_object : FileIO.load),
    force=false,
    verbose=true,
    kwargs...
) do
    data = Dict()  # ...  # something that can be saved to / loaded from file
    return data
end</code></pre><p>runs the code in the block and stores <code>data</code> in the given <code>file</code>. If <code>file</code> already exists, skip running the code and instead return the data in <code>file</code>.</p><p>If <code>force</code> is <code>True</code>, run the code whether or not <code>file</code> exists, potentially overwriting it.</p><p>With <code>verbose=true</code>, information about the status of <code>file</code> will be shown as <code>@info</code>.</p><p>The <code>data</code> returned by the code block must be compatible with the format of <code>file</code> and the <code>save</code>/<code>load</code> functions. When using <code>JLD2.save_object</code> and <code>JLD2.load_object</code>, almost any data can be written, so this should be particularly safe. More generally, when using <code>FileIO.save</code> and <code>FileIO.load</code>, see the <a href="https://juliaio.github.io/FileIO.jl/stable/registry/">FileIO registry</a> for details. A common examples would be a <a href="https://dataframes.juliadata.org/stable/"><code>DataFrame</code></a> being written to a <code>.csv</code> file.</p><p><strong>See also</strong></p><ul><li><a href="#QuantumControl.Workflows.@optimize_or_load"><code>@optimize_or_load</code></a> — for wrapping around <a href="../quantum_control_base/#QuantumControlBase.optimize"><code>optimize</code></a></li><li><a href="https://juliadynamics.github.io/DrWatson.jl/stable/save/#DrWatson.@produce_or_load"><code>DrWatson.@produce_or_load</code></a> — a similar but more opinionated function with automatic naming</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/17d3a0b29dedd3fedff175921ee136e80c1807bc/src/workflows.jl#L11-L52">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quantum_control/">« QuantumControl</a><a class="docs-footer-nextpage" href="../quantum_propagators/">QuantumPropagators »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/QuantumControl.jl">QuantumControl.jl</a> v0.6.0+dev docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Friday 17 February 2023 06:38">Friday 17 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

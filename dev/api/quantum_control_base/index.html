<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>QuantumControlBase · QuantumControl.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliaquantumcontrol.github.io/QuantumControl.jl/api/quantum_control_base/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QuantumControl.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../glossary/">Glossary</a></li><li><a class="tocitem" href="../../manual/">User Manual</a></li><li><a class="tocitem" href="../../howto/">Howto</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/">List of Examples</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../quantum_control/">QuantumControl</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox" checked/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Subpackages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../quantum_propagators/">QuantumPropagators</a></li><li class="is-active"><a class="tocitem" href>QuantumControlBase</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#QuantumControlBaseAPI"><span>QuantumControlBase</span></a></li><li><a class="tocitem" href="#QuantumControlBaseConditionalThreadsAPI"><span>QuantumControlBase.ConditionalThreads</span></a></li><li><a class="tocitem" href="#QuantumControlBaseFunctionalsAPI"><span>QuantumControlBase.Functionals</span></a></li><li><a class="tocitem" href="#QuantumControlBaseShapesAPI"><span>QuantumControlBase.Shapes</span></a></li><li><a class="tocitem" href="#QuantumControlBaseTestUtilsAPI"><span>QuantumControlBase.TestUtils</span></a></li></ul></li><li><a class="tocitem" href="../krotov/">Krotov</a></li><li><a class="tocitem" href="../grape/">GRAPE</a></li></ul></li></ul></li><li><a class="tocitem" href="../../history/">History</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li><a class="is-disabled">Subpackages</a></li><li class="is-active"><a href>QuantumControlBase</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>QuantumControlBase</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/master/docs/generate_api.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="QuantumControlBase-Package"><a class="docs-heading-anchor" href="#QuantumControlBase-Package">QuantumControlBase Package</a><a id="QuantumControlBase-Package-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBase-Package" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#QuantumControlBase.AbstractControlObjective"><code>QuantumControlBase.AbstractControlObjective</code></a></li><li><a href="#QuantumControlBase.ControlProblem"><code>QuantumControlBase.ControlProblem</code></a></li><li><a href="#QuantumControlBase.GradGenerator"><code>QuantumControlBase.GradGenerator</code></a></li><li><a href="#QuantumControlBase.GradVector"><code>QuantumControlBase.GradVector</code></a></li><li><a href="#QuantumControlBase.Objective"><code>QuantumControlBase.Objective</code></a></li><li><a href="#QuantumControlBase.TimeDependentGradGenerator"><code>QuantumControlBase.TimeDependentGradGenerator</code></a></li><li><a href="#QuantumControlBase.WeightedObjective"><code>QuantumControlBase.WeightedObjective</code></a></li><li><a href="#QuantumControlBase.Functionals.F_re"><code>QuantumControlBase.Functionals.F_re</code></a></li><li><a href="#QuantumControlBase.Functionals.F_sm"><code>QuantumControlBase.Functionals.F_sm</code></a></li><li><a href="#QuantumControlBase.Functionals.F_ss"><code>QuantumControlBase.Functionals.F_ss</code></a></li><li><a href="#QuantumControlBase.Functionals.J_T_re"><code>QuantumControlBase.Functionals.J_T_re</code></a></li><li><a href="#QuantumControlBase.Functionals.J_T_sm"><code>QuantumControlBase.Functionals.J_T_sm</code></a></li><li><a href="#QuantumControlBase.Functionals.J_T_ss"><code>QuantumControlBase.Functionals.J_T_ss</code></a></li><li><a href="#QuantumControlBase.Functionals.chi_re!"><code>QuantumControlBase.Functionals.chi_re!</code></a></li><li><a href="#QuantumControlBase.Functionals.chi_sm!"><code>QuantumControlBase.Functionals.chi_sm!</code></a></li><li><a href="#QuantumControlBase.Functionals.chi_ss!"><code>QuantumControlBase.Functionals.chi_ss!</code></a></li><li><a href="#QuantumControlBase.Functionals.f_tau"><code>QuantumControlBase.Functionals.f_tau</code></a></li><li><a href="#QuantumControlBase.Functionals.grad_J_T_sm!"><code>QuantumControlBase.Functionals.grad_J_T_sm!</code></a></li><li><a href="#QuantumControlBase.Shapes.blackman"><code>QuantumControlBase.Shapes.blackman</code></a></li><li><a href="#QuantumControlBase.Shapes.box"><code>QuantumControlBase.Shapes.box</code></a></li><li><a href="#QuantumControlBase.Shapes.flattop"><code>QuantumControlBase.Shapes.flattop</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_complex_matrix"><code>QuantumControlBase.TestUtils.random_complex_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_complex_sparse_matrix"><code>QuantumControlBase.TestUtils.random_complex_sparse_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_hermitian_matrix"><code>QuantumControlBase.TestUtils.random_hermitian_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_hermitian_sparse_matrix"><code>QuantumControlBase.TestUtils.random_hermitian_sparse_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_real_matrix"><code>QuantumControlBase.TestUtils.random_real_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_real_sparse_matrix"><code>QuantumControlBase.TestUtils.random_real_sparse_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_state_vector"><code>QuantumControlBase.TestUtils.random_state_vector</code></a></li><li><a href="#QuantumControlBase.chain_infohooks"><code>QuantumControlBase.chain_infohooks</code></a></li><li><a href="#QuantumControlBase.default_optimization_savename_kwargs"><code>QuantumControlBase.default_optimization_savename_kwargs</code></a></li><li><a href="#QuantumControlBase.discretize"><code>QuantumControlBase.discretize</code></a></li><li><a href="#QuantumControlBase.discretize_on_midpoints"><code>QuantumControlBase.discretize_on_midpoints</code></a></li><li><a href="#QuantumControlBase.evalcontrols"><code>QuantumControlBase.evalcontrols</code></a></li><li><a href="#QuantumControlBase.evalcontrols!"><code>QuantumControlBase.evalcontrols!</code></a></li><li><a href="#QuantumControlBase.get_control_parameters"><code>QuantumControlBase.get_control_parameters</code></a></li><li><a href="#QuantumControlBase.get_tlist_midpoints"><code>QuantumControlBase.get_tlist_midpoints</code></a></li><li><a href="#QuantumControlBase.getcontrolderiv"><code>QuantumControlBase.getcontrolderiv</code></a></li><li><a href="#QuantumControlBase.getcontrolderivs"><code>QuantumControlBase.getcontrolderivs</code></a></li><li><a href="#QuantumControlBase.getcontrols"><code>QuantumControlBase.getcontrols</code></a></li><li><a href="#QuantumControlBase.initobjpropwrk"><code>QuantumControlBase.initobjpropwrk</code></a></li><li><a href="#QuantumControlBase.liouvillian"><code>QuantumControlBase.liouvillian</code></a></li><li><a href="#QuantumControlBase.load_optimization"><code>QuantumControlBase.load_optimization</code></a></li><li><a href="#QuantumControlBase.objective_genfunc"><code>QuantumControlBase.objective_genfunc</code></a></li><li><a href="#QuantumControlBase.optimization_savename"><code>QuantumControlBase.optimization_savename</code></a></li><li><a href="#QuantumControlBase.optimize"><code>QuantumControlBase.optimize</code></a></li><li><a href="#QuantumControlBase.propagate_objective"><code>QuantumControlBase.propagate_objective</code></a></li><li><a href="#QuantumControlBase.resetgradvec!"><code>QuantumControlBase.resetgradvec!</code></a></li><li><a href="#QuantumControlBase.@optimize_or_load"><code>QuantumControlBase.@optimize_or_load</code></a></li><li><a href="#QuantumControlBase.ConditionalThreads.@threadsif"><code>QuantumControlBase.ConditionalThreads.@threadsif</code></a></li></ul><h2 id="QuantumControlBaseAPI"><a class="docs-heading-anchor" href="#QuantumControlBaseAPI">QuantumControlBase</a><a id="QuantumControlBaseAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBaseAPI" title="Permalink"></a></h2><h3 id="Public"><a class="docs-heading-anchor" href="#Public">Public</a><a id="Public-1"></a><a class="docs-heading-anchor-permalink" href="#Public" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.@optimize_or_load" href="#QuantumControlBase.@optimize_or_load"><code>QuantumControlBase.@optimize_or_load</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Run <a href="#QuantumControlBase.optimize"><code>optimize</code></a> and store the result, or load the result if it exists.</p><pre><code class="language-julia hljs">result, file = @optimize_or_load(
    path=&quot;&quot;,
    problem;
    method=&lt;method&gt;,
    filename=nothing,
    suffix=&quot;jld2&quot;,
    prefix=DrWatson.default_prefix(config),
    tag=DrWatson.readenv(&quot;DRWATSON_TAG&quot;, true),
    gitpath=DrWatson.projectdir(),
    storepatch::Bool=DrWatson.readenv(&quot;DRWATSON_STOREPATCH&quot;, false),
    force=false,
    verbose=true,
    wsave_kwargs=Dict(),
    savename_kwargs=DEFAULT_OPTIMIZATION_SAVENAME_KWARGS,
    kwargs...
)</code></pre><p>runs <code>result = optimize(problem; method=&lt;method&gt;, kwargs...)</code> and stores <code>result</code> in an automatically named file inside <code>path</code>. The automatic file name is determined by <a href="#QuantumControlBase.optimization_savename"><code>optimization_savename</code></a> and can be overriden by passing an explicit <code>filename</code>. The full path to the output file (<code>joinpath(path, filename)</code>) is returned as <code>file</code>.</p><p>In addition to the <code>result</code>, the data in the output <code>file</code> may also contain some metadata, e.g. &quot;gitcommit&quot; containing the git commit hash of the project the produced the file, and &quot;script&quot; with the file name and line number where <code>@optimize_or_load</code> was called, see <a href="#QuantumControlBase.load_optimization"><code>load_optimization</code></a>.</p><p>If <code>file</code> already exists (and <code>force=false</code>), load the <code>result</code> from that file instead of running the optimization.</p><p>The <code>@optimize_or_load</code> macro is intended to integrate well with the <a href="https://juliadynamics.github.io/DrWatson.jl/stable/"><code>DrWatson</code></a> framework for scientific projects and utilizes several configuration options and utility functions from <code>DrWatson</code>, see below. Note that even though <code>DrWatson</code> is recomended, you are not <em>required</em> to use if for your projects in order to use <code>@optimize_or_load</code> or any other part of <code>QuantumControl</code>.</p><p><strong>I/O Keywords</strong></p><p>The following keyword arguments determine where the result is stored and in which format.</p><ul><li><code>filename</code>: A file name to override the automatic file name. The <code>filename</code>  should not contain slashes: use <code>path</code> for the folder where <code>filename</code>  should be created.</li><li><code>suffix</code>, <code>prefix</code>, <code>savename_kwargs</code>: Parameters for <a href="#QuantumControlBase.optimization_savename"><code>optimization_savename</code></a>, which determines the automatic file name</li><li><code>tag</code>: Whether to record the current &quot;gitcommit&quot; as metadata alongside the  optimization result, via  <a href="https://juliadynamics.github.io/DrWatson.jl/stable/save/#DrWatson.tagsave"><code>DrWatson.tagsave</code></a>.  If not given explicitly, determine automatically from <code>suffix</code> or the  extension of <code>filename</code>.</li><li><code>gitpath</code>, <code>storepatch</code>: Passed to <code>DrWatson.tagsave</code> if <code>tag</code> is <code>true</code>.</li><li><code>force</code>: If <code>true</code>, run and store the optimization regardless of whether <code>file</code> already exists.</li><li><code>verbose</code>: If <code>true</code>, print info about the process, if <code>file</code> does not exist.</li><li><code>wsave_kwargs</code>: Additional keyword arguments to pass to <a href="https://juliadynamics.github.io/DrWatson.jl/stable/save/#Saving-Tools-1"><code>DrWatson.wsave</code></a>, e.g., to enable compression</li></ul><p>All other keyword arguments are passed directly to <a href="#QuantumControlBase.optimize"><code>optimize</code></a>.</p><p><strong>Related Functions</strong></p><ul><li><a href="#QuantumControlBase.optimization_savename"><code>optimization_savename</code></a>: Function that determines the automatic filename</li><li><a href="https://juliadynamics.github.io/DrWatson.jl/stable/save/#DrWatson.@produce_or_load"><code>DrWatson.@produce_or_load</code></a>: The lower-level backend implementing the functionality of <code>@optimize_or_load</code>.</li><li><a href="#QuantumControlBase.load_optimization"><code>load_optimization</code></a>: Function to load a file produced by <code>@optimize_or_load</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/optimize.jl#L111-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.ControlProblem" href="#QuantumControlBase.ControlProblem"><code>QuantumControlBase.ControlProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A full control problem with multiple objectives.</p><pre><code class="language-julia hljs">ControlProblem(
   objectives=&lt;list of objectives&gt;,
   pulse_options=&lt;dict of controls to pulse options&gt;,
   tlist=&lt;time grid&gt;,
   kwargs...
)</code></pre><p>Note that the control problem can only be instantiated via keyword arguments.</p><p>The <code>objectives</code> are a list of <a href="#QuantumControlBase.AbstractControlObjective"><code>AbstractControlObjective</code></a> instances, each defining an initial state and a dynamical generator for the evolution of that state. Usually, the objective will also include a target state (see <a href="#QuantumControlBase.Objective"><code>Objective</code></a>) and possibly a weight (see <a href="#QuantumControlBase.WeightedObjective"><code>WeightedObjective</code></a>).</p><p>The <code>pulse_options</code> are a dictionary (<code>IdDict</code>) mapping controls that occur in the <code>objectives</code> to properties specific to the control method.</p><p>The <code>tlist</code> is the time grid on which the time evolution of the initial states of each objective should be propagated.</p><p>The remaining <code>kwargs</code> are keyword arguments that are passed directly to the optimal control method. These typically include e.g. the optimization functional.</p><p>The control problem is solved by finding a set of controls that simultaneously fulfill all objectives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/controlproblem.jl#L73-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Objective" href="#QuantumControlBase.Objective"><code>QuantumControlBase.Objective</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Standard optimization objective.</p><pre><code class="language-julia hljs">Objective(;
    initial_state=&lt;initial_state&gt;,
    generator=&lt;genenerator&gt;,
    target_state=&lt;target_state&gt;
)</code></pre><p>describes an optimization objective where the time evoluation of the given <code>initial_state</code> under the given <code>generator</code> aims towards <code>target_state</code>. The <code>generator</code> here is e.g. a time-dependent Hamiltonian or Liouvillian.</p><p>The most common control problems in quantum control, e.g. state-to-state transitions or quantum gate implementations can be expressed by simultaneously fulfilling multiple objectives of this type.</p><p>Note that the objective can only be instantiated via keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/controlproblem.jl#L11-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.WeightedObjective" href="#QuantumControlBase.WeightedObjective"><code>QuantumControlBase.WeightedObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Standard optimization objective with a weight.</p><pre><code class="language-julia hljs">WeightedObjective(;
    initial_state=&lt;initial_state&gt;,
    generator=&lt;genenerator&gt;,
    target_state=&lt;target_state&gt;,
    weight=&lt;weight&gt;
)</code></pre><p>initializes a control objective like <a href="#QuantumControlBase.Objective"><code>Objective</code></a>, but with an additional <code>weight</code> parameter (a float generally between 0 and 1) that weights the objective relative to other objectives that are part of the same control problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/controlproblem.jl#L41-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.chain_infohooks" href="#QuantumControlBase.chain_infohooks"><code>QuantumControlBase.chain_infohooks</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Combine multiple <code>info_hook</code> functions.</p><pre><code class="language-julia hljs">chain_infohooks(funcs...)</code></pre><p>combines <code>funcs</code> into a single Function that can be passes as <code>info_hook</code> to <a href="#QuantumControlBase.ControlProblem"><code>ControlProblem</code></a> or any <code>optimize</code>-function.</p><p>Each function in <code>func</code> must be a suitable <code>info_hook</code> by itself. This means that it should receive the optimization workspace object as its first positional parameter, then positional parameters specific to the optimization method, and then an arbitrary number of data parameters. It must return either <code>nothing</code> or a tuple of &quot;info&quot; objects (which will end up in the <code>records</code> field of the optimization result).</p><p>When chaining infohooks, the <code>funcs</code> will be called in series, and the &quot;info&quot; objects will be accumulated into a single result tuple. The combined results from previous <code>funcs</code> will be given to the subsequent <code>funcs</code> as data parameters. This allows for the infohooks in the chain to communicate.</p><p>The chain will return the final combined result tuple, or <code>nothing</code> if all <code>funcs</code> return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/infohook.jl#L2-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.default_optimization_savename_kwargs" href="#QuantumControlBase.default_optimization_savename_kwargs"><code>QuantumControlBase.default_optimization_savename_kwargs</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Set the default <code>savename_kwargs</code> for <a href="#QuantumControlBase.optimization_savename"><code>optimization_savename</code></a>.</p><pre><code class="language-julia hljs">savename_kwargs = default_optimization_savename_kwargs(;kwargs...)</code></pre><p>sets entries in the <code>DEFAULT_OPTIMIZATION_SAVENAME_KWARGS</code> used in <code>optimization_savename</code> and thus determines the automatic name used to store optimization results.</p><p>Use</p><pre><code class="language-julia hljs">default_optimization_savename_kwargs(reset=true)</code></pre><p>to clear the settings from any previous call to <code>default_optimization_savename_kwargs</code>.</p><p>The following keyword arguments are supported, cf. <a href="https://juliadynamics.github.io/DrWatson.jl/dev/name/#DrWatson.savename"><code>DrWatson.savename</code></a>:</p><ul><li><code>accesses</code> - List of strings indicating which fields (keys in <code>kwargs</code> of <a href="#QuantumControlBase.ControlProblem"><code>ControlProblem</code></a> or <code>kwargs</code> of <a href="#QuantumControlBase.optimize"><code>optimize</code></a>/<a href="#QuantumControlBase.@optimize_or_load"><code>@optimize_or_load</code></a>) can be included in the output filename. By default, all fields with values matching <code>allowedtypes</code> (excluding anonymous functions) are used.</li><li><code>allowedtypes</code> - List of types of values eligible to be included in the filename. Defaults to <code>[Real, String, Symbol, TimeType, Function]</code></li><li><code>connector</code> - String used to separate key-value pairs in the output filename. Defaults to <code>&quot;_&quot;</code>.</li><li><code>digits</code> - Used in <code>round</code> when formatting numbers, if no custom <code>val_to_string</code>.</li><li><code>equals</code> - String used between keys and values. Defaults to <code>&quot;=&quot;</code>.</li><li><code>ignores</code> - List of strings indicating which fields should be ignored.</li><li><code>sigdigits</code> - Used in <code>round</code> when formatting numbers, if no custom <code>val_to_string</code>.</li><li><code>sort</code> - Whether to sort the fields alphabetically (default). If <code>false</code>, the resulting file name my not be stable.</li><li><code>val_to_string</code> - Function to convert values to string.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/optimize.jl#L279-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.discretize" href="#QuantumControlBase.discretize"><code>QuantumControlBase.discretize</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Evaluate <code>control</code> at every point of <code>tlist</code>.</p><pre><code class="language-julia hljs">values = discretize(control, tlist; via_midpoints=true)</code></pre><p>discretizes the given <code>control</code> to a Vector of values defined on the points of <code>tlist</code>.</p><p>If <code>control</code> is a function, it will will first be evaluated at the midpoint of <code>tlist</code>, see <a href="#QuantumControlBase.discretize_on_midpoints"><code>discretize_on_midpoints</code></a>, and then the values on the midpoints are converted to values on <code>tlist</code>. This discretization is more stable than directly evaluationg the control function at the values of <code>tlist</code>, and ensures that repeated round-trips between <a href="#QuantumControlBase.discretize"><code>discretize</code></a> and <a href="#QuantumControlBase.discretize_on_midpoints"><code>discretize_on_midpoints</code></a> can be done safely, see the note in the documentation of <a href="#QuantumControlBase.discretize_on_midpoints"><code>discretize_on_midpoints</code></a>.</p><p>The latter can still be achieved by passing <code>via_midpoints=false</code>. While such a direct discretization is suitable e.g. for plotting, but it is unsuitable for round-trips between <a href="#QuantumControlBase.discretize"><code>discretize</code></a> and <a href="#QuantumControlBase.discretize_on_midpoints"><code>discretize_on_midpoints</code></a>  (constant controls on <code>tlist</code> may result in a zig-zag on the intervals of <code>tlist</code>).</p><p>If <code>control</code> is a vector, it will be returned un-modified if it is of the same length as <code>tlist</code>. Otherwise, <code>control</code> must have one less value than <code>tlist</code>, and is assumed to be defined on the midpoins of <code>tlist</code>. In that case, <a href="#QuantumControlBase.discretize"><code>discretize</code></a> acts as the inverse of <a href="#QuantumControlBase.discretize_on_midpoints"><code>discretize_on_midpoints</code></a>. See <a href="#QuantumControlBase.discretize_on_midpoints"><code>discretize_on_midpoints</code></a> for how control values on <code>tlist</code> and control values on the intervals of <code>tlist</code> are related.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/controls.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.discretize_on_midpoints" href="#QuantumControlBase.discretize_on_midpoints"><code>QuantumControlBase.discretize_on_midpoints</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Evaluate <code>control</code> at the midpoints of <code>tlist</code>.</p><pre><code class="language-julia hljs">values = discretize_on_midpoints(control, tlist)</code></pre><p>discretizes the given <code>control</code> to a Vector of values on the midpoints of <code>tlist</code>. Hence, the resulting <code>values</code> will contain one less value than <code>tlist</code>.</p><p>If <code>control</code> is a vector of values defined on <code>tlist</code> (i.e., of the same length as <code>tlist</code>), it will be converted to a vector of values on the intervals of <code>tlist</code>. The value for the first and last &quot;midpoint&quot; will remain the original values at the beginning and end of <code>tlist</code>, in order to ensure exact bounary conditions. For all other midpoints, the value for that midpoint will be calculated by &quot;un-averaging&quot;.</p><p>For example, for a <code>control</code> and <code>tlist</code> of length 5, consider the following diagram:</p><pre><code class="nohighlight hljs">tlist index:       1   2   3   4   5
tlist:             ⋅   ⋅   ⋅   ⋅   ⋅   input values cᵢ (i ∈ 1..5)
                   |̂/ ̄ ̄ ̂\ / ̂\ / ̂ ̄ ̄\|̂
midpoints:         x     x   x     x   output values pᵢ (i ∈ 1..4)
midpoints index:   1     2   3     4</code></pre><p>We will have <span>$p₁=c₁$</span> for the first value, <span>$p₄=c₅$</span> for the last value. For all other points, the control values <span>$cᵢ = \frac{p_{i-1} + p_{i}}{2}$</span> are the average of the values on the midpoints. This implies the &quot;un-averaging&quot; for the midpoint values <span>$pᵢ = 2 c_{i} - p_{i-1}$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>An arbitrary input <code>control</code> array may not be compatible with the above averaging formula. In this case, the conversion will be &quot;lossy&quot; (<a href="#QuantumControlBase.discretize"><code>discretize</code></a> will not recover the original <code>control</code> array; the difference should be considered a &quot;discretization error&quot;). However, any <em>further</em> round-trip conversions between points and intervals are bijective and preserve the boundary conditions. In this case, the <a href="#QuantumControlBase.discretize_on_midpoints"><code>discretize_on_midpoints</code></a> and <a href="#QuantumControlBase.discretize"><code>discretize</code></a> methods are each other&#39;s inverse. This also implies that for an optimal control procedure, it is safe to modify <em>midpoint</em> values. Modifying the the values on the time grid directly on the other hand may accumulate discretization errors.</p></div></div><p>If <code>control</code> is a vector of one less length than <code>tlist</code>, it will be returned unchanged, under the assumption that the input is already properly discretized.</p><p>If <code>control</code> is a function, the function will be directly evaluated at the midpoints marked as <code>x</code> in the above diagram..</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/controls.jl#L81-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.get_control_parameters" href="#QuantumControlBase.get_control_parameters"><code>QuantumControlBase.get_control_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Collect all control parameters from the given objectives.</p><pre><code class="language-julia hljs">get_control_parameters(objectives...; kwargs...)</code></pre><p>returns a vector of control parameters extracted from the controls in <code>objectives</code>. This first extracts the controls with [<code>getcontrols</code>] and then the &quot;control parameters&quot; from each control. What are the &quot;control parameters&quot; are depends on the type of the control. For controls that are function ϵ(t), the control parameters are the values of the control function on intervals of the time grid. The time grid in the case must be passed as a keyword argument <code>tlist</code>.</p><p>The control parameters for multiple controls will be concatenated in the returned vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/controls.jl#L344-L361">source</a></section><section><div><pre><code class="language-julia hljs">get_control_parameters(func; tlist, on_midpoints=true)</code></pre><p>returns the control parameters of a control function by discretizing to the time grid in <code>tlist</code>. By default, the discretization is on intervals (midpoints) of the time grid. With <code>on_midpoints=false</code>, the discretization will be on the actual points of the time grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/controls.jl#L368-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.get_tlist_midpoints" href="#QuantumControlBase.get_tlist_midpoints"><code>QuantumControlBase.get_tlist_midpoints</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Shift time grid values the interval midpoints</p><pre><code class="language-julia hljs">tlist_midpoints = get_tlist_midpoints(tlist)</code></pre><p>takes a vector <code>tlist</code> of length <span>$n$</span> and returns a vector of length <span>$n-1$</span> containing the midpoint values of each interval. The intervals in <code>tlist</code> are not required to be uniform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/controls.jl#L59-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.getcontrols" href="#QuantumControlBase.getcontrols"><code>QuantumControlBase.getcontrols</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Extract a Tuple of controls.</p><pre><code class="language-julia hljs">controls = getcontrols(generator)</code></pre><p>extracts the controls from a single dynamical generator.</p><pre><code class="language-julia hljs">controls = getcontrols(objectives)</code></pre><p>extracts the controls from a list of objectives (i.e., from each objective&#39;s <code>generator</code>)</p><p>In either case, controls that occur multiple times, either in a single generator, or throughout the different objectives, will occur only once in the result.</p><p>By default, assumes that any <code>generator</code> is a nested Tuple, e.g. <code>(H0, (H1, ϵ1), (H2, ϵ2), ...)</code> and extracts (ϵ1, ϵ2)</p><p>Each control must be a valid argument for <code>discretize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/controls.jl#L156-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.liouvillian" href="#QuantumControlBase.liouvillian"><code>QuantumControlBase.liouvillian</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a Liouvillian super-operator.</p><pre><code class="language-julia hljs">ℒ = liouvillian(Ĥ, c_ops=(); convention=:LvN)</code></pre><p>calculates the sparse Liouvillian super-operator <code>ℒ</code> from the Hamiltonian <code>Ĥ</code> and a list <code>c_ops</code> of Lindblad operators.</p><p>With <code>convention=:LvN</code>, applying the resulting <code>ℒ</code> to a vectorized density matrix <code>ρ⃗</code> calculates <span>$\frac{d}{dt} \vec{\rho}(t) = ℒ \vec{\rho}(t)$</span> equivalent to the Liouville-von-Neumann equation for the density matrix <span>$ρ̂$</span>,</p><p class="math-container">\[\frac{d}{dt} ρ̂(t)
= -i [Ĥ, ρ̂(t)] + \sum_k\left(
    Â_k ρ̂ Â_k^\dagger
    - \frac{1}{2} A_k^\dagger Â_k ρ̂
    - \frac{1}{2} ρ̂ Â_k^\dagger Â_k
  \right)\,,\]</p><p>where the Lindblad operators <span>$Â_k$</span> are the elements of <code>c_ops</code>.</p><p>The Hamiltonian <span>$Ĥ$</span> may be time-dependent, using a nested-tuple format by default, e.g., <code>(Ĥ₀, (H₁, ϵ₁), (H₂, ϵ₂))</code>, where <code>ϵ₁</code> and <code>ϵ₂</code> are functions of time. In this case, the resulting <code>ℒ</code> will also be in nested tuple format, <code>ℒ = (ℒ₀, (ℒ₁, ϵ₁), (ℒ₂, ϵ₂))</code>, where the initial element contains the superoperator <code>ℒ₀</code> for the static component of the Liouvillian, i.e., the commutator with the drift Hamiltonian <code>Ĥ₀</code>, plus the dissipator (sum over <span>$k$</span>), as a sparse matrix. Time-dependent Lindblad operators are not supported. The remaining elements are tuples <code>(ℒ₁, ϵ₁)</code> and <code>(ℒ₂, ϵ₂)</code> corresponding to the commutators with the two control Hamiltonians, where <code>ℒ₁</code> and <code>ℒ₂</code> again are sparse matrices.</p><p>If <span>$Ĥ$</span> is not time-dependent, the resulting <code>ℒ</code> will be a single-element tuple containing the Liouvillian as a sparse matrix, <code>ℒ = (ℒ₀, )</code>.</p><p>With <code>convention=:TDSE</code>, the Liouvillian will be constructed for the equation of motion <span>$-i \hbar \frac{d}{dt} \vec{\rho}(t) = ℒ \vec{\rho}(t)$</span> to match exactly the form of the time-dependent Schrödinger equation. While this notation is not standard in the literature of open quantum systems, it has the benefit that the resulting <code>ℒ</code> can be used in a numerical propagator for a (non-Hermitian) Schrödinger equation without any change. Thus, for numerical applications, <code>convention=:TDSE</code> is generally preferred. The returned <code>ℒ</code> between the two conventions differs only by a factor of <span>$i$</span>, since we generally assume <span>$\hbar=1$</span>.</p><p>The <code>convention</code> keyword argument is mandatory, to force a conscious choice.</p><p>See <a href="https://arxiv.org/abs/1312.0111v2">Goerz et. al. &quot;Optimal control theory for a unitary operation under dissipative evolution&quot;, arXiv 1312.0111v2, Appendix B.2</a> for the explicit construction of the Liouvillian superoperator as a sparse matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/liouvillian.jl#L62-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.load_optimization" href="#QuantumControlBase.load_optimization"><code>QuantumControlBase.load_optimization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Load a previously stored optimization.</p><pre><code class="language-julia hljs">result = load_optimization(filename; verbose=true, kwargs...)</code></pre><p>recovers a <code>result</code> previously stored by <a href="#QuantumControlBase.@optimize_or_load"><code>@optimize_or_load</code></a>.</p><pre><code class="language-julia hljs">result, metadata = load_optimization(filename; return_metadata=true, kwargs...)</code></pre><p>also obtains a metadata dict containing e.g., &quot;gitcommit&quot; or &quot;script&quot; depending on the options to <a href="#QuantumControlBase.@optimize_or_load"><code>@optimize_or_load</code></a>.</p><p>Calling <code>load_optimization</code> with <code>verbose=true</code> (default) will show the metadata after loading the file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/optimize.jl#L340-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.optimization_savename" href="#QuantumControlBase.optimization_savename"><code>QuantumControlBase.optimization_savename</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Determine an automatic filename for storing an optimization result.</p><pre><code class="language-julia hljs">file = optimization_savename(
    path=&quot;&quot;,
    problem;
    method=&lt;method&gt;,
    suffix=&quot;jld2&quot;,
    prefix=&quot;&quot;,
    savename_kwargs=DEFAULT_OPTIMIZATION_SAVENAME_KWARGS,
    kwargs...,
)</code></pre><p>finds an appropriate automatic filename for the result of <code>optimize(problem; method=&lt;method&gt;, kwargs...)</code>.</p><p>By default, the <code>file</code> has the structure <code>&lt;path&gt;/&lt;prefix&gt;_&lt;key1&gt;=&lt;value1&gt;_..._&lt;keyN&gt;=&lt;valueN&gt;_method=&lt;method&gt;.jld2</code> where the key-value pairs are a subset of the keyword arguments used to instantiate <code>problem</code>, respectively the keyword arguments in <code>kwargs</code>. The <code>prefix</code> is best used as a &quot;name&quot; for the optimization problem to ensure a unique file name.</p><p>Which key-value pairs that are taken into account and the way they are formatted can be customized via <code>savename_kwargs</code>. See <a href="#QuantumControlBase.default_optimization_savename_kwargs"><code>default_optimization_savename_kwargs</code></a> for the supported options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/optimize.jl#L225-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.optimize" href="#QuantumControlBase.optimize"><code>QuantumControlBase.optimize</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Optimize a quantum control problem.</p><pre><code class="language-julia hljs">opt_result = optimize(problem; method=&lt;method&gt;, kwargs...)</code></pre><p>optimizes towards a solution of given <a href="#QuantumControlBase.ControlProblem"><code>problem</code></a> with the given optimization <code>method</code>. Any keyword argument temporarily overrides the corresponding keyword argument in <code>problem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/optimize.jl#L1-L11">source</a></section><section><div><pre><code class="language-julia hljs">opt_result = optimize(problem; method=:krotov, kwargs...)</code></pre><p>optimizes <a href="#QuantumControlBase.ControlProblem"><code>problem</code></a> using Krotov&#39;s method, see <a href="../krotov/#Krotov.optimize_krotov"><code>Krotov.optimize_krotov</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/Krotov.jl/blob/3fcd456a28be12745f6aff41f7025a0d6402617d/src/Krotov.jl#L16-L23">source</a></section><section><div><pre><code class="language-julia hljs">opt_result = optimize(problem; method=:GRAPE, kwargs...)</code></pre><p>optimizes <a href="#QuantumControlBase.ControlProblem"><code>problem</code></a> using GRadident Ascent Pulse Engineering (GRAPE), see <a href="../grape/#GRAPE.optimize_grape"><code>GRAPE.optimize_grape</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/GRAPE.jl/blob/ba4b06ee9a82d4623e6da15e382ed371365f197b/src/GRAPE.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.propagate_objective" href="#QuantumControlBase.propagate_objective"><code>QuantumControlBase.propagate_objective</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Propagate with the dynamical generator of a control objective.</p><pre><code class="language-julia hljs">propagate_objective(obj, tlist; method=:auto, initial_state=obj.initial_state,
                    controls_map=IdDict(), kwargs...)</code></pre><p>propagates <code>initial_state</code> under the dynamics described by <code>obj.generator</code>.</p><p>The optional dict <code>control_map</code> may be given to replace the controls in <code>obj.generator</code> (as obtained by <a href="#QuantumControlBase.getcontrols"><code>getcontrols</code></a>) with custom functions or vectors, e.g. with the controls resulting from optimization.</p><p>If <code>obj</code> has a property/field <code>prop_method</code> or <code>fw_prop_method</code>, its value will be used as the default for <code>method</code> instead of :auto. An explicit keyword argument for <code>method</code> always overrides the default.</p><p>All other <code>kwargs</code> are forwarded to the underlying <a href="../quantum_propagators/#QuantumPropagators.propagate"><code>QuantumPropagators.propagate</code></a> method for <code>obj.initial_state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/propagate.jl#L61-L81">source</a></section></article><h3 id="Private"><a class="docs-heading-anchor" href="#Private">Private</a><a id="Private-1"></a><a class="docs-heading-anchor-permalink" href="#Private" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.AbstractControlObjective" href="#QuantumControlBase.AbstractControlObjective"><code>QuantumControlBase.AbstractControlObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Base class for a single optimization objective.</p><p>All objectives must have a field <code>initial_state</code> and a field <code>generator</code>, at minimum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/controlproblem.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.resetgradvec!" href="#QuantumControlBase.resetgradvec!"><code>QuantumControlBase.resetgradvec!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Reset the given gradient vector for a new gradient evaluation.</p><pre><code class="language-julia hljs">resetgradvec!(Ψ̃::GradVector)</code></pre><p>zeroes out <code>Ψ̃.grad_states</code> but leaves <code>Ψ̃.state</code> unaffected.</p><pre><code class="language-julia hljs">resetgradvec!(Ψ̃::GradVector, Ψ)</code></pre><p>additionally sets <code>Ψ̃.state</code> to <code>Ψ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/gradgen.jl#L141-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.objective_genfunc" href="#QuantumControlBase.objective_genfunc"><code>QuantumControlBase.objective_genfunc</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a <code>genfunc</code> suitable for propagating an objective.</p><pre><code class="language-julia hljs">genfunc = objective_genfunc(obj, tlist; controls_map=IdDict())</code></pre><p>can be passed to <a href="../quantum_propagators/#QuantumPropagators.propagate"><code>QuantumPropagators.propagate</code></a> to propagate under the dynamical generator in <code>obj</code>.</p><p>If given, <code>control_map</code> defines replacements for the controls in <code>obj.generator</code>. This allows, e.g., to replace the controls with those resulting from an optimization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/propagate.jl#L5-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.getcontrolderiv" href="#QuantumControlBase.getcontrolderiv"><code>QuantumControlBase.getcontrolderiv</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get the derivative of the generator <span>$G$</span> w.r.t. the control <span>$ϵ(t)$</span>.</p><pre><code class="language-julia hljs">μ  = getcontrolderiv(generator, control)</code></pre><p>returns <code>nothing</code> if the <code>generator</code> (Hamiltonian or Liouvillian) does not depend on <code>control</code>, or a function <code>μ(v)</code> that evaluates</p><p class="math-container">\[μ(v) = \left.\frac{∂G}{∂ϵ(t)}\right\vert_{ϵ(t)=v}\]</p><p>otherwise. That is, a call <code>μ(v)</code> will return the static operator resulting from evaluating the derivative of the dynamical generator <span>$G$</span> with respect to the control filed <span>$ϵ(t)$</span> at a particular point in time where the control field takes the value <span>$v$</span>.</p><p>Note that for the common case of linear control terms, e.g., <span>$Ĥ = Ĥ_0 + \sum_l ϵ_l(t) Ĥ_l$</span>, the derivative <span>$∂Ĥ/∂ϵ_l(t)$</span> is simply the control Hamiltonian <span>$Ĥ_l$</span>. Thus, the resulting function <code>μ</code> will simply return <span>$Ĥ_l$</span>, ignoring the argument <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/controls.jl#L299-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TimeDependentGradGenerator" href="#QuantumControlBase.TimeDependentGradGenerator"><code>QuantumControlBase.TimeDependentGradGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Extended generator for the standard dynamic gradient.</p><pre><code class="language-julia hljs">G̃ = TimeDependentGradGenerator(G)</code></pre><p>contains the original time-dependent generator <code>G</code> (a Hamiltonian or Liouvillian) in <code>G̃.G</code>, a vector of control derivatives <span>$∂G/∂ϵₗ(t)$</span> in <code>G̃.control_derivs</code>, and the controls in <code>G̃.controls</code>.</p><p>For a generator <span>$G = Ĥ(t) = Ĥ₀ + ϵ₁(t) Ĥ₁ + … +  ϵₙ(t) Ĥₙ$</span>, this extended generator encodes the block-matrix</p><p class="math-container">\[G̃ = \begin{pmatrix}
         Ĥ(t)  &amp;  0    &amp;  \dots   &amp;  0     &amp;  Ĥ₁     \\
         0     &amp;  Ĥ(t) &amp;  \dots   &amp;  0     &amp;  Ĥ₂     \\
    \vdots     &amp;       &amp;  \ddots  &amp;        &amp;  \vdots \\
         0     &amp;  0    &amp;  \dots   &amp;  Ĥ(t)  &amp;  Ĥₙ     \\
         0     &amp;  0    &amp;  \dots   &amp;  0     &amp;  Ĥ(t)
\end{pmatrix}\]</p><p>Note that the <span>$∂G/∂ϵₗ(t)$</span> (<span>$Ĥₗ$</span> in the above example) are functions, to account for the possibility of non-linear control terms, see <a href="#QuantumControlBase.getcontrolderiv"><code>getcontrolderiv</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/gradgen.jl#L5-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.GradGenerator" href="#QuantumControlBase.GradGenerator"><code>QuantumControlBase.GradGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Static generator for the standard dynamic gradient.</p><pre><code class="language-julia hljs">G::GradGenerator = evalcontrols(G_of_t::TimeDependentGradGenerator, vals_dict)</code></pre><p>is the result of plugging in specific values for all controls in a <a href="#QuantumControlBase.TimeDependentGradGenerator"><code>TimeDependentGradGenerator</code></a>. See <a href="#QuantumControlBase.evalcontrols"><code>evalcontrols</code></a> and <a href="#QuantumControlBase.evalcontrols!"><code>evalcontrols!</code></a>.</p><p>The resulting object can be multiplied directly with a <a href="#QuantumControlBase.GradVector"><code>GradVector</code></a>, e.g., in the process of evaluating a piecewise-constant time propagation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/gradgen.jl#L46-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.evalcontrols!" href="#QuantumControlBase.evalcontrols!"><code>QuantumControlBase.evalcontrols!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>In-place version of <a href="#QuantumControlBase.evalcontrols"><code>evalcontrols</code></a>.</p><pre><code class="language-julia hljs">evalcontrols!(G, generator, vals_dict)</code></pre><p>acts as <a href="#QuantumControlBase.evalcontrols"><code>evalcontrols</code></a>, but modifies <code>G</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/controls.jl#L251-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.evalcontrols" href="#QuantumControlBase.evalcontrols"><code>QuantumControlBase.evalcontrols</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Replace the controls in <code>generator</code> with static values.</p><pre><code class="language-julia hljs">G = evalcontrols(generator, vals_dict)</code></pre><p>replaces the time-dependent controls in <code>generator</code> with the values in <code>vals_dict</code> and returns the static operator <code>G</code>.</p><p>The <code>vals_dict</code> is a dictionary (<code>IdDict</code>) mapping controls as returned by <code>getcontrols(generator)</code> to values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/controls.jl#L220-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.GradVector" href="#QuantumControlBase.GradVector"><code>QuantumControlBase.GradVector</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Extended state-vector for the dynamic gradient.</p><pre><code class="language-julia hljs">Ψ̃ = GradVector(Ψ, num_controls)</code></pre><p>for an initial state <code>Ψ</code> and <code>num_controls</code> control fields.</p><p>The <code>GradVector</code> conceptually corresponds to a direct-sum (block) column-vector <span>$Ψ̃ = (|Ψ̃₁⟩, |Ψ̃₂⟩, … |Ψ̃ₙ⟩, |Ψ⟩)^T$</span>, where <span>$n$</span> is <code>num_controls</code>. With a matching <span>$G̃$</span> as in the documentation of <a href="#QuantumControlBase.TimeDependentGradGenerator"><code>TimeDependentGradGenerator</code></a>, we have</p><p class="math-container">\[G̃ Ψ̃ = \begin{pmatrix}
Ĥ |Ψ̃₁⟩ + Ĥ₁|Ψ⟩ \\
\vdots \\
Ĥ |Ψ̃ₙ⟩ + Ĥₙ|Ψ⟩ \\
Ĥ |Ψ⟩
\end{pmatrix}\]</p><p>and</p><p class="math-container">\[e^{-i G̃ dt} \begin{pmatrix} 0 \\ \vdots \\ 0 \\ |Ψ⟩ \end{pmatrix}
= \begin{pmatrix}
\frac{∂}{∂ϵ₁} e^{-i Ĥ dt} |Ψ⟩ \\
\vdots \\
\frac{∂}{∂ϵₙ} e^{-i Ĥ dt} |Ψ⟩ \\
e^{-i Ĥ dt} |Ψ⟩
\end{pmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/gradgen.jl#L93-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.initobjpropwrk" href="#QuantumControlBase.initobjpropwrk"><code>QuantumControlBase.initobjpropwrk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wrk = initobjpropwrk(obj, tlist, method; kwargs...)</code></pre><p>initializes a workspace for the propagation of an <a href="#QuantumControlBase.AbstractControlObjective"><code>AbstractControlObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/propagate.jl#L139-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.getcontrolderivs" href="#QuantumControlBase.getcontrolderivs"><code>QuantumControlBase.getcontrolderivs</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get a vector of the derivatives of <code>generator</code> w.r.t. each control.</p><pre><code class="language-julia hljs">getcontrolderivs(generator, controls)</code></pre><p>return as vector containing the derivative of <code>generator</code> with respect to each control in <code>controls</code>. The elements of the vector are either <code>nothing</code> if <code>generator</code> does not depend on that particular control, or a function <code>μ(α)</code> that evaluates the derivative for a particular value of the control, see <a href="#QuantumControlBase.getcontrolderiv"><code>getcontrolderiv</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/controls.jl#L278-L290">source</a></section></article><h2 id="QuantumControlBaseConditionalThreadsAPI"><a class="docs-heading-anchor" href="#QuantumControlBaseConditionalThreadsAPI">QuantumControlBase.ConditionalThreads</a><a id="QuantumControlBaseConditionalThreadsAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBaseConditionalThreadsAPI" title="Permalink"></a></h2><h3 id="Private-2"><a class="docs-heading-anchor" href="#Private-2">Private</a><a class="docs-heading-anchor-permalink" href="#Private-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.ConditionalThreads.@threadsif" href="#QuantumControlBase.ConditionalThreads.@threadsif"><code>QuantumControlBase.ConditionalThreads.@threadsif</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Conditionally apply multi-threading to <code>for</code> loops.</p><p>This is a variation on <code>Base.Threads.@threads</code> that adds a run-time boolean flag to enable or disable threading. It is intended for <em>internal use</em> in packages building on <code>QuantumControlBase</code>.</p><p>Usage:</p><pre><code class="language-julia hljs">using QuantumControlBase.ConditionalThreads: @threadsif

function optimize(objectives; use_threads=true)
    @threadsif use_threads for k = 1:length(objectives)
    # ...
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/conditionalthreads.jl#L6-L24">source</a></section></article><h2 id="QuantumControlBaseFunctionalsAPI"><a class="docs-heading-anchor" href="#QuantumControlBaseFunctionalsAPI">QuantumControlBase.Functionals</a><a id="QuantumControlBaseFunctionalsAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBaseFunctionalsAPI" title="Permalink"></a></h2><h3 id="Public-2"><a class="docs-heading-anchor" href="#Public-2">Public</a><a class="docs-heading-anchor-permalink" href="#Public-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.F_re" href="#QuantumControlBase.Functionals.F_re"><code>QuantumControlBase.Functionals.F_re</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Real-part fidelity.</p><pre><code class="language-julia hljs">F_re(ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/functionals.jl#L147-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.F_sm" href="#QuantumControlBase.Functionals.F_sm"><code>QuantumControlBase.Functionals.F_sm</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Square-modulus fidelity.</p><pre><code class="language-julia hljs">F_sm(ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/functionals.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.F_ss" href="#QuantumControlBase.Functionals.F_ss"><code>QuantumControlBase.Functionals.F_ss</code></a> — <span class="docstring-category">Function</span></header><section><div><p>State-to-state phase-insensitive fidelity.</p><pre><code class="language-julia hljs">F_ss(ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/functionals.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.J_T_re" href="#QuantumControlBase.Functionals.J_T_re"><code>QuantumControlBase.Functionals.J_T_re</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Real-part functional.</p><pre><code class="language-julia hljs">J_T_re(ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/functionals.jl#L158-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.J_T_sm" href="#QuantumControlBase.Functionals.J_T_sm"><code>QuantumControlBase.Functionals.J_T_sm</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Square-modulus functional.</p><pre><code class="language-julia hljs">J_T_sm(ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/functionals.jl#L92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.J_T_ss" href="#QuantumControlBase.Functionals.J_T_ss"><code>QuantumControlBase.Functionals.J_T_ss</code></a> — <span class="docstring-category">Function</span></header><section><div><p>State-to-state phase-insensitive functional.</p><pre><code class="language-julia hljs">J_T_ss(ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/functionals.jl#L49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.chi_re!" href="#QuantumControlBase.Functionals.chi_re!"><code>QuantumControlBase.Functionals.chi_re!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Krotov-states χ for functional <a href="#QuantumControlBase.Functionals.J_T_re"><code>J_T_re</code></a>.</p><pre><code class="language-julia hljs">chi_re!(χ, ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/functionals.jl#L169-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.chi_sm!" href="#QuantumControlBase.Functionals.chi_sm!"><code>QuantumControlBase.Functionals.chi_sm!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Krotov-states χ for functional <a href="#QuantumControlBase.Functionals.J_T_sm"><code>J_T_sm</code></a>.</p><pre><code class="language-julia hljs">chi_sm!(χ, ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/functionals.jl#L118-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.chi_ss!" href="#QuantumControlBase.Functionals.chi_ss!"><code>QuantumControlBase.Functionals.chi_ss!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Krotov-states χ for functional <a href="#QuantumControlBase.Functionals.J_T_ss"><code>J_T_ss</code></a>.</p><pre><code class="language-julia hljs">chi_ss!(χ, ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/functionals.jl#L60-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.grad_J_T_sm!" href="#QuantumControlBase.Functionals.grad_J_T_sm!"><code>QuantumControlBase.Functionals.grad_J_T_sm!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Gradient for <a href="#QuantumControlBase.Functionals.J_T_sm"><code>J_T_sm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/functionals.jl#L103">source</a></section></article><h3 id="Private-3"><a class="docs-heading-anchor" href="#Private-3">Private</a><a class="docs-heading-anchor-permalink" href="#Private-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.f_tau" href="#QuantumControlBase.Functionals.f_tau"><code>QuantumControlBase.Functionals.f_tau</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Average complex overlap of the target states with forward-propagated states.</p><pre><code class="language-julia hljs">f_tau(ϕ, objectives; τ=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/functionals.jl#L12-L18">source</a></section></article><h2 id="QuantumControlBaseShapesAPI"><a class="docs-heading-anchor" href="#QuantumControlBaseShapesAPI">QuantumControlBase.Shapes</a><a id="QuantumControlBaseShapesAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBaseShapesAPI" title="Permalink"></a></h2><h3 id="Public-3"><a class="docs-heading-anchor" href="#Public-3">Public</a><a class="docs-heading-anchor-permalink" href="#Public-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Shapes.blackman" href="#QuantumControlBase.Shapes.blackman"><code>QuantumControlBase.Shapes.blackman</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Blackman window shape.</p><pre><code class="language-julia hljs">blackman(t, t₀, T; a=0.16)</code></pre><p>calculates</p><p class="math-container">\[B(t; t_0, T) =
    \frac{1}{2}\left(
        1 - a - \cos\left(2π \frac{t - t_0}{T - t_0}\right)
        + a \cos\left(4π \frac{t - t_0}{T - t_0}\right)
    \right)\,,\]</p><p>for a scalar <code>t</code>, with <span>$a$</span> = 0.16.</p><p>See <a href="http://en.wikipedia.org/wiki/Window_function#Blackman_windows">http://en.wikipedia.org/wiki/Window_function#Blackman_windows</a></p><p>A Blackman shape looks nearly identical to a Gaussian with a 6-sigma interval between <code>t₀</code> and <code>T</code>.  Unlike the Gaussian, however, it will go exactly to zero at the edges. Thus, Blackman pulses are often preferable to Gaussians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/shapes.jl#L75-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Shapes.box" href="#QuantumControlBase.Shapes.box"><code>QuantumControlBase.Shapes.box</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Box shape (Theta-function).</p><pre><code class="language-julia hljs">box(t, t₀, T)</code></pre><p>evaluates the Heaviside (Theta-) function <span>$\Theta(t) = 1$</span> for <span>$t_0 \le t \le T$</span>; and <span>$\Theta(t) = 0$</span> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/shapes.jl#L63-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Shapes.flattop" href="#QuantumControlBase.Shapes.flattop"><code>QuantumControlBase.Shapes.flattop</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Flat shape (one) with a switch-on/switch-off from zero.</p><pre><code class="language-julia hljs">flattop(t; t₀, T, t_rise, t_fall=t_rise, func=:blackman)</code></pre><p>evaluates a shape function that starts at 0 at <span>$t=t₀$</span>, and ramps to to 1 during the <code>t_rise</code> interval. The function then remains at value 1, before ramping down to 0 again during the interval <code>t_fall</code> before <code>T</code>. For <span>$t &lt; t₀$</span> and <span>$t &gt; T$</span>, the shape is zero.</p><p>The default switch-on/-off shape is half of a Blackman window (see <a href="#QuantumControlBase.Shapes.blackman"><code>blackman</code></a>).</p><p>For <code>func=:sinsq</code>, the switch-on/-off shape is a sine-squared curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/shapes.jl#L6-L22">source</a></section></article><h2 id="QuantumControlBaseTestUtilsAPI"><a class="docs-heading-anchor" href="#QuantumControlBaseTestUtilsAPI">QuantumControlBase.TestUtils</a><a id="QuantumControlBaseTestUtilsAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBaseTestUtilsAPI" title="Permalink"></a></h2><h3 id="Public-4"><a class="docs-heading-anchor" href="#Public-4">Public</a><a class="docs-heading-anchor-permalink" href="#Public-4" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.random_complex_matrix" href="#QuantumControlBase.TestUtils.random_complex_matrix"><code>QuantumControlBase.TestUtils.random_complex_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a random complex matrix of size N×N with spectral radius ρ.</p><pre><code class="language-julia hljs">random_complex_matrix(N, ρ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/testutils.jl#L14-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.random_complex_sparse_matrix" href="#QuantumControlBase.TestUtils.random_complex_sparse_matrix"><code>QuantumControlBase.TestUtils.random_complex_sparse_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a random sparse complex matrix.</p><pre><code class="language-julia hljs">random_complex_sparse_matrix(N, ρ, sparsity)</code></pre><p>returns a matrix of size N×N with spectral radius ρ and the given sparsity (number between zero and one that is the approximate fraction of non-zero elements).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/testutils.jl#L54-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.random_hermitian_matrix" href="#QuantumControlBase.TestUtils.random_hermitian_matrix"><code>QuantumControlBase.TestUtils.random_hermitian_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a random Hermitian matrix of size N×N with spectral radius ρ.</p><pre><code class="language-julia hljs">random_hermitian_matrix(N, ρ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/testutils.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.random_hermitian_sparse_matrix" href="#QuantumControlBase.TestUtils.random_hermitian_sparse_matrix"><code>QuantumControlBase.TestUtils.random_hermitian_sparse_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a random sparse Hermitian matrix.</p><pre><code class="language-julia hljs">random_hermitian_sparse_matrix(N, ρ, sparsity)</code></pre><p>returns a matrix of size N×N with spectral radius ρ and the given sparsity (number between zero and one that is the approximate fraction of non-zero elements).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/testutils.jl#L90-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.random_real_matrix" href="#QuantumControlBase.TestUtils.random_real_matrix"><code>QuantumControlBase.TestUtils.random_real_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a random real-valued matrix of size N×N with spectral radius ρ.</p><pre><code class="language-julia hljs">random_real_matrix(N, ρ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/testutils.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.random_real_sparse_matrix" href="#QuantumControlBase.TestUtils.random_real_sparse_matrix"><code>QuantumControlBase.TestUtils.random_real_sparse_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a random sparse real-valued matrix.</p><pre><code class="language-julia hljs">random_real_sparse_matrix(N, ρ, sparsity)</code></pre><p>returns a matrix of size N×N with spectral radius ρ and the given sparsity (number between zero and one that is the approximate fraction of non-zero elements).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/testutils.jl#L73-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.random_state_vector" href="#QuantumControlBase.TestUtils.random_state_vector"><code>QuantumControlBase.TestUtils.random_state_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return a random, normalized Hilbert space state vector of dimension <code>N</code>.</p><pre><code class="language-julia hljs">random_state_vector(N)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/dd40173f62d7d06a44aaa6575813a1e703b9ce71/src/testutils.jl#L108-L114">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quantum_propagators/">« QuantumPropagators</a><a class="docs-footer-nextpage" href="../krotov/">Krotov »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/QuantumControl.jl">QuantumControl.jl</a> v0.0.4+dev docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Saturday 12 February 2022 05:41">Saturday 12 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

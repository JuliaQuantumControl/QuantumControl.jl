<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>QuantumControlBase · QuantumControl.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliaquantumcontrol.github.io/QuantumControl.jl/api/quantum_control_base/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QuantumControl.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../glossary/">Glossary</a></li><li><a class="tocitem" href="../../manual/">User Manual</a></li><li><a class="tocitem" href="../../howto/">Howto</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/">List of Examples</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../quantum_control/">QuantumControl</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox" checked/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Subpackages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../quantum_propagators/">QuantumPropagators</a></li><li class="is-active"><a class="tocitem" href>QuantumControlBase</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#QuantumControlBaseAPI"><span>QuantumControlBase</span></a></li><li><a class="tocitem" href="#QuantumControlBaseConditionalThreadsAPI"><span>QuantumControlBase.ConditionalThreads</span></a></li><li><a class="tocitem" href="#QuantumControlBaseFunctionalsAPI"><span>QuantumControlBase.Functionals</span></a></li><li><a class="tocitem" href="#QuantumControlBasePulseParametrizationsAPI"><span>QuantumControlBase.PulseParametrizations</span></a></li><li><a class="tocitem" href="#QuantumControlBaseTestUtilsAPI"><span>QuantumControlBase.TestUtils</span></a></li><li><a class="tocitem" href="#QuantumControlBaseWeylChamberAPI"><span>QuantumControlBase.WeylChamber</span></a></li></ul></li><li><a class="tocitem" href="../krotov/">Krotov</a></li><li><a class="tocitem" href="../grape/">GRAPE</a></li></ul></li></ul></li><li><a class="tocitem" href="../../history/">History</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li><a class="is-disabled">Subpackages</a></li><li class="is-active"><a href>QuantumControlBase</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>QuantumControlBase</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/master/docs/generate_api.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="QuantumControlBasePackage"><a class="docs-heading-anchor" href="#QuantumControlBasePackage">QuantumControlBase Package</a><a id="QuantumControlBasePackage-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBasePackage" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><p><span>$\gdef\tgt{\text{tgt}}$</span> <span>$\gdef\tr{\operatorname{tr}}$</span> <span>$\gdef\Re{\operatorname{Re}}$</span> <span>$\gdef\Im{\operatorname{Im}}$</span></p><ul><li><a href="#QuantumControlBase.ControlProblem"><code>QuantumControlBase.ControlProblem</code></a></li><li><a href="#QuantumControlBase.GradGenerator"><code>QuantumControlBase.GradGenerator</code></a></li><li><a href="#QuantumControlBase.GradVector"><code>QuantumControlBase.GradVector</code></a></li><li><a href="#QuantumControlBase.GradgenOperator"><code>QuantumControlBase.GradgenOperator</code></a></li><li><a href="#QuantumControlBase.Objective"><code>QuantumControlBase.Objective</code></a></li><li><a href="#QuantumControlBase.PulseParametrizations.ParametrizedAmplitude"><code>QuantumControlBase.PulseParametrizations.ParametrizedAmplitude</code></a></li><li><a href="#QuantumControlBase.PulseParametrizations.PulseParametrization"><code>QuantumControlBase.PulseParametrizations.PulseParametrization</code></a></li><li><a href="#QuantumControlBase.TestUtils.DummyOptimizationResult"><code>QuantumControlBase.TestUtils.DummyOptimizationResult</code></a></li><li><a href="#QuantumControlBase.TestUtils.QuantumTestLogger"><code>QuantumControlBase.TestUtils.QuantumTestLogger</code></a></li><li><a href="#QuantumControlBase.Functionals.F_re"><code>QuantumControlBase.Functionals.F_re</code></a></li><li><a href="#QuantumControlBase.Functionals.F_sm"><code>QuantumControlBase.Functionals.F_sm</code></a></li><li><a href="#QuantumControlBase.Functionals.F_ss"><code>QuantumControlBase.Functionals.F_ss</code></a></li><li><a href="#QuantumControlBase.Functionals.J_T_re"><code>QuantumControlBase.Functionals.J_T_re</code></a></li><li><a href="#QuantumControlBase.Functionals.J_T_sm"><code>QuantumControlBase.Functionals.J_T_sm</code></a></li><li><a href="#QuantumControlBase.Functionals.J_T_ss"><code>QuantumControlBase.Functionals.J_T_ss</code></a></li><li><a href="#QuantumControlBase.Functionals.J_a_fluence"><code>QuantumControlBase.Functionals.J_a_fluence</code></a></li><li><a href="#QuantumControlBase.Functionals.chi_re!"><code>QuantumControlBase.Functionals.chi_re!</code></a></li><li><a href="#QuantumControlBase.Functionals.chi_sm!"><code>QuantumControlBase.Functionals.chi_sm!</code></a></li><li><a href="#QuantumControlBase.Functionals.chi_ss!"><code>QuantumControlBase.Functionals.chi_ss!</code></a></li><li><a href="#QuantumControlBase.Functionals.f_tau"><code>QuantumControlBase.Functionals.f_tau</code></a></li><li><a href="#QuantumControlBase.Functionals.gate_functional"><code>QuantumControlBase.Functionals.gate_functional</code></a></li><li><a href="#QuantumControlBase.Functionals.grad_J_a_fluence!"><code>QuantumControlBase.Functionals.grad_J_a_fluence!</code></a></li><li><a href="#QuantumControlBase.Functionals.make_chi"><code>QuantumControlBase.Functionals.make_chi</code></a></li><li><a href="#QuantumControlBase.Functionals.make_gate_chi"><code>QuantumControlBase.Functionals.make_gate_chi</code></a></li><li><a href="#QuantumControlBase.Functionals.make_grad_J_a"><code>QuantumControlBase.Functionals.make_grad_J_a</code></a></li><li><a href="#QuantumControlBase.PulseParametrizations.LogisticParametrization"><code>QuantumControlBase.PulseParametrizations.LogisticParametrization</code></a></li><li><a href="#QuantumControlBase.PulseParametrizations.LogisticSqParametrization"><code>QuantumControlBase.PulseParametrizations.LogisticSqParametrization</code></a></li><li><a href="#QuantumControlBase.PulseParametrizations.SquareParametrization"><code>QuantumControlBase.PulseParametrizations.SquareParametrization</code></a></li><li><a href="#QuantumControlBase.PulseParametrizations.TanhParametrization"><code>QuantumControlBase.PulseParametrizations.TanhParametrization</code></a></li><li><a href="#QuantumControlBase.PulseParametrizations.TanhSqParametrization"><code>QuantumControlBase.PulseParametrizations.TanhSqParametrization</code></a></li><li><a href="#QuantumControlBase.TestUtils.dummy_control_problem"><code>QuantumControlBase.TestUtils.dummy_control_problem</code></a></li><li><a href="#QuantumControlBase.TestUtils.generate_coverage_html"><code>QuantumControlBase.TestUtils.generate_coverage_html</code></a></li><li><a href="#QuantumControlBase.TestUtils.optimize_with_dummy_method"><code>QuantumControlBase.TestUtils.optimize_with_dummy_method</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_complex_matrix"><code>QuantumControlBase.TestUtils.random_complex_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_complex_sparse_matrix"><code>QuantumControlBase.TestUtils.random_complex_sparse_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_hermitian_matrix"><code>QuantumControlBase.TestUtils.random_hermitian_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_hermitian_real_matrix"><code>QuantumControlBase.TestUtils.random_hermitian_real_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_hermitian_sparse_matrix"><code>QuantumControlBase.TestUtils.random_hermitian_sparse_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_hermitian_sparse_real_matrix"><code>QuantumControlBase.TestUtils.random_hermitian_sparse_real_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_real_matrix"><code>QuantumControlBase.TestUtils.random_real_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_real_sparse_matrix"><code>QuantumControlBase.TestUtils.random_real_sparse_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_state_vector"><code>QuantumControlBase.TestUtils.random_state_vector</code></a></li><li><a href="#QuantumControlBase.TestUtils.show_coverage"><code>QuantumControlBase.TestUtils.show_coverage</code></a></li><li><a href="#QuantumControlBase.TestUtils.test"><code>QuantumControlBase.TestUtils.test</code></a></li><li><a href="#QuantumControlBase.WeylChamber.D_PE"><code>QuantumControlBase.WeylChamber.D_PE</code></a></li><li><a href="#QuantumControlBase.WeylChamber.canonical_gate"><code>QuantumControlBase.WeylChamber.canonical_gate</code></a></li><li><a href="#QuantumControlBase.WeylChamber.gate_concurrence"><code>QuantumControlBase.WeylChamber.gate_concurrence</code></a></li><li><a href="#QuantumControlBase.WeylChamber.in_weyl_chamber"><code>QuantumControlBase.WeylChamber.in_weyl_chamber</code></a></li><li><a href="#QuantumControlBase.WeylChamber.local_invariants"><code>QuantumControlBase.WeylChamber.local_invariants</code></a></li><li><a href="#QuantumControlBase.WeylChamber.unitarity"><code>QuantumControlBase.WeylChamber.unitarity</code></a></li><li><a href="#QuantumControlBase.WeylChamber.weyl_chamber_coordinates"><code>QuantumControlBase.WeylChamber.weyl_chamber_coordinates</code></a></li><li><a href="#QuantumControlBase.WeylChamber.weyl_chamber_region"><code>QuantumControlBase.WeylChamber.weyl_chamber_region</code></a></li><li><a href="#QuantumControlBase.chain_infohooks"><code>QuantumControlBase.chain_infohooks</code></a></li><li><a href="#QuantumControlBase.get_control_deriv"><code>QuantumControlBase.get_control_deriv</code></a></li><li><a href="#QuantumControlBase.get_control_derivs"><code>QuantumControlBase.get_control_derivs</code></a></li><li><a href="#QuantumControlBase.load_optimization"><code>QuantumControlBase.load_optimization</code></a></li><li><a href="#QuantumControlBase.optimize"><code>QuantumControlBase.optimize</code></a></li><li><a href="#QuantumControlBase.propagate_objective"><code>QuantumControlBase.propagate_objective</code></a></li><li><a href="#QuantumControlBase.propagate_objectives"><code>QuantumControlBase.propagate_objectives</code></a></li><li><a href="#QuantumControlBase.resetgradvec!"><code>QuantumControlBase.resetgradvec!</code></a></li><li><a href="#QuantumControlBase.@optimize_or_load"><code>QuantumControlBase.@optimize_or_load</code></a></li><li><a href="#QuantumControlBase.ConditionalThreads.@threadsif"><code>QuantumControlBase.ConditionalThreads.@threadsif</code></a></li></ul><h2 id="QuantumControlBaseAPI"><a class="docs-heading-anchor" href="#QuantumControlBaseAPI">QuantumControlBase</a><a id="QuantumControlBaseAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBaseAPI" title="Permalink"></a></h2><h3 id="Public"><a class="docs-heading-anchor" href="#Public">Public</a><a id="Public-1"></a><a class="docs-heading-anchor-permalink" href="#Public" title="Permalink"></a></h3><ul><li><a href="#QuantumControlBase.@optimize_or_load"><code>@optimize_or_load</code></a></li><li><a href="#QuantumControlBase.ControlProblem"><code>ControlProblem</code></a></li><li><a href="#QuantumControlBase.Objective"><code>Objective</code></a></li><li><a href="#QuantumControlBase.chain_infohooks"><code>chain_infohooks</code></a></li><li><a href="#QuantumControlBase.load_optimization"><code>load_optimization</code></a></li><li><a href="#QuantumControlBase.optimize"><code>optimize</code></a></li><li><a href="#QuantumControlBase.propagate_objective"><code>propagate_objective</code></a></li><li><a href="#QuantumControlBase.propagate_objectives"><code>propagate_objectives</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.@optimize_or_load" href="#QuantumControlBase.@optimize_or_load"><code>QuantumControlBase.@optimize_or_load</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Run <a href="#QuantumControlBase.optimize"><code>optimize</code></a> and store the result, or load the result if it exists.</p><pre><code class="language-julia hljs">result = @optimize_or_load(
    file,
    problem;
    method,
    suffix=&quot;jld2&quot;,
    tag=DrWatson.readenv(&quot;DRWATSON_TAG&quot;, true),
    gitpath=DrWatson.projectdir(),
    storepatch::Bool=DrWatson.readenv(&quot;DRWATSON_STOREPATCH&quot;, false),
    force=false,
    verbose=true,
    wsave_kwargs=Dict(),
    metadata=nothing,
    kwargs...
)</code></pre><p>runs <code>result = optimize(problem; method, kwargs...)</code> and stores <code>result</code> in <code>file</code>. Note that the <code>method</code> keyword argument is mandatory. In addition to the <code>result</code>, the data in the output <code>file</code> may also contain some metadata, e.g. (automatically) &quot;gitcommit&quot; containing the git commit hash of the project that produced the file, and &quot;script&quot; with the file name and line number where <code>@optimize_or_load</code> was called, see <a href="#QuantumControlBase.load_optimization"><code>load_optimization</code></a>. If <code>metadata</code> is given as a dict on input, the data it contains will be included in the output file.</p><p>If <code>file</code> already exists (and <code>force=false</code>), load the <code>result</code> from that file instead of running the optimization.</p><p>The <code>@optimize_or_load</code> macro is intended to integrate well with the <a href="https://juliadynamics.github.io/DrWatson.jl/stable/"><code>DrWatson</code></a> framework for scientific projects and utilizes several configuration options and utility functions from <code>DrWatson</code>, see below. Note that even though <code>DrWatson</code> is recomended, you are not <em>required</em> to use if for your projects in order to use <code>@optimize_or_load</code> or any other part of <code>QuantumControl</code>.</p><p><strong>I/O Keywords</strong></p><p>The following keyword arguments determine how the <code>result</code> is stored:</p><ul><li><code>suffix</code>. File extension of <code>file</code>, determining the output data format (see <a href="https://juliadynamics.github.io/DrWatson.jl/stable/save/">DrWatson Saving Tools</a>). If <code>file</code> does not end with the given extension, it will be appended.</li><li><code>tag</code>: Whether to record the current &quot;gitcommit&quot; as metadata alongside the optimization result, via <a href="https://juliadynamics.github.io/DrWatson.jl/stable/save/#DrWatson.tagsave"><code>DrWatson.tagsave</code></a>. If not given explicitly, determine automatically from <code>suffix</code>.</li><li><code>gitpath</code>, <code>storepatch</code>: Passed to <code>DrWatson.tagsave</code> if <code>tag</code> is <code>true</code>.</li><li><code>force</code>: If <code>true</code>, run and store the optimization regardless of whether <code>file</code> already exists.</li><li><code>verbose</code>: If <code>true</code>, print info about the process</li><li><code>wsave_kwargs</code>: Additional keyword arguments to pass to <a href="https://juliadynamics.github.io/DrWatson.jl/stable/save/#Saving-Tools-1"><code>DrWatson.wsave</code></a>, e.g., to enable compression</li></ul><p>All other keyword arguments are passed directly to <a href="#QuantumControlBase.optimize"><code>optimize</code></a>.</p><p><strong>Related Functions</strong></p><ul><li><a href="https://juliadynamics.github.io/DrWatson.jl/stable/save/#DrWatson.@produce_or_load"><code>DrWatson.@produce_or_load</code></a>: The lower-level backend implementing the functionality of <code>@optimize_or_load</code>.</li><li><a href="#QuantumControlBase.load_optimization"><code>load_optimization</code></a>: Function to load a file produced by <code>@optimize_or_load</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.ControlProblem" href="#QuantumControlBase.ControlProblem"><code>QuantumControlBase.ControlProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A full control problem with multiple objectives.</p><pre><code class="language-julia hljs">ControlProblem(;
   objectives,
   tlist,
   kwargs...
)</code></pre><p>Note that the control problem can only be instantiated via keyword arguments.</p><p>The <code>objectives</code> are a list of <a href="#QuantumControlBase.Objective"><code>Objective</code></a> instances, each defining an initial state and a dynamical generator for the evolution of that state. Usually, the objective will also include a target state (see <a href="#QuantumControlBase.Objective"><code>Objective</code></a>) and possibly a weight.</p><p>The <code>tlist</code> is the time grid on which the time evolution of the initial states of each objective should be propagated.</p><p>The remaining <code>kwargs</code> are keyword arguments that are passed directly to the optimal control method. These typically include e.g. the optimization functional.</p><p>The control problem is solved by finding a set of controls that simultaneously fulfill all objectives.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Objective" href="#QuantumControlBase.Objective"><code>QuantumControlBase.Objective</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Optimization objective.</p><pre><code class="language-julia hljs">Objective(;
    initial_state,
    generator,
    target_state=nothing,
    weight=1.0,
    kwargs...
)</code></pre><p>describes an optimization objective that is tracked by the time evolution of the given <code>initial_state</code> under the given <code>generator</code>, e.g., a time-dependent Hamiltonian or Liouvillian. Each objective represents a single propagated state on which an optimization functional may depend.</p><p>The most common control problems in quantum control (state-to-state, gate optimization) require that the <code>initial_state</code> evolves into a <code>target_state</code>, which should be given as a keyword argument.</p><p>An optimization functional usually depends on <em>multiple</em> forward-propagated states (i.e., multiple <code>objectives</code>). Sometimes, it is useful to weight the contributions of different <code>objectives</code> relative to each other, see, e.g., Goerz <em>et al</em>., New J. Phys. 16, 055012 (2014). To this end, a <code>weight</code> can be attached to each <code>Objective</code> as an optional keyword argument.</p><p>Any other keyword arguments are available to a custom functional as properties of the <code>Objective</code> .</p><p>Note that the <code>Objective</code> can only be instantiated via keyword arguments, with <code>initial_state</code> and <code>generator</code> being the only two mandatory keyword arguments.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.chain_infohooks" href="#QuantumControlBase.chain_infohooks"><code>QuantumControlBase.chain_infohooks</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Combine multiple <code>info_hook</code> functions.</p><pre><code class="language-julia hljs">chain_infohooks(funcs...)</code></pre><p>combines <code>funcs</code> into a single Function that can be passes as <code>info_hook</code> to <a href="#QuantumControlBase.ControlProblem"><code>ControlProblem</code></a> or any <code>optimize</code>-function.</p><p>Each function in <code>func</code> must be a suitable <code>info_hook</code> by itself. This means that it should receive the optimization workspace object as its first positional parameter, then positional parameters specific to the optimization method, and then an arbitrary number of data parameters. It must return either <code>nothing</code> or a tuple of &quot;info&quot; objects (which will end up in the <code>records</code> field of the optimization result).</p><p>When chaining infohooks, the <code>funcs</code> will be called in series, and the &quot;info&quot; objects will be accumulated into a single result tuple. The combined results from previous <code>funcs</code> will be given to the subsequent <code>funcs</code> as data parameters. This allows for the infohooks in the chain to communicate.</p><p>The chain will return the final combined result tuple, or <code>nothing</code> if all <code>funcs</code> return <code>nothing</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.load_optimization" href="#QuantumControlBase.load_optimization"><code>QuantumControlBase.load_optimization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Load a previously stored optimization.</p><pre><code class="language-julia hljs">result = load_optimization(file; verbose=true, kwargs...)</code></pre><p>recovers a <code>result</code> previously stored by <a href="#QuantumControlBase.@optimize_or_load"><code>@optimize_or_load</code></a>.</p><pre><code class="language-julia hljs">result, metadata = load_optimization(file; return_metadata=true, kwargs...)</code></pre><p>also obtains a metadata dict containing e.g., &quot;gitcommit&quot; or &quot;script&quot; depending on the options to <a href="#QuantumControlBase.@optimize_or_load"><code>@optimize_or_load</code></a>.</p><p>Calling <code>load_optimization</code> with <code>verbose=true</code> (default) will show the metadata after loading the file.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.optimize" href="#QuantumControlBase.optimize"><code>QuantumControlBase.optimize</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Optimize a quantum control problem.</p><pre><code class="language-julia hljs">opt_result = optimize(problem; method=&lt;method&gt;, kwargs...)</code></pre><p>optimizes towards a solution of given <a href="#QuantumControlBase.ControlProblem"><code>problem</code></a> with the given optimization <code>method</code>. Any keyword argument temporarily overrides the corresponding keyword argument in <code>problem</code>.</p></div></section><section><div><pre><code class="language-julia hljs">opt_result = optimize(problem; method=:krotov, kwargs...)</code></pre><p>optimizes <a href="#QuantumControlBase.ControlProblem"><code>problem</code></a> using Krotov&#39;s method, see <a href="../krotov/#Krotov.optimize_krotov"><code>Krotov.optimize_krotov</code></a>.</p></div></section><section><div><pre><code class="language-julia hljs">opt_result = optimize(problem; method=:GRAPE, kwargs...)</code></pre><p>optimizes <a href="#QuantumControlBase.ControlProblem"><code>problem</code></a> using GRadident Ascent Pulse Engineering (GRAPE), see <a href="../grape/#GRAPE.optimize_grape"><code>GRAPE.optimize_grape</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.propagate_objective" href="#QuantumControlBase.propagate_objective"><code>QuantumControlBase.propagate_objective</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Propagate with the dynamical generator of a control objective.</p><pre><code class="language-julia hljs">propagate_objective(obj, tlist; method=:auto, initial_state=obj.initial_state,
                    kwargs...)</code></pre><p>propagates <code>initial_state</code> under the dynamics described by <code>obj.generator</code>.</p><p>The optional dict <code>control_map</code> may be given to replace the controls in <code>obj.generator</code> (as obtained by <a href="../quantum_propagators/#QuantumPropagators.Controls.get_controls"><code>get_controls</code></a>) with custom functions or vectors, e.g. with the controls resulting from optimization, see also <a href="../quantum_propagators/#QuantumPropagators.Controls.substitute"><code>substitute</code></a>.</p><p>If <code>obj</code> has a property/field <code>prop_method</code> or <code>fw_prop_method</code>, its value will be used as the default for <code>method</code> instead of :auto. An explicit keyword argument for <code>method</code> always overrides the default.</p><p>All other <code>kwargs</code> are forwarded to the underlying <a href="../quantum_propagators/#QuantumPropagators.propagate"><code>QuantumPropagators.propagate</code></a> method for <code>obj.initial_state</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.propagate_objectives" href="#QuantumControlBase.propagate_objectives"><code>QuantumControlBase.propagate_objectives</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Propagate multiple objectives in parallel.</p><pre><code class="language-julia hljs">result = propagate_objectives(objectives, tlist; use_threads=true, kwargs...)</code></pre><p>runs <a href="#QuantumControlBase.propagate_objective"><code>propagate_objective</code></a> for every objective in <code>objectives</code>, collects and returns a vector of results. The propagation happens in parallel if <code>use_threads=true</code> (default). All keyword parameters are passed to <a href="#QuantumControlBase.propagate_objective"><code>propagate_objective</code></a>, except that if <code>initial_state</code> is given, it must be a vector of initial states, one for each objective. Likewise, to pass pre-allocated storage arrays to <code>storage</code>, a vector of storage arrays must be passed. A simple <code>storage=true</code> will still work to return a vector of storage results.</p></div></section></article><h3 id="Private"><a class="docs-heading-anchor" href="#Private">Private</a><a id="Private-1"></a><a class="docs-heading-anchor-permalink" href="#Private" title="Permalink"></a></h3><ul><li><a href="#QuantumControlBase.GradgenOperator"><code>GradgenOperator</code></a></li><li><a href="#QuantumControlBase.get_control_derivs"><code>get_control_derivs</code></a></li><li><a href="#QuantumControlBase.GradVector"><code>GradVector</code></a></li><li><a href="#QuantumControlBase.get_control_deriv"><code>get_control_deriv</code></a></li><li><a href="#QuantumControlBase.resetgradvec!"><code>resetgradvec!</code></a></li><li><a href="#QuantumControlBase.GradGenerator"><code>GradGenerator</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.GradgenOperator" href="#QuantumControlBase.GradgenOperator"><code>QuantumControlBase.GradgenOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Static generator for the dynamic gradient.</p><pre><code class="language-julia hljs">G::GradgenOperator = evaluate(gradgen::GradGenerator; vals_dict)</code></pre><p>is the result of plugging in specific values for all controls in a <a href="#QuantumControlBase.GradGenerator"><code>GradGenerator</code></a>. See <a href="../quantum_propagators/#QuantumPropagators.Controls.evaluate"><code>evaluate</code></a> and <a href="../quantum_propagators/#QuantumPropagators.Controls.evaluate!"><code>evaluate!</code></a>.</p><p>The resulting object can be multiplied directly with a <a href="#QuantumControlBase.GradVector"><code>GradVector</code></a>, e.g., in the process of evaluating a piecewise-constant time propagation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.get_control_derivs" href="#QuantumControlBase.get_control_derivs"><code>QuantumControlBase.get_control_derivs</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get a vector of the derivatives of <code>generator</code> w.r.t. each control.</p><pre><code class="language-julia hljs">get_control_derivs(generator, controls)</code></pre><p>return as vector containing the derivative of <code>generator</code> with respect to each control in <code>controls</code>. The elements of the vector are either <code>nothing</code> if <code>generator</code> does not depend on that particular control, or a function <code>μ(α)</code> that evaluates the derivative for a particular value of the control, see <a href="#QuantumControlBase.get_control_deriv"><code>get_control_deriv</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.GradVector" href="#QuantumControlBase.GradVector"><code>QuantumControlBase.GradVector</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Extended state-vector for the dynamic gradient.</p><pre><code class="language-julia hljs">Ψ̃ = GradVector(Ψ, num_controls)</code></pre><p>for an initial state <code>Ψ</code> and <code>num_controls</code> control fields.</p><p>The <code>GradVector</code> conceptually corresponds to a direct-sum (block) column-vector <span>$Ψ̃ = (|Ψ̃₁⟩, |Ψ̃₂⟩, … |Ψ̃ₙ⟩, |Ψ⟩)^T$</span>, where <span>$n$</span> is <code>num_controls</code>. With a matching <span>$G̃$</span> as in the documentation of <a href="#QuantumControlBase.GradGenerator"><code>GradGenerator</code></a>, we have</p><p class="math-container">\[G̃ Ψ̃ = \begin{pmatrix}
Ĥ |Ψ̃₁⟩ + Ĥ₁|Ψ⟩ \\
\vdots \\
Ĥ |Ψ̃ₙ⟩ + Ĥₙ|Ψ⟩ \\
Ĥ |Ψ⟩
\end{pmatrix}\]</p><p>and</p><p class="math-container">\[e^{-i G̃ dt} \begin{pmatrix} 0 \\ \vdots \\ 0 \\ |Ψ⟩ \end{pmatrix}
= \begin{pmatrix}
\frac{∂}{∂ϵ₁} e^{-i Ĥ dt} |Ψ⟩ \\
\vdots \\
\frac{∂}{∂ϵₙ} e^{-i Ĥ dt} |Ψ⟩ \\
e^{-i Ĥ dt} |Ψ⟩
\end{pmatrix}.\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.get_control_deriv" href="#QuantumControlBase.get_control_deriv"><code>QuantumControlBase.get_control_deriv</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get the derivative of the generator <span>$G$</span> w.r.t. the control <span>$ϵ(t)$</span>.</p><pre><code class="language-julia hljs">μ  = get_control_deriv(generator, control)</code></pre><p>returns <code>nothing</code> if the <code>generator</code> (Hamiltonian or Liouvillian) does not depend on <code>control</code>, or generator</p><p class="math-container">\[μ = \frac{∂G}{∂ϵ(t)}\]</p><p>otherwise. For linear control terms, <code>μ</code> will be a static operator, e.g. an <code>AbstractMatrix</code> or an <a href="../quantum_propagators/#QuantumPropagators.Generators.Operator"><code>Operator</code></a>. For non-linear controls, <code>μ</code> will be time-dependent, e.g. a <a href="../quantum_propagators/#QuantumPropagators.Generators.Generator"><code>Generator</code></a>. In either case, <a href="../quantum_propagators/#QuantumPropagators.Controls.evaluate"><code>evaluate</code></a> should be used to evaluate <code>μ</code> into a constant operator for particular values of the controls and a particular point in time.</p><p>For constant generators, e.g. an <a href="../quantum_propagators/#QuantumPropagators.Generators.Operator"><code>Operator</code></a>, the result is always <code>nothing</code>.</p></div></section><section><div><pre><code class="language-julia hljs">a = get_control_deriv(ampl, control)</code></pre><p>returns the derivative <span>$∂a_l(t)/∂ϵ_{l&#39;}(t)$</span> of the given amplitude <span>$a_l(\{ϵ_{l&#39;&#39;}(t)\}, t)$</span> with respect to the given control <span>$ϵ_{l&#39;}(t)$</span>. For &quot;trivial&quot; amplitudes, where <span>$a_l(t) ≡ ϵ_l(t)$</span>, the result with be either <code>1.0</code> or <code>0.0</code> (depending on whether <code>ampl ≡ control</code>). For non-trivial amplitudes, the result may be another amplitude that depends on the controls and potentially on time, but can be evaluated to a constant with <a href="../quantum_propagators/#QuantumPropagators.Controls.evaluate"><code>evaluate</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.resetgradvec!" href="#QuantumControlBase.resetgradvec!"><code>QuantumControlBase.resetgradvec!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Reset the given gradient vector for a new gradient evaluation.</p><pre><code class="language-julia hljs">resetgradvec!(Ψ̃::GradVector)</code></pre><p>zeroes out <code>Ψ̃.grad_states</code> but leaves <code>Ψ̃.state</code> unaffected.</p><pre><code class="language-julia hljs">resetgradvec!(Ψ̃::GradVector, Ψ)</code></pre><p>additionally sets <code>Ψ̃.state</code> to <code>Ψ</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.GradGenerator" href="#QuantumControlBase.GradGenerator"><code>QuantumControlBase.GradGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Extended generator for the standard dynamic gradient.</p><pre><code class="language-julia hljs">G̃ = GradGenerator(G)</code></pre><p>contains the original time-dependent generator <code>G</code> (a Hamiltonian or Liouvillian) in <code>G̃.G</code>, a vector of control derivatives <span>$∂G/∂ϵₗ(t)$</span> in <code>G̃.control_derivs</code>, and the controls in <code>G̃.controls</code>.</p><p>For a generator <span>$G = Ĥ(t) = Ĥ₀ + ϵ₁(t) Ĥ₁ + … +  ϵₙ(t) Ĥₙ$</span>, this extended generator encodes the block-matrix</p><p class="math-container">\[G̃ = \begin{pmatrix}
         Ĥ(t)  &amp;  0    &amp;  \dots   &amp;  0     &amp;  Ĥ₁     \\
         0     &amp;  Ĥ(t) &amp;  \dots   &amp;  0     &amp;  Ĥ₂     \\
    \vdots     &amp;       &amp;  \ddots  &amp;        &amp;  \vdots \\
         0     &amp;  0    &amp;  \dots   &amp;  Ĥ(t)  &amp;  Ĥₙ     \\
         0     &amp;  0    &amp;  \dots   &amp;  0     &amp;  Ĥ(t)
\end{pmatrix}\]</p><p>Note that the <span>$∂G/∂ϵₗ(t)$</span> (<span>$Ĥₗ$</span> in the above example) may be time-dependent, to account for the possibility of non-linear control terms, see <a href="#QuantumControlBase.get_control_deriv"><code>get_control_deriv</code></a>.</p></div></section></article><h2 id="QuantumControlBaseConditionalThreadsAPI"><a class="docs-heading-anchor" href="#QuantumControlBaseConditionalThreadsAPI">QuantumControlBase.ConditionalThreads</a><a id="QuantumControlBaseConditionalThreadsAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBaseConditionalThreadsAPI" title="Permalink"></a></h2><h3 id="Private-2"><a class="docs-heading-anchor" href="#Private-2">Private</a><a class="docs-heading-anchor-permalink" href="#Private-2" title="Permalink"></a></h3><ul><li><a href="#QuantumControlBase.ConditionalThreads.@threadsif"><code>@threadsif</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.ConditionalThreads.@threadsif" href="#QuantumControlBase.ConditionalThreads.@threadsif"><code>QuantumControlBase.ConditionalThreads.@threadsif</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Conditionally apply multi-threading to <code>for</code> loops.</p><p>This is a variation on <code>Base.Threads.@threads</code> that adds a run-time boolean flag to enable or disable threading. It is intended for <em>internal use</em> in packages building on <code>QuantumControlBase</code>.</p><p>Usage:</p><pre><code class="language-julia hljs">using QuantumControlBase.ConditionalThreads: @threadsif

function optimize(objectives; use_threads=true)
    @threadsif use_threads for k = 1:length(objectives)
    # ...
    end
end</code></pre></div></section></article><h2 id="QuantumControlBaseFunctionalsAPI"><a class="docs-heading-anchor" href="#QuantumControlBaseFunctionalsAPI">QuantumControlBase.Functionals</a><a id="QuantumControlBaseFunctionalsAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBaseFunctionalsAPI" title="Permalink"></a></h2><h3 id="Public-2"><a class="docs-heading-anchor" href="#Public-2">Public</a><a class="docs-heading-anchor-permalink" href="#Public-2" title="Permalink"></a></h3><ul><li><a href="#QuantumControlBase.Functionals.J_T_re"><code>J_T_re</code></a></li><li><a href="#QuantumControlBase.Functionals.J_T_sm"><code>J_T_sm</code></a></li><li><a href="#QuantumControlBase.Functionals.J_T_ss"><code>J_T_ss</code></a></li><li><a href="#QuantumControlBase.Functionals.J_a_fluence"><code>J_a_fluence</code></a></li><li><a href="#QuantumControlBase.Functionals.gate_functional"><code>gate_functional</code></a></li><li><a href="#QuantumControlBase.Functionals.make_chi"><code>make_chi</code></a></li><li><a href="#QuantumControlBase.Functionals.make_gate_chi"><code>make_gate_chi</code></a></li><li><a href="#QuantumControlBase.Functionals.make_grad_J_a"><code>make_grad_J_a</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.J_T_re" href="#QuantumControlBase.Functionals.J_T_re"><code>QuantumControlBase.Functionals.J_T_re</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Real-part functional.</p><pre><code class="language-julia hljs">J_T_re(ϕ, objectives; τ=nothing)</code></pre><p>calculates</p><p class="math-container">\[J_{T,\text{re}} = 1 - F_{\text{re}} \quad\in \begin{cases}
    [0, 2] &amp; \text{in Hilbert space} \\
    [0, 1] &amp; \text{in Liouville space.}
\end{cases}\]</p><p>All arguments are passed to <a href="#QuantumControlBase.Functionals.f_tau"><code>f_tau</code></a> while evaluating <span>$F_{\text{re}}$</span> in <a href="#QuantumControlBase.Functionals.F_re"><code>F_re</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.J_T_sm" href="#QuantumControlBase.Functionals.J_T_sm"><code>QuantumControlBase.Functionals.J_T_sm</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Square-modulus functional.</p><pre><code class="language-julia hljs">J_T_sm(ϕ, objectives; τ=nothing)</code></pre><p>calculates</p><p class="math-container">\[J_{T,\text{sm}} = 1 - F_{\text{sm}} \quad\in [0, 1].\]</p><p>All arguments are passed to <a href="#QuantumControlBase.Functionals.f_tau"><code>f_tau</code></a> while evaluating <span>$F_{\text{sm}}$</span> in <a href="#QuantumControlBase.Functionals.F_sm"><code>F_sm</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.J_T_ss" href="#QuantumControlBase.Functionals.J_T_ss"><code>QuantumControlBase.Functionals.J_T_ss</code></a> — <span class="docstring-category">Function</span></header><section><div><p>State-to-state phase-insensitive functional.</p><pre><code class="language-julia hljs">J_T_ss(ϕ, objectives; τ=nothing)</code></pre><p>calculates</p><p class="math-container">\[J_{T,\text{ss}} = 1 - F_{\text{ss}} \in [0, 1].\]</p><p>All arguments are passed to <a href="#QuantumControlBase.Functionals.F_ss"><code>F_ss</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.J_a_fluence" href="#QuantumControlBase.Functionals.J_a_fluence"><code>QuantumControlBase.Functionals.J_a_fluence</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Running cost for the pulse fluence.</p><pre><code class="language-julia hljs">J_a = J_a_fluence(pulsevals, tlist)</code></pre><p>calculates</p><p class="math-container">\[J_a = \sum_l \int_0^T |ϵ_l(t)|^2 dt = \left(\sum_{ln} |ϵ_{ln}|^2 \right) dt\]</p><p>where <span>$ϵ_{ln}$</span> are the values in the (vectorized) <code>pulsevals</code>, <code>n</code> is the index of the intervals of the time grid, and <span>$dt$</span> is the time step, taken from the first time interval of <code>tlist</code> and assumed to be uniform.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.gate_functional" href="#QuantumControlBase.Functionals.gate_functional"><code>QuantumControlBase.Functionals.gate_functional</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Convert a functional from acting on a gate to acting on propagated states.</p><pre><code class="nohighlight hljs">J_T = gate_functional(J_T_U; kwargs...)</code></pre><p>constructs a functional <code>J_T</code> that meets the requirements for for Krotov/GRAPE and <a href="#QuantumControlBase.Functionals.make_chi"><code>make_chi</code></a>. That is, the output <code>J_T</code> takes positional positional arguments <code>ϕ</code> and <code>objectives</code>. The input functional <code>J_T_U</code> is assumed to have the signature <code>J_T_U(U; kwargs...)</code> where <code>U</code> is a matrix with elements <span>$U_{ij} = ⟨Ψ_i|ϕ_j⟩$</span>, where <span>$|Ψ_i⟩$</span> is the <code>initial_state</code> of the i&#39;th <code>objectives</code> (assumed to be the i&#39;th canonical basis state) and <span>$|ϕ_j⟩$</span> is the result of forward-propagating <span>$|Ψ_j⟩$</span>. That is, <code>U</code> is the projection of the time evolution operator into the subspace defined by the basis in the <code>initial_states</code> of the  <code>objectives</code>.</p><p><strong>See also</strong></p><ul><li><a href="#QuantumControlBase.Functionals.make_gate_chi"><code>make_gate_chi</code></a> — create a corresponding <code>chi</code> function that acts more efficiently than the general <a href="#QuantumControlBase.Functionals.make_chi"><code>make_chi</code></a>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.make_chi" href="#QuantumControlBase.Functionals.make_chi"><code>QuantumControlBase.Functionals.make_chi</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return a function that evaluates <span>$|χ_k⟩ = -∂J_T/∂⟨ϕ_k|$</span>.</p><pre><code class="language-julia hljs">chi! = make_chi(
    J_T,
    objectives;
    force_zygote=false,
    via=(any(isnothing(obj.target_state) for obj in objectives) ? :phi : :tau),
    use_finite_differences=false
)</code></pre><p>creates a function <code>chi!(χ, ϕ, objectives; τ)</code> that sets the k&#39;th element of <code>χ</code> to <span>$|χ_k⟩ = -∂J_T/∂⟨ϕ_k|$</span>, where <span>$|ϕ_k⟩$</span> is the k&#39;th element of <code>ϕ</code>. These are the states used as the boundary condition for the backward propagation propagation in Krotov&#39;s method and GRAPE. Each <span>$|χₖ⟩$</span> is defined as a matrix calculus <a href="https://www.ekinakyurek.me/complex-derivatives-wirtinger/">Wirtinger derivative</a>,</p><p class="math-container">\[|χ_k(T)⟩ = -\frac{∂J_T}{∂⟨ϕ_k|} = -\frac{1}{2} ∇_{ϕ_k} J_T\,;\qquad
∇_{ϕ_k} J_T ≡ \frac{∂J_T}{\Re[ϕ_k]} + i \frac{∂J_T}{\Im[ϕ_k]}\,.\]</p><p>The function <code>J_T</code> must take a vector of states <code>ϕ</code> and a vector of <code>objectives</code> as positional parameters, and a vector <code>τ</code> as a keyword argument, see e.g. <a href="#QuantumControlBase.Functionals.J_T_sm"><code>J_T_sm</code></a>. If all objectives define a <code>target_state</code>, then <code>τ</code> will be the overlap of the states <code>ϕ</code> with those target states. The functional <code>J_T</code> may or may not use those overlaps.  Likewise, the resulting <code>chi!</code> may or may not use the keyword parameter <code>τ</code>.</p><p>For functionals where <span>$-∂J_T/∂⟨ϕ_k|$</span> is known analytically, that analytic derivative will be returned, e.g.,</p><ul><li><a href="#QuantumControlBase.Functionals.J_T_sm"><code>J_T_sm</code></a> → <a href="#QuantumControlBase.Functionals.chi_sm!"><code>chi_sm!</code></a>,</li><li><a href="#QuantumControlBase.Functionals.J_T_re"><code>J_T_re</code></a> → <a href="#QuantumControlBase.Functionals.chi_re!"><code>chi_re!</code></a>,</li><li><a href="#QuantumControlBase.Functionals.J_T_ss"><code>J_T_ss</code></a> → <a href="#QuantumControlBase.Functionals.chi_ss!"><code>chi_ss!</code></a>.</li></ul><p>Otherwise, or if <code>force_zygote=true</code> or <code>use_finite_differences=true</code>, the derivative to calculate <span>$|χ_k⟩$</span> will be evaluated automatically, via automatic differentiation with Zygote, or via finite differences (which primarily serves for testing the Zygote gradient).</p><p>When evaluating <span>$|χ_k⟩$</span> automatically, if <code>via=:phi</code> is given , <span>$|χ_k(T)⟩$</span> is calculated directly as defined a above from the gradient with respect to the states <span>$\{|ϕ_k(T)⟩\}$</span>. The resulting function <code>chi!</code> ignores any passed <code>τ</code> keyword argument.</p><p>If <code>via=:tau</code> is given instead, the functional <span>$J_T$</span> is considered a function of overlaps <span>$τ_k = ⟨ϕ_k^\tgt|ϕ_k(T)⟩$</span>. This requires that all <code>objectives</code> define a <code>target_state</code> and that <code>J_T</code> calculates the value of the functional solely based on the values of <code>τ</code> passed as a keyword argument.  With only the complex conjugate <span>$τ̄_k = ⟨ϕ_k(T)|ϕ_k^\tgt⟩$</span> having an explicit dependency on <span>$⟨ϕ_k(T)|$</span>,  the chain rule in this case is</p><p class="math-container">\[|χ_k(T)⟩
= -\frac{∂J_T}{∂⟨ϕ_k|}
= -\left(
    \frac{∂J_T}{∂τ̄_k}
    \frac{∂τ̄_k}{∂⟨ϕ_k|}
  \right)
= - \frac{1}{2} (∇_{τ_k} J_T) |ϕ_k^\tgt⟩\,.\]</p><p>Again, we have used the definition of the Wirtinger derivatives,</p><p class="math-container">\[\begin{align*}
    \frac{∂J_T}{∂τ_k}
    &amp;≡ \frac{1}{2}\left(
        \frac{∂ J_T}{∂ \Re[τ_k]}
        - i \frac{∂ J_T}{∂ \Im[τ_k]}
    \right)\,,\\
    \frac{∂J_T}{∂τ̄_k}
    &amp;≡ \frac{1}{2}\left(
        \frac{∂ J_T}{∂ \Re[τ_k]}
        + i \frac{∂ J_T}{∂ \Im[τ_k]}
    \right)\,,
\end{align*}\]</p><p>and the definition of the Zygote gradient with respect to a complex scalar,</p><p class="math-container">\[∇_{τ_k} J_T = \left(
    \frac{∂ J_T}{∂ \Re[τ_k]}
    + i \frac{∂ J_T}{∂ \Im[τ_k]}
\right)\,.\]</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In order to extend <code>make_chi</code> with an analytic implementation for a new <code>J_T</code> function, define a new method <code>make_analytic_chi</code> like so:</p><pre><code class="language-julia hljs">make_analytic_chi(::typeof(J_T_sm), objectives) = chi_sm!</code></pre><p>which links <code>make_chi</code> for <a href="#QuantumControlBase.Functionals.J_T_sm"><code>J_T_sm</code></a> to <a href="#QuantumControlBase.Functionals.chi_sm!"><code>chi_sm!</code></a>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Zygote is notorious for being buggy (silently returning incorrect gradients). Always test automatic derivatives against finite differences and/or other automatic differentiation frameworks.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.make_gate_chi" href="#QuantumControlBase.Functionals.make_gate_chi"><code>QuantumControlBase.Functionals.make_gate_chi</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return a function to evaluate <span>$|χ_k⟩ = -∂J_T(Û)/∂⟨ϕ_k|$</span> via the chain rule.</p><pre><code class="language-julia hljs">chi! = make_gate_chi(J_T_U, objectives; use_finite_differences=false, kwargs...)</code></pre><p>returns a function equivalent to</p><pre><code class="language-julia hljs">chi! = make_chi(gate_functional(J_T_U; kwargs...), objectives)</code></pre><p class="math-container">\[\begin{split}
    |χ_k⟩
    &amp;= -\frac{∂}{∂⟨ϕ_k|} J_T \\
    &amp;= - \frac{1}{2} \sum_i (∇_U J_T)_{ik} \frac{∂ U_{ik}}{∂⟨ϕ_k|} \\
    &amp;= - \frac{1}{2} \sum_i (∇_U J_T)_{ik} |Ψ_i⟩
\end{split}\]</p><p>where <span>$|Ψ_i⟩$</span> is the basis state stored as the <code>initial_state</code> of the i&#39;th <code>objective</code>, see <a href="#QuantumControlBase.Functionals.gate_functional"><code>gate_functional</code></a>.</p><p>The gradient <span>$∇_U J_T$</span> is obtained via automatic differentiation, or via finite differences if <code>use_finite_differences=true</code>.</p><p>Compared to the more general <a href="#QuantumControlBase.Functionals.make_chi"><code>make_chi</code></a>, <code>make_gate_chi</code> will generally have a slightly smaller numerical overhead, as it pushes the use of automatic differentiation down by one level.</p><p>With <code>use_finite_differences=true</code>, this routine serves to test and debug gradients for gate functionals obtained by automatic differentiation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.make_grad_J_a" href="#QuantumControlBase.Functionals.make_grad_J_a"><code>QuantumControlBase.Functionals.make_grad_J_a</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return a function to evaluate <span>$∂J_a/∂ϵ_{ln}$</span> for a pulse value running cost.</p><pre><code class="language-julia hljs">grad_J_a! = make_grad_J_a(
    J_a,
    tlist;
    force_zygote=false,
    use_finite_differences=false
)</code></pre><p>returns a function so that <code>grad_J_a!(∇J_a, pulsevals, tlist)</code> sets <span>$∂J_a/∂ϵ_{ln}$</span> as the elements of the (vectorized) <code>∇J_a</code>. The function <code>J_a</code> must have the interface <code>J_a(pulsevals, tlist)</code>, see, e.g., <a href="#QuantumControlBase.Functionals.J_a_fluence"><code>J_a_fluence</code></a>.</p><p>If <code>force_zygote=true</code>, automatic differentiation with Zygote will be used to calculate the derivative.</p><p>If <code>use_finite_differences=true</code>, the derivative will be calculated via finite differences. This may be used to verify Zygote gradients.</p><p>By default, for functionals <code>J_a</code> that have a known analytic derivative, that analytic derivative will be used. For unknown functions, the derivative will be calculated via Zygote.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In order to extend <code>make_grad_J_a</code> with an analytic implementation for a new <code>J_a</code> function, define a new method <code>make_analytic_grad_J_a</code> like so:</p><pre><code class="language-julia hljs">make_analytic_grad_J_a(::typeof(J_a_fluence), tlist) = grad_J_a_fluence!</code></pre><p>which links <code>make_grad_J_a</code> for <a href="#QuantumControlBase.Functionals.J_a_fluence"><code>J_a_fluence</code></a> to <a href="#QuantumControlBase.Functionals.grad_J_a_fluence!"><code>grad_J_a_fluence!</code></a>.</p></div></div></div></section></article><h3 id="Private-3"><a class="docs-heading-anchor" href="#Private-3">Private</a><a class="docs-heading-anchor-permalink" href="#Private-3" title="Permalink"></a></h3><ul><li><a href="#QuantumControlBase.Functionals.grad_J_a_fluence!"><code>grad_J_a_fluence!</code></a></li><li><a href="#QuantumControlBase.Functionals.F_sm"><code>F_sm</code></a></li><li><a href="#QuantumControlBase.Functionals.chi_sm!"><code>chi_sm!</code></a></li><li><a href="#QuantumControlBase.Functionals.F_re"><code>F_re</code></a></li><li><a href="#QuantumControlBase.Functionals.F_ss"><code>F_ss</code></a></li><li><a href="#QuantumControlBase.Functionals.f_tau"><code>f_tau</code></a></li><li><a href="#QuantumControlBase.Functionals.chi_re!"><code>chi_re!</code></a></li><li><a href="#QuantumControlBase.Functionals.chi_ss!"><code>chi_ss!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.grad_J_a_fluence!" href="#QuantumControlBase.Functionals.grad_J_a_fluence!"><code>QuantumControlBase.Functionals.grad_J_a_fluence!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Analytic derivative for <a href="#QuantumControlBase.Functionals.J_a_fluence"><code>J_a_fluence</code></a>.</p><pre><code class="language-julia hljs">grad_J_a_fluence!(∇J_a, pulsevals, tlist)</code></pre><p>sets the (vectorized) elements of <code>∇J_a</code> to <span>$2 ϵ_{ln} dt$</span>, where <span>$ϵ_{ln}$</span> are the (vectorized) elements of <code>pulsevals</code> and <span>$dt$</span> is the time step, taken from the first time interval of <code>tlist</code> and assumed to be uniform.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.F_sm" href="#QuantumControlBase.Functionals.F_sm"><code>QuantumControlBase.Functionals.F_sm</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Square-modulus fidelity.</p><pre><code class="language-julia hljs">F_sm(ϕ, objectives; τ=nothing)</code></pre><p>calculates</p><p class="math-container">\[F_{\text{sm}}
    = |f_τ|^2
    = \left\vert\frac{1}{N} \sum_{k=1}^{N} w_k τ_k\right\vert^2
    = \frac{1}{N^2} \sum_{k=1}^{N} \sum_{j=1}^{N} w_k w_j τ̄_k τ_j
    \quad\in [0, 1]\,,\]</p><p>with <span>$w_k$</span> the weight for the k&#39;th objective and <span>$τ_k$</span> the overlap of the k&#39;th propagated state with the k&#39;th target state, <span>$τ̄_k$</span> the complex conjugate of <span>$τ_k$</span>, and <span>$N$</span> the number of objectives.</p><p>All arguments are passed to <a href="#QuantumControlBase.Functionals.f_tau"><code>f_tau</code></a> to evaluate <span>$f_τ$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.chi_sm!" href="#QuantumControlBase.Functionals.chi_sm!"><code>QuantumControlBase.Functionals.chi_sm!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Backward boundary states <span>$|χ⟩$</span> for functional <a href="#QuantumControlBase.Functionals.J_T_sm"><code>J_T_sm</code></a>.</p><pre><code class="language-julia hljs">chi_sm!(χ, ϕ, objectives; τ=nothing)</code></pre><p>sets the elements of <code>χ</code> according to</p><p class="math-container">\[|χ_k⟩
= -\frac{\partial J_{T,\text{sm}}}{\partial ⟨ϕ_k(T)|}
= \frac{1}{N^2} w_k \sum_{j}^{N} w_j τ_j |ϕ_k^{\tgt}⟩\]</p><p>with <span>$|ϕ^{\tgt}_k⟩$</span>, <span>$τ_j$</span> and <span>$w_k$</span> as defined in <a href="#QuantumControlBase.Functionals.f_tau"><code>f_tau</code></a>.</p><p>Note: this function can be obtained with <code>make_chi(J_T_sm, objectives)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.F_re" href="#QuantumControlBase.Functionals.F_re"><code>QuantumControlBase.Functionals.F_re</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Real-part fidelity.</p><pre><code class="language-julia hljs">F_re(ϕ, objectives; τ=nothing)</code></pre><p>calculates</p><p class="math-container">\[F_{\text{re}}
    = \Re[f_{τ}]
    = \Re\left[
        \frac{1}{N} \sum_{k=1}^{N} w_k τ_k
    \right]
    \quad\in \begin{cases}
    [-1, 1] &amp; \text{in Hilbert space} \\
    [0, 1] &amp; \text{in Liouville space.}
\end{cases}\]</p><p>with <span>$w_k$</span> the weight for the k&#39;th objective and <span>$τ_k$</span> the overlap of the k&#39;th propagated state with the k&#39;th target state, and <span>$N$</span> the number of objectives.</p><p>All arguments are passed to <a href="#QuantumControlBase.Functionals.f_tau"><code>f_tau</code></a> to evaluate <span>$f_τ$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.F_ss" href="#QuantumControlBase.Functionals.F_ss"><code>QuantumControlBase.Functionals.F_ss</code></a> — <span class="docstring-category">Function</span></header><section><div><p>State-to-state phase-insensitive fidelity.</p><pre><code class="language-julia hljs">F_ss(ϕ, objectives; τ=nothing)</code></pre><p>calculates</p><p class="math-container">\[F_{\text{ss}} = \frac{1}{N} \sum_{k=1}^{N} w_k |τ_k|^2 \quad\in [0, 1]\]</p><p>with <span>$N$</span>, <span>$w_k$</span> and <span>$τ_k$</span> as in <a href="#QuantumControlBase.Functionals.f_tau"><code>f_tau</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.f_tau" href="#QuantumControlBase.Functionals.f_tau"><code>QuantumControlBase.Functionals.f_tau</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Average complex overlap of the target states with forward-propagated states.</p><pre><code class="language-julia hljs">f_tau(ϕ, objectives; τ=nothing)</code></pre><p>calculates</p><p class="math-container">\[f_τ = \frac{1}{N} \sum_{k=1}^{N} w_k τ_k\]</p><p>with</p><p class="math-container">\[τ_k = ⟨ϕ_k^\tgt|ϕ_k(T)⟩\]</p><p>in Hilbert space, or</p><p class="math-container">\[τ_k = \tr[ρ̂_k^{\tgt\,\dagger} ρ̂_k(T)]\]</p><p>in Liouville space, where <span>$|ϕ_k⟩$</span> or <span>$ρ̂_k$</span> are the elements of <code>ϕ</code>, and <span>$|ϕ_k^\tgt⟩$</span> or <span>$ρ̂_k^\tgt$</span> are the target states from the <code>target_state</code> field of the <code>objectives</code>. If <code>τ</code> is given as a keyword argument, it must contain the values <code>τ_k</code> according to the above definition. Otherwise, the <span>$τ_k$</span> values will be calculated internally.</p><p><span>$N$</span> is the number of objectives, and <span>$w_k$</span> is the <code>weight</code> attribute for each objective. The weights are not automatically normalized, they are assumed to have values such that the resulting <span>$f_τ$</span> lies in the unit circle of the complex plane. Usually, this means that the weights should sum to <span>$N$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.chi_re!" href="#QuantumControlBase.Functionals.chi_re!"><code>QuantumControlBase.Functionals.chi_re!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Backward boundary states <span>$|χ⟩$</span> for functional <a href="#QuantumControlBase.Functionals.J_T_re"><code>J_T_re</code></a>.</p><pre><code class="language-julia hljs">chi_re!(χ, ϕ, objectives; τ=nothing)</code></pre><p>sets the elements of <code>χ</code> according to</p><p class="math-container">\[|χ_k⟩
= -\frac{∂ J_{T,\text{re}}}{∂ ⟨ϕ_k(T)|}
= \frac{1}{2N} w_k |ϕ^{\tgt}_k⟩\]</p><p>with <span>$|ϕ^{\tgt}_k⟩$</span> and <span>$w_k$</span> as defined in <a href="#QuantumControlBase.Functionals.f_tau"><code>f_tau</code></a>.</p><p>Note: this function can be obtained with <code>make_chi(J_T_re, objectives)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Functionals.chi_ss!" href="#QuantumControlBase.Functionals.chi_ss!"><code>QuantumControlBase.Functionals.chi_ss!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Backward boundary states <span>$|χ⟩$</span> for functional <a href="#QuantumControlBase.Functionals.J_T_ss"><code>J_T_ss</code></a>.</p><pre><code class="language-julia hljs">chi_ss!(χ, ϕ, objectives; τ=nothing)</code></pre><p>sets the elements of <code>χ</code> according to</p><p class="math-container">\[|χ_k⟩
= -\frac{∂ J_{T,\text{ss}}}{∂ ⟨ϕ_k(T)|}
= \frac{1}{N} w_k τ_k |ϕ^{\tgt}_k⟩\,,\]</p><p>with <span>$|ϕ^{\tgt}_k⟩$</span>, <span>$τ_k$</span> and <span>$w_k$</span> as defined in <a href="#QuantumControlBase.Functionals.f_tau"><code>f_tau</code></a>.</p><p>Note: this function can be obtained with <code>make_chi(J_T_ss, objectives)</code>.</p></div></section></article><h2 id="QuantumControlBasePulseParametrizationsAPI"><a class="docs-heading-anchor" href="#QuantumControlBasePulseParametrizationsAPI">QuantumControlBase.PulseParametrizations</a><a id="QuantumControlBasePulseParametrizationsAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBasePulseParametrizationsAPI" title="Permalink"></a></h2><h3 id="Public-3"><a class="docs-heading-anchor" href="#Public-3">Public</a><a class="docs-heading-anchor-permalink" href="#Public-3" title="Permalink"></a></h3><ul><li><a href="#QuantumControlBase.PulseParametrizations.LogisticParametrization"><code>LogisticParametrization</code></a></li><li><a href="#QuantumControlBase.PulseParametrizations.LogisticSqParametrization"><code>LogisticSqParametrization</code></a></li><li><a href="#QuantumControlBase.PulseParametrizations.ParametrizedAmplitude"><code>ParametrizedAmplitude</code></a></li><li><a href="#QuantumControlBase.PulseParametrizations.SquareParametrization"><code>SquareParametrization</code></a></li><li><a href="#QuantumControlBase.PulseParametrizations.TanhParametrization"><code>TanhParametrization</code></a></li><li><a href="#QuantumControlBase.PulseParametrizations.TanhSqParametrization"><code>TanhSqParametrization</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.PulseParametrizations.LogisticParametrization" href="#QuantumControlBase.PulseParametrizations.LogisticParametrization"><code>QuantumControlBase.PulseParametrizations.LogisticParametrization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parametrization with a Logistic function that enforces <code>a_min &lt; a(t) &lt; a_max</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.PulseParametrizations.LogisticSqParametrization" href="#QuantumControlBase.PulseParametrizations.LogisticSqParametrization"><code>QuantumControlBase.PulseParametrizations.LogisticSqParametrization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parametrization with a Logistic-Square function that enforces <code>0 ≤ a(t) &lt; a_max</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.PulseParametrizations.ParametrizedAmplitude" href="#QuantumControlBase.PulseParametrizations.ParametrizedAmplitude"><code>QuantumControlBase.PulseParametrizations.ParametrizedAmplitude</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An amplitude determined by a pulse parametrization.</p><p>That is, <span>$a(t) = a(ϵ(t))$</span> with a bijective mapping between the value of <span>$a(t)$</span> and <span>$ϵ(t)$</span>, e.g. <span>$a(t) = ϵ^2(t)$</span> (a <a href="#QuantumControlBase.PulseParametrizations.SquareParametrization"><code>SquareParametrization</code></a>). Optionally, the amplitude may be multiplied with an additional shape function, cf. <a href="../quantum_propagators/#QuantumPropagators.Amplitudes.ShapedAmplitude"><code>ShapedAmplitude</code></a>.</p><pre><code class="language-julia hljs">ampl = ParametrizedAmplitude(control; parametrization)</code></pre><p>initilizes <span>$a(t) = a(ϵ(t)$</span> where <span>$ϵ(t)$</span> is the <code>control</code>, and the mandatory keyword argument <code>parametrization</code> is a <a href="#QuantumControlBase.PulseParametrizations.PulseParametrization"><code>PulseParametrization</code></a>. The <code>control</code> must either be a vector of values discretized to the midpoints of a time grid, or a callable <code>control(t)</code>.</p><pre><code class="language-julia hljs">ampl = ParametrizedAmplitude(control; parametrization, shape=shape)</code></pre><p>initializes <span>$a(t) = S(t) a(ϵ(t))$</span> where <span>$S(t)$</span> is the given <code>shape</code>. It must be a vector if <code>control</code> is a vector, or a callable <code>shape(t)</code> if <code>control</code> is a callable.</p><pre><code class="language-julia hljs">ampl = ParametrizedAmplitude(control, tlist; parametrization, shape=shape)</code></pre><p>discretizes <code>control</code> and <code>shape</code> (if given) to the midpoints of <code>tlist</code> before initialization.</p><pre><code class="language-julia hljs">ampl = ParametrizedAmplitude(
    amplitude, tlist; parametrization, shape=shape, parametrize=true
)</code></pre><p>initializes <span>$ã(t) = S(t) a(t)$</span> where <span>$a(t)$</span> is the input <code>amplitude</code>. First, if <code>amplitude</code> is a callable <code>amplitude(t)</code>, it is discretized to the midpoints of <code>tlist</code>. Then, a <code>control</code> <span>$ϵ(t)$</span> is calculated so that <span>$a(t) ≈ a(ϵ(t))$</span>. Clippling may occur if the values in <code>amplitude</code> cannot represented with the given <code>parametrization</code>. Lastly, <code>ParametrizedAmplitude(control; parametrization, shape)</code> is initialized with the calculated <code>control</code>.</p><p>Note that the <code>tlist</code> keyword argument is required when <code>parametrize=true</code> is given, even if <code>amplitude</code> is already a vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.PulseParametrizations.SquareParametrization" href="#QuantumControlBase.PulseParametrizations.SquareParametrization"><code>QuantumControlBase.PulseParametrizations.SquareParametrization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parametrization a(t) = ϵ²(t), enforcing pulse values <span>$a(t) ≥ 0$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.PulseParametrizations.TanhParametrization" href="#QuantumControlBase.PulseParametrizations.TanhParametrization"><code>QuantumControlBase.PulseParametrizations.TanhParametrization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parametrization with a tanh function that enforces <code>a_min &lt; a(t) &lt; a_max</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.PulseParametrizations.TanhSqParametrization" href="#QuantumControlBase.PulseParametrizations.TanhSqParametrization"><code>QuantumControlBase.PulseParametrizations.TanhSqParametrization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parametrization with a tanh² function that enforces <code>0 ≤ a(t) &lt; a_max</code>.</p></div></section></article><h3 id="Private-4"><a class="docs-heading-anchor" href="#Private-4">Private</a><a class="docs-heading-anchor-permalink" href="#Private-4" title="Permalink"></a></h3><ul><li><a href="#QuantumControlBase.PulseParametrizations.PulseParametrization"><code>PulseParametrization</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.PulseParametrizations.PulseParametrization" href="#QuantumControlBase.PulseParametrizations.PulseParametrization"><code>QuantumControlBase.PulseParametrizations.PulseParametrization</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Specification for a &quot;time-local&quot; pulse parametrization.</p><p>The parametrization is given as a collection of three functions:</p><ul><li><span>$a(ϵ(t))$</span></li><li><span>$ϵ(a(t))$</span></li><li><span>$∂a/∂ϵ$</span> as a function of <span>$ϵ(t)$</span>.</li></ul></div></section></article><h2 id="QuantumControlBaseTestUtilsAPI"><a class="docs-heading-anchor" href="#QuantumControlBaseTestUtilsAPI">QuantumControlBase.TestUtils</a><a id="QuantumControlBaseTestUtilsAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBaseTestUtilsAPI" title="Permalink"></a></h2><h3 id="Public-4"><a class="docs-heading-anchor" href="#Public-4">Public</a><a class="docs-heading-anchor-permalink" href="#Public-4" title="Permalink"></a></h3><ul><li><a href="#QuantumControlBase.TestUtils.QuantumTestLogger"><code>QuantumTestLogger</code></a></li><li><a href="#QuantumControlBase.TestUtils.dummy_control_problem"><code>dummy_control_problem</code></a></li><li><a href="#QuantumControlBase.TestUtils.generate_coverage_html"><code>generate_coverage_html</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_complex_matrix"><code>random_complex_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_complex_sparse_matrix"><code>random_complex_sparse_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_hermitian_matrix"><code>random_hermitian_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_hermitian_real_matrix"><code>random_hermitian_real_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_hermitian_sparse_matrix"><code>random_hermitian_sparse_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_hermitian_sparse_real_matrix"><code>random_hermitian_sparse_real_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_real_matrix"><code>random_real_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_real_sparse_matrix"><code>random_real_sparse_matrix</code></a></li><li><a href="#QuantumControlBase.TestUtils.random_state_vector"><code>random_state_vector</code></a></li><li><a href="#QuantumControlBase.TestUtils.show_coverage"><code>show_coverage</code></a></li><li><a href="#QuantumControlBase.TestUtils.test"><code>test</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.QuantumTestLogger" href="#QuantumControlBase.TestUtils.QuantumTestLogger"><code>QuantumControlBase.TestUtils.QuantumTestLogger</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Logger that stores all messages in a <code>messages</code> field (array of strings).</p><p>The <code>in</code> operator can be used to check whether a string or regex is in any of the recorded messages.</p><pre><code class="language-julia hljs">test_logger = QuantumTestLogger()
with_logger(test_logger) do
    #...
end
@test &quot;message&quot; in logger</code></pre><p>This is a simplified version of <code>Logging.TestLogger</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.dummy_control_problem" href="#QuantumControlBase.TestUtils.dummy_control_problem"><code>QuantumControlBase.TestUtils.dummy_control_problem</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Set up a dummy control problem.</p><pre><code class="language-julia hljs">problem = dummy_control_problem(;
    N=10, n_objectives=1, n_controls=1, n_steps=50, dt=1.0, sparsity=0.5,
    complex_operators=true, hermitian=true, kwargs...)</code></pre><p>Sets up a control problem with random (sparse) Hermitian matrices.</p><p><strong>Arguments</strong></p><ul><li><code>N</code>: The dimension of the Hilbert space</li><li><code>n_objectives</code>: The number of objectives in the optimization. All objectives will have the same Hamiltonian, but random initial and target states.</li><li><code>n_controls</code>: The number of controls, that is, the number of control terms in the control Hamiltonian. Each control is an array of random values, normalized on the intervals of the time grid.</li><li><code>n_steps</code>: The number of time steps (intervals of the time grid)</li><li><code>dt</code>: The time step</li><li><code>sparsity</code>: The sparsity of the Hamiltonians, as a number between 0.0 and 1.0. For <code>sparsity=1.0</code>, the Hamiltonians will be dense matrices.</li><li><code>complex_operators</code>: Whether or not the drift/control operators will be complex-valued or real-valued.</li><li><code>hermitian</code>: Whether or not all drift/control operators will be Hermitian matrices.</li><li><code>kwargs</code>: All other keyword arguments are passed on to <a href="#QuantumControlBase.ControlProblem"><code>ControlProblem</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.generate_coverage_html" href="#QuantumControlBase.TestUtils.generate_coverage_html"><code>QuantumControlBase.TestUtils.generate_coverage_html</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Generate an HTML report for existing coverage data.</p><pre><code class="language-julia hljs">generate_coverage_html(path=&quot;./&quot;; covdir=&quot;coverage&quot;, genhtml=&quot;genhtml&quot;)</code></pre><p>creates a folder <code>covdir</code> and use the external <code>genhtml</code> program to write an HTML coverage report into that folder.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.random_complex_matrix" href="#QuantumControlBase.TestUtils.random_complex_matrix"><code>QuantumControlBase.TestUtils.random_complex_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a random complex matrix of size N×N with spectral radius ρ.</p><pre><code class="language-julia hljs">random_complex_matrix(N, ρ)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.random_complex_sparse_matrix" href="#QuantumControlBase.TestUtils.random_complex_sparse_matrix"><code>QuantumControlBase.TestUtils.random_complex_sparse_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a random sparse complex matrix.</p><pre><code class="language-julia hljs">random_complex_sparse_matrix(N, ρ, sparsity)</code></pre><p>returns a matrix of size N×N with spectral radius ρ and the given sparsity (number between zero and one that is the approximate fraction of non-zero elements).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.random_hermitian_matrix" href="#QuantumControlBase.TestUtils.random_hermitian_matrix"><code>QuantumControlBase.TestUtils.random_hermitian_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a random Hermitian matrix of size N×N with spectral radius ρ.</p><pre><code class="language-julia hljs">random_hermitian_matrix(N, ρ)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.random_hermitian_real_matrix" href="#QuantumControlBase.TestUtils.random_hermitian_real_matrix"><code>QuantumControlBase.TestUtils.random_hermitian_real_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a random Hermitian real matrix of size N×N with spectral radius ρ.</p><pre><code class="language-julia hljs">random_hermitian_real_matrix(N, ρ)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.random_hermitian_sparse_matrix" href="#QuantumControlBase.TestUtils.random_hermitian_sparse_matrix"><code>QuantumControlBase.TestUtils.random_hermitian_sparse_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a random sparse Hermitian matrix.</p><pre><code class="language-julia hljs">random_hermitian_sparse_matrix(N, ρ, sparsity)</code></pre><p>returns a matrix of size N×N with spectral radius ρ and the given sparsity (number between zero and one that is the approximate fraction of non-zero elements).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.random_hermitian_sparse_real_matrix" href="#QuantumControlBase.TestUtils.random_hermitian_sparse_real_matrix"><code>QuantumControlBase.TestUtils.random_hermitian_sparse_real_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a random sparse Hermitian real matrix.</p><pre><code class="language-julia hljs">random_hermitian_sparse_real_matrix(N, ρ, sparsity)</code></pre><p>returns a matrix of size N×N with spectral radius ρ and the given sparsity (number between zero and one that is the approximate fraction of non-zero elements).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.random_real_matrix" href="#QuantumControlBase.TestUtils.random_real_matrix"><code>QuantumControlBase.TestUtils.random_real_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a random real-valued matrix of size N×N with spectral radius ρ.</p><pre><code class="language-julia hljs">random_real_matrix(N, ρ)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.random_real_sparse_matrix" href="#QuantumControlBase.TestUtils.random_real_sparse_matrix"><code>QuantumControlBase.TestUtils.random_real_sparse_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a random sparse real-valued matrix.</p><pre><code class="language-julia hljs">random_real_sparse_matrix(N, ρ, sparsity)</code></pre><p>returns a matrix of size N×N with spectral radius ρ and the given sparsity (number between zero and one that is the approximate fraction of non-zero elements).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.random_state_vector" href="#QuantumControlBase.TestUtils.random_state_vector"><code>QuantumControlBase.TestUtils.random_state_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return a random, normalized Hilbert space state vector of dimension <code>N</code>.</p><pre><code class="language-julia hljs">random_state_vector(N)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.show_coverage" href="#QuantumControlBase.TestUtils.show_coverage"><code>QuantumControlBase.TestUtils.show_coverage</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Print out a coverage summary from existing coverage data.</p><pre><code class="language-julia hljs">show_coverage(path=&quot;./src&quot;; sort_by=nothing)</code></pre><p>prints a a table showing the tracked files in <code>path</code>, the total number of tracked lines in that file (&quot;Total&quot;), the number of lines with coverage (&quot;Hit&quot;), the number of lines without coverage (&quot;Missed&quot;) and the &quot;Coverage&quot; as a percentage.</p><p>The coverage data is collected from <code>.cov</code> files in <code>path</code>.</p><p>Optionally, the table can be sorted by passing the name of a column to <code>sort_by</code>, e..g. <code>sort_py=:Missed</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.test" href="#QuantumControlBase.TestUtils.test"><code>QuantumControlBase.TestUtils.test</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Run a package test-suite in a subprocess.</p><pre><code class="language-julia hljs">test(
    file=&quot;test/runtests.jl&quot;;
    root=pwd(),
    project=&quot;test&quot;,
    code_coverage=&quot;user&quot;,
    show_coverage=(code_coverage == &quot;user&quot;),
    color=&lt;inherit&gt;,
    compiled_modules=&lt;inherit&gt;,
    startup_file=&lt;inherit&gt;,
    depwarn=&lt;inherit&gt;,
    inline=&lt;inherit&gt;,
    check_bounds=&quot;yes&quot;,
    track_allocation=&lt;inherit&gt;,
    threads=&lt;inherit&gt;,
    genhtml=false,
    covdir=&quot;coverage&quot;
)</code></pre><p>runs the test suite of the package located at <code>root</code> by running <code>include(file)</code> inside a new julia process.</p><p>This is similar to what <code>Pkg.test()</code> does, but differs in the &quot;sandboxing&quot; approach. While <code>Pkg.test()</code> creates a new temporary sandboxed environment, <code>test()</code> uses an existing environment in <code>project</code> (the <code>test</code> subfolder by default). This allows testing against the dev-versions of other packages. It requires that the <code>test</code> folder contains both a <code>Project.toml</code> and a <code>Manifest.toml</code> file.</p><p>The <code>test()</code> function also differs from directly including <code>test/runtests.jl</code> in the REPL in that it can generate coverage data and reports (this is only possible when running tests in a subprocess).</p><p>If <code>show_coverage</code> is passed as <code>true</code> (default), a coverage summary is shown. Further, if <code>genhtml</code> is <code>true</code>, a full HTML coverage report will be generated in <code>covdir</code> (relative to <code>root</code>). This requires the <code>genhtml</code> executable (part of the <a href="http://ltp.sourceforge.net/coverage/lcov.php">lcov</a> package). Instead of <code>true</code>, it is also possible to pass the path to the <code>genhtml</code> exectuable.</p><p>All other keyword arguments correspond to the respective command line flag for the <code>julia</code> executable that is run as the subprocess.</p><p>This function is intended to be exposed in a project&#39;s development-REPL.</p></div></section></article><h3 id="Private-5"><a class="docs-heading-anchor" href="#Private-5">Private</a><a class="docs-heading-anchor-permalink" href="#Private-5" title="Permalink"></a></h3><ul><li><a href="#QuantumControlBase.TestUtils.DummyOptimizationResult"><code>DummyOptimizationResult</code></a></li><li><a href="#QuantumControlBase.TestUtils.optimize_with_dummy_method"><code>optimize_with_dummy_method</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.DummyOptimizationResult" href="#QuantumControlBase.TestUtils.DummyOptimizationResult"><code>QuantumControlBase.TestUtils.DummyOptimizationResult</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Result returned by <a href="#QuantumControlBase.TestUtils.optimize_with_dummy_method"><code>optimize_with_dummy_method</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.TestUtils.optimize_with_dummy_method" href="#QuantumControlBase.TestUtils.optimize_with_dummy_method"><code>QuantumControlBase.TestUtils.optimize_with_dummy_method</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Run a dummy optimization.</p><pre><code class="language-julia hljs">result = optimize(problem, method=:dummymethod)</code></pre><p>runs through and &quot;optimization&quot; of the given <code>problem</code> where in each iteration, the amplitude of the guess pulses is diminished by 10%. The (summed) vector norm of the the control serves as the value of the optimization functional.</p></div></section></article><h2 id="QuantumControlBaseWeylChamberAPI"><a class="docs-heading-anchor" href="#QuantumControlBaseWeylChamberAPI">QuantumControlBase.WeylChamber</a><a id="QuantumControlBaseWeylChamberAPI-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBaseWeylChamberAPI" title="Permalink"></a></h2><h3 id="Public-5"><a class="docs-heading-anchor" href="#Public-5">Public</a><a class="docs-heading-anchor-permalink" href="#Public-5" title="Permalink"></a></h3><ul><li><a href="#QuantumControlBase.WeylChamber.D_PE"><code>D_PE</code></a></li><li><a href="#QuantumControlBase.WeylChamber.canonical_gate"><code>canonical_gate</code></a></li><li><a href="#QuantumControlBase.WeylChamber.gate_concurrence"><code>gate_concurrence</code></a></li><li><a href="#QuantumControlBase.WeylChamber.in_weyl_chamber"><code>in_weyl_chamber</code></a></li><li><a href="#QuantumControlBase.WeylChamber.local_invariants"><code>local_invariants</code></a></li><li><a href="#QuantumControlBase.WeylChamber.unitarity"><code>unitarity</code></a></li><li><a href="#QuantumControlBase.WeylChamber.weyl_chamber_coordinates"><code>weyl_chamber_coordinates</code></a></li><li><a href="#QuantumControlBase.WeylChamber.weyl_chamber_region"><code>weyl_chamber_region</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.WeylChamber.D_PE" href="#QuantumControlBase.WeylChamber.D_PE"><code>QuantumControlBase.WeylChamber.D_PE</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Perfect-entanglers distance measure.</p><pre><code class="language-julia hljs">D = D_PE(U; unitarity_weight=0.0, absolute_square=false)</code></pre><p>For a given two-qubit gate <span>$Û$</span>, this is defined via the <a href="#QuantumControlBase.WeylChamber.local_invariants"><code>local_invariants</code></a> <span>$g_1$</span>, <span>$g_2$</span>, <span>$g_3$</span> as</p><p class="math-container">\[D = g_3 \sqrt{g_1^2 + g_2^2} - g_1\]</p><p>This describes the geometric distance of the quantum gate from the polyhedron of perfect entanglers in the Weyl chamber.</p><p>This equation is only meaningful under the assumption that <span>$Û$</span> is unitary. If the two-qubit level are a logical subspace embedded in a larger physical Hilbert space, loss of population from the logical subspace may lead to a non-unitary <span>$Û$</span>. In this case, the <a href="#QuantumControlBase.WeylChamber.unitarity"><code>unitarity</code></a> measure can be added to the functional by giving a <code>unitary_weight</code> ∈ [0, 1) that specifies the relative proportion of the <span>$D$</span> term and the unitarity term.</p><p>By specifying <code>absolute_square=true</code>, the functional is modified as <span>$D → |D|²$</span>, optimizing specifically for the <em>boundary</em> of the perfect entanglers polyhedron. This accounts for the fact that <span>$D$</span> can take negative values inside the polyhedron, as well as the <code>W1</code> region of the Weyl chamber (the one adjacent to SWAP). This may be especially useful in a system with population loss (<code>unitarity_weight</code> &gt; 0), as it avoids situations where the optimization goes deeper into the perfect entanglers while <em>increasing</em> population loss.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The functional does not check which region of the Weyl chamber the quantum gate is in. When using this for an optimization where the guess leads to a point in the <code>W1</code> region of the Weyl chamber (close to SWAP), the sign of the functional must be flipped, or else it will optimize for SWAP. Alternatively, use <code>absolute_square=true</code>.</p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The functional can be converted into the correct form for an optimization that uses one objective for each logical basis state by using <code>QuantumControl.Functionals.gate_functional</code>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.WeylChamber.canonical_gate" href="#QuantumControlBase.WeylChamber.canonical_gate"><code>QuantumControlBase.WeylChamber.canonical_gate</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct the canonical gate for the given Weyl chamber coordinates.</p><pre><code class="language-julia hljs">Û = canonical_gate(c₁, c₂, c₃)</code></pre><p>constructs the two qubit gate <span>$Û$</span> as</p><p class="math-container">\[Û = \exp\left[i\frac{π}{2} (c_1 σ̂_x σ̂_x + c_2 σ̂_y σ̂_y + c_3 σ̂_z σ̂_z)\right]\]</p><p>where <span>$σ̂_{x,y,z}$</span> are the Pauli matrices.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.WeylChamber.gate_concurrence" href="#QuantumControlBase.WeylChamber.gate_concurrence"><code>QuantumControlBase.WeylChamber.gate_concurrence</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculate the maximum gate concurrence.</p><pre><code class="language-julia hljs">C = gate_concurrence(U)
C = gate_concurrence(c₁, c₂, c₃)</code></pre><p>calculates that maximum concurrence <span>$C ∈ [0, 1]$</span> that the two two-qubit gate <code>U</code>, respectively the gate described by the Weyl chamber coordinates <code>c₁</code>, <code>c₂</code>, <code>c₃</code> (see <a href="#QuantumControlBase.WeylChamber.weyl_chamber_coordinates"><code>weyl_chamber_coordinates</code></a>) can generate.</p><p>See Kraus, Cirac, Phys. Rev. A 63, 062309 (2001)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.WeylChamber.in_weyl_chamber" href="#QuantumControlBase.WeylChamber.in_weyl_chamber"><code>QuantumControlBase.WeylChamber.in_weyl_chamber</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Check whether a given gate is in (a specific region of) the Weyl chamber.</p><pre><code class="nohighlight hljs">in_weyl_chamber(c₁, c₂, c₃)</code></pre><p>checks whether <code>c₁</code>, <code>c₂</code>, <code>c₃</code> are valid Weyl chamber coordinates.</p><pre><code class="nohighlight hljs">in_weyl_chamber(U; region=&quot;PE&quot;)
in_weyl_chamber(c₁, c₂, c₃; region=&quot;PE&quot;)</code></pre><p>checks whether the two-qubit gate <code>U</code>, respectively the gate described by the Weyl chamber coordinates <code>c₁</code>, <code>c₂</code>, <code>c₃</code> (see <a href="#QuantumControlBase.WeylChamber.weyl_chamber_coordinates"><code>weyl_chamber_coordinates</code></a>) is a perfect entangler. The <code>region</code> can be any other of the regions returned by <a href="#QuantumControlBase.WeylChamber.weyl_chamber_region"><code>weyl_chamber_region</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.WeylChamber.local_invariants" href="#QuantumControlBase.WeylChamber.local_invariants"><code>QuantumControlBase.WeylChamber.local_invariants</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculate the local invariants g₁, g₂, g₃ for a two-qubit gate.</p><pre><code class="language-julia hljs">g₁, g₂, g₃ = local_invariants(U)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.WeylChamber.unitarity" href="#QuantumControlBase.WeylChamber.unitarity"><code>QuantumControlBase.WeylChamber.unitarity</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Unitarity of a matrix.</p><pre><code class="nohighlight hljs">pop_loss = 1 - unitarity(U)</code></pre><p>measures the loss of population from the subspace described by <code>U</code>. E.g., for a two-qubit gate, <code>U</code> is a 4×4 matrix. The <code>unitarity</code> is defined as <span>$\Re[\tr(Û^†Û) / N]$</span> where <span>$N$</span> is the dimension of <span>$Û$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.WeylChamber.weyl_chamber_coordinates" href="#QuantumControlBase.WeylChamber.weyl_chamber_coordinates"><code>QuantumControlBase.WeylChamber.weyl_chamber_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculate the Weyl chamber coordinates c₁, c₂, c₃ for a two-qubit gate.</p><pre><code class="language-julia hljs">c₁, c₂, c₃ = weyl_chamber_coordinates(U)</code></pre><p>calculates the Weyl chamber coordinates using the algorithm described in Childs et al., PRA 68, 052311 (2003).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.WeylChamber.weyl_chamber_region" href="#QuantumControlBase.WeylChamber.weyl_chamber_region"><code>QuantumControlBase.WeylChamber.weyl_chamber_region</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Identify which region of the Weyl chamber a given gate is located in.</p><pre><code class="language-julia hljs">region = weyl_chamber_region(U)
region = weyl_chamber_region(c₁, c₂, c₃)</code></pre><p>identifies which region of the Weyl chamber the given two-qubit gate <code>U</code>, respectively the gate identified by the Weyl chamber coordinates <code>c₁</code>, <code>c₂</code>, <code>c₃</code> (see <a href="#QuantumControlBase.WeylChamber.weyl_chamber_coordinates"><code>weyl_chamber_coordinates</code></a>) is in, as a string. Possible outputs are:</p><ul><li><code>&quot;PE&quot;</code>: gate is in the polyhedron of perfect entanglers.</li><li><code>&quot;W0&quot;</code>: gate is between the identity and the perfect entanglers.</li><li><code>&quot;W0*&quot;</code>: gate is between CPHASE(2π) and the perfect entanglers.</li><li><code>&quot;W1&quot;</code>: gate is between SWAP and the perfect entanglers.</li></ul><p>For invalid Weyl chamber coordinates, an empty string is returned.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quantum_propagators/">« QuantumPropagators</a><a class="docs-footer-nextpage" href="../krotov/">Krotov »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/QuantumControl.jl">QuantumControl.jl</a> v0.5.0+dev docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 28 January 2023 18:15">Saturday 28 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

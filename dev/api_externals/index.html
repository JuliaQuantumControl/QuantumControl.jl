<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Externals · QuantumControl.jl</title><meta name="title" content="Externals · QuantumControl.jl"/><meta property="og:title" content="Externals · QuantumControl.jl"/><meta property="twitter:title" content="Externals · QuantumControl.jl"/><meta name="description" content="Documentation for QuantumControl.jl."/><meta property="og:description" content="Documentation for QuantumControl.jl."/><meta property="twitter:description" content="Documentation for QuantumControl.jl."/><meta property="og:url" content="https://juliaquantumcontrol.github.io/QuantumControl.jl/api_externals/"/><meta property="twitter:url" content="https://juliaquantumcontrol.github.io/QuantumControl.jl/api_externals/"/><link rel="canonical" href="https://juliaquantumcontrol.github.io/QuantumControl.jl/api_externals/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/assets/topbar/topbar.css" rel="stylesheet" type="text/css"/><script src="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/assets/topbar/topbar.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumControl.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li><a class="tocitem" href="../manual/">User Manual</a></li><li><a class="tocitem" href="../methods/">Control Methods</a></li><li><a class="tocitem" href="../howto/">Howto</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../api/quantum_control/">QuantumControl</a></li><li><a class="tocitem" href="../api/quantum_control_reference/">Local Submodules</a></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Subpackages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/quantum_propagators/">QuantumPropagators</a></li><li><a class="tocitem" href="../api/quantum_control_base/">QuantumControlBase</a></li></ul></li><li class="is-active"><a class="tocitem" href>Externals</a></li><li><a class="tocitem" href="../api/quantum_control_index/">Index</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Externals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Externals</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/QuantumControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/master/docs/src/api_externals.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krotov.KrotovResult" href="#Krotov.KrotovResult"><code>Krotov.KrotovResult</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Result object returned by <a href="#Krotov.optimize_krotov-Tuple{Any}"><code>optimize_krotov</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/Krotov.jl/blob/44aaa6f96ff8f2c0b64c4964efaa21007d5c7575/src/result.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krotov.optimize_krotov-Tuple{Any}" href="#Krotov.optimize_krotov-Tuple{Any}"><code>Krotov.optimize_krotov</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="../api/quantum_control_base/#QuantumControlBase.optimize"><code>optimize(problem; method=Krotov, kwargs...)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/Krotov.jl/blob/44aaa6f96ff8f2c0b64c4964efaa21007d5c7575/src/optimize.jl#L105-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krotov.print_table-Tuple{Any, Any, Vararg{Any}}" href="#Krotov.print_table-Tuple{Any, Any, Vararg{Any}}"><code>Krotov.print_table</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Print optimization progress as a table.</p><p>This functions serves as the default <code>info_hook</code> for an optimization with Krotov&#39;s method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/Krotov.jl/blob/44aaa6f96ff8f2c0b64c4964efaa21007d5c7575/src/optimize.jl#L333-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.optimize-Tuple{Any, Val{:Krotov}}" href="#QuantumControlBase.optimize-Tuple{Any, Val{:Krotov}}"><code>QuantumControlBase.optimize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">using Krotov
result = optimize(problem; method=Krotov, kwargs...)</code></pre><p>optimizes the given control <a href="../api/quantum_control_base/#QuantumControlBase.ControlProblem"><code>problem</code></a> using Krotov&#39;s method, returning a <a href="#Krotov.KrotovResult"><code>KrotovResult</code></a>.</p><p>Keyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of <code>problem</code>; any of these can be overriden with explicit keyword arguments to <code>optimize</code>.</p><p><strong>Required problem keyword arguments</strong></p><ul><li><code>J_T</code>: A function <code>J_T(ϕ, trajectories)</code> that evaluates the final time functional from a list <code>ϕ</code> of forward-propagated states and <code>problem.trajectories</code>.</li></ul><p><strong>Recommended problem keyword arguments</strong></p><ul><li><code>lambda_a=1.0</code>: The inverse Krotov step width λ_a for every pulse.</li><li><code>update_shape=(t-&gt;1.0)</code>: A function <code>S(t)</code> for the &quot;update shape&quot; that scales the update for every pulse</li></ul><p>If different controls require different <code>lambda_a</code> or <code>update_shape</code>, a dict <code>pulse_options</code> must be given instead of a global <code>lambda_a</code> and <code>update_shape</code>, see below.</p><p><strong>Optional problem keyword arguments</strong></p><p>The following keyword arguments are supported (with default values):</p><ul><li><p><code>pulse_options</code>: A dictionary that maps every control (as obtained by <a href="../api/quantum_propagators/#QuantumPropagators.Controls.get_controls"><code>get_controls</code></a> from the <code>problem.trajectories</code>) to the following dict:</p><ul><li><code>:lambda_a</code>:  The value for inverse Krotov step width λₐ</li><li><code>:update_shape</code>: A function <code>S(t)</code> for the &quot;update shape&quot; that scales the Krotov pulse update.</li></ul><p>This overrides the global <code>lambda_a</code> and <code>update_shape</code> arguments.</p></li><li><p><code>chi</code>: A function <code>chi!(χ, ϕ, trajectories)</code> what receives a list <code>ϕ</code> of the forward propagated states and must set <span>$|χₖ⟩ = -∂J_T/∂⟨ϕₖ|$</span>. If not given, it will be automatically determined from <code>J_T</code> via <a href="../api/quantum_control_base/#QuantumControlBase.make_chi"><code>make_chi</code></a> with the default parameters.</p></li><li><p><code>sigma=nothing</code>: Function that calculate the second-order contribution. If not given, the first-order Krotov method is used.</p></li><li><p><code>iter_start=0</code>: the initial iteration number</p></li><li><p><code>iter_stop=5000</code>: the maximum iteration number</p></li><li><p><code>prop_method</code>: The propagation method to use for each trajectory, see below.</p></li><li><p><code>update_hook</code>: A function that receives the Krotov workspace, the iteration number, the list of updated pulses and the list of guess pulses as positional arguments. The function may mutate any of its arguments. This may be used e.g. to apply a spectral filter to the updated pulses or to perform similar manipulations.</p></li><li><p><code>info_hook</code>: A function (or tuple of functions) that receives the same arguments as <code>update_hook</code>, in order to write information about the current iteration to the screen or to a file. The default <code>info_hook</code> prints a table with convergence information to the screen. Runs after <code>update_hook</code>. The <code>info_hook</code> function may return a tuple, which is stored in the list of <code>records</code> inside the <a href="#Krotov.KrotovResult"><code>KrotovResult</code></a> object.</p></li><li><p><code>check_convergence</code>: a function to check whether convergence has been reached. Receives a <a href="#Krotov.KrotovResult"><code>KrotovResult</code></a> object <code>result</code>, and should set <code>result.converged</code> to <code>true</code> and <code>result.message</code> to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with <code>∘</code>. The convergence check is performed after any calls to <code>update_hook</code> and <code>info_hook</code>.</p></li><li><p><code>verbose=false</code>: If <code>true</code>, print information during initialization</p></li></ul><p><strong>Trajectory propagation</strong></p><p>Krotov&#39;s method involves the forward and backward propagation for every <a href="../api/quantum_control_base/#QuantumControlBase.Trajectory"><code>Trajectory</code></a> in the <code>problem</code>. The keyword arguments for each propagation (see <a href="../api/quantum_propagators/#QuantumPropagators.propagate"><code>propagate</code></a>) are determined from any properties of each <a href="../api/quantum_control_base/#QuantumControlBase.Trajectory"><code>Trajectory</code></a> that have a <code>prop_</code> prefix, cf. <a href="../api/quantum_control_base/#QuantumControlBase.init_prop_trajectory"><code>init_prop_trajectory</code></a>.</p><p>In situations where different parameters are required for the forward and backward propagation, instead of the <code>prop_</code> prefix, the <code>fw_prop_</code> and <code>bw_prop_</code> prefix can be used, respectively. These override any setting with the <code>prop_</code> prefix. This applies both to the properties of each <a href="../api/quantum_control_base/#QuantumControlBase.Trajectory"><code>Trajectory</code></a> and the problem keyword arguments.</p><p>Note that the propagation method for each propagation must be specified. In most cases, it is sufficient (and recommended) to pass a global <code>prop_method</code> problem keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/Krotov.jl/blob/44aaa6f96ff8f2c0b64c4964efaa21007d5c7575/src/optimize.jl#L12-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GRAPE.GrapeResult" href="#GRAPE.GrapeResult"><code>GRAPE.GrapeResult</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Result object returned by <a href="#GRAPE.optimize_grape-Tuple{Any}"><code>optimize_grape</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/GRAPE.jl/blob/2b5646664b4159a5d6170ec2369ce5e8072a405c/src/result.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GRAPE.GrapeWrk" href="#GRAPE.GrapeWrk"><code>GRAPE.GrapeWrk</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Grape Workspace.</p><p><strong>Methods</strong></p><ul><li><a href="#GRAPE.step_width-Tuple{Any}"><code>step_width</code></a></li><li><a href="#GRAPE.search_direction-Tuple{Any}"><code>search_direction</code></a></li><li><a href="#GRAPE.gradient-Tuple{Any}"><code>gradient</code></a></li><li><a href="#GRAPE.pulse_update-Tuple{Any}"><code>pulse_update</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/GRAPE.jl/blob/2b5646664b4159a5d6170ec2369ce5e8072a405c/src/workspace.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GRAPE.gradient-Tuple{Any}" href="#GRAPE.gradient-Tuple{Any}"><code>GRAPE.gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The gradient in the current iteration.</p><pre><code class="language-julia hljs">g = gradient(wrk; which=:initial)</code></pre><p>returns the gradient associated with the guess pulse of the current iteration. Up to quasi-Newton corrections, the negative gradient determines the <a href="#GRAPE.search_direction-Tuple{Any}"><code>search_direction</code></a> for the <a href="#GRAPE.pulse_update-Tuple{Any}"><code>pulse_update</code></a>.</p><pre><code class="language-julia hljs">g = gradient(wrk; which=:final)</code></pre><p>returns the gradient associated with the optimized pulse of the current iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/GRAPE.jl/blob/2b5646664b4159a5d6170ec2369ce5e8072a405c/src/workspace.jl#L328-L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GRAPE.optimize_grape-Tuple{Any}" href="#GRAPE.optimize_grape-Tuple{Any}"><code>GRAPE.optimize_grape</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="#QuantumControlBase.optimize-Tuple{Any, Val{:GRAPE}}"><code>optimize(problem; method=GRAPE, kwargs...)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/GRAPE.jl/blob/2b5646664b4159a5d6170ec2369ce5e8072a405c/src/optimize.jl#L152-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GRAPE.print_table-Tuple{Any, Any, Vararg{Any}}" href="#GRAPE.print_table-Tuple{Any, Any, Vararg{Any}}"><code>GRAPE.print_table</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Print optimization progress as a table.</p><p>This functions serves as the default <code>info_hook</code> for an optimization with GRAPE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/GRAPE.jl/blob/2b5646664b4159a5d6170ec2369ce5e8072a405c/src/optimize.jl#L436-L441">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GRAPE.pulse_update-Tuple{Any}" href="#GRAPE.pulse_update-Tuple{Any}"><code>GRAPE.pulse_update</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The vector of pulse update values for the current iteration.</p><pre><code class="language-julia hljs">Δu = pulse_update(wrk)</code></pre><p>returns a vector conntaining the different between the optimized pulse values and the guess pulse values of the current iteration. This should be proportional to <a href="#GRAPE.search_direction-Tuple{Any}"><code>search_direction</code></a> with the proportionality factor <a href="#GRAPE.step_width-Tuple{Any}"><code>step_width</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/GRAPE.jl/blob/2b5646664b4159a5d6170ec2369ce5e8072a405c/src/workspace.jl#L359-L370">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GRAPE.search_direction-Tuple{Any}" href="#GRAPE.search_direction-Tuple{Any}"><code>GRAPE.search_direction</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The search direction used in the current iteration.</p><pre><code class="language-julia hljs">s = search_direction(wrk)</code></pre><p>returns the vector describing the search direction used in the current iteration. This should be proportional to <a href="#GRAPE.pulse_update-Tuple{Any}"><code>pulse_update</code></a> with the proportionality factor <a href="#GRAPE.step_width-Tuple{Any}"><code>step_width</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/GRAPE.jl/blob/2b5646664b4159a5d6170ec2369ce5e8072a405c/src/workspace.jl#L315-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GRAPE.step_width-Tuple{Any}" href="#GRAPE.step_width-Tuple{Any}"><code>GRAPE.step_width</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The step width used in the current iteration.</p><pre><code class="language-julia hljs">α = step_width(wrk)</code></pre><p>returns the scalar <code>α</code> so that <code>pulse_update(wrk) = α * search_direction(wrk)</code>, see <a href="#GRAPE.pulse_update-Tuple{Any}"><code>pulse_update</code></a> and <a href="#GRAPE.search_direction-Tuple{Any}"><code>search_direction</code></a> for the iteration desribed by the current <a href="#GRAPE.GrapeWrk"><code>GrapeWrk</code></a> (for the state of <code>wrk</code> as available in the <code>info_hook</code> of the current iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/GRAPE.jl/blob/2b5646664b4159a5d6170ec2369ce5e8072a405c/src/workspace.jl#L292-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GRAPE.vec_angle-Union{Tuple{P}, Tuple{T}, Tuple{N}, Tuple{P, P}} where {N, T, P&lt;:Union{AbstractVector{T}, Tuple{Vararg{T, N}}}}" href="#GRAPE.vec_angle-Union{Tuple{P}, Tuple{T}, Tuple{N}, Tuple{P, P}} where {N, T, P&lt;:Union{AbstractVector{T}, Tuple{Vararg{T, N}}}}"><code>GRAPE.vec_angle</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The angle between two vectors.</p><pre><code class="nohighlight hljs">ϕ = vec_angle(v1, v2; unit=:rad)</code></pre><p>returns the angle between two vectors in radians (or degrees, with <code>unit=:degree</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/GRAPE.jl/blob/2b5646664b4159a5d6170ec2369ce5e8072a405c/src/workspace.jl#L373-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.optimize-Tuple{Any, Val{:GRAPE}}" href="#QuantumControlBase.optimize-Tuple{Any, Val{:GRAPE}}"><code>QuantumControlBase.optimize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">using GRAPE
result = optimize(problem; method=GRAPE, kwargs...)</code></pre><p>optimizes the given control <a href="../api/quantum_control_base/#QuantumControlBase.ControlProblem"><code>problem</code></a> via the GRAPE method, by minimizing the functional</p><p class="math-container">\[J(\{ϵ_{nl}\}) = J_T(\{|ϕ_k(T)⟩\}) + λ_a J_a(\{ϵ_{nl}\})\]</p><p>where the final time functional <span>$J_T$</span> depends explicitly on the forward-propagated states and the running cost <span>$J_a$</span> depends explicitly on pulse values <span>$ϵ_{nl}$</span> of the l&#39;th control discretized on the n&#39;th interval of the time grid.</p><p>Returns a <a href="#GRAPE.GrapeResult"><code>GrapeResult</code></a>.</p><p>Keyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of <code>problem</code>; any of these can be overridden with explicit keyword arguments to <code>optimize</code>.</p><p><strong>Required problem keyword arguments</strong></p><ul><li><code>J_T</code>: A function <code>J_T(ϕ, trajectories; τ=τ)</code> that evaluates the final time functional from a vector <code>ϕ</code> of forward-propagated states and <code>problem.trajectories</code>. For all <code>trajectories</code> that define a <code>target_state</code>, the element <code>τₖ</code> of the vector <code>τ</code> will contain the overlap of the state <code>ϕₖ</code> with the <code>target_state</code> of the <code>k</code>&#39;th trajectory, or <code>NaN</code> otherwise.</li></ul><p><strong>Optional problem keyword arguments</strong></p><ul><li><p><code>chi</code>: A function <code>chi!(χ, ϕ, trajectories)</code> what receives a list <code>ϕ</code> of the forward propagated states and must set <span>$|χₖ⟩ = -∂J_T/∂⟨ϕₖ|$</span>. If not given, it will be automatically determined from <code>J_T</code> via <a href="../api/quantum_control_base/#QuantumControlBase.make_chi"><code>make_chi</code></a> with the default parameters.</p></li><li><p><code>J_a</code>: A function <code>J_a(pulsevals, tlist)</code> that evaluates running costs over the pulse values, where <code>pulsevals</code> are the vectorized values <span>$ϵ_{nl}$</span>, where <code>n</code> are in indices of the time intervals and <code>l</code> are the indices over the controls, i.e., <code>[ϵ₁₁, ϵ₂₁, …, ϵ₁₂, ϵ₂₂, …]</code> (the pulse values for each control are contiguous). If not given, the optimization will not include a running cost.</p></li><li><p><code>gradient_method=:gradgen</code>: One of <code>:gradgen</code> (default) or <code>:taylor</code>. With <code>gradient_method=:gradgen</code>, the gradient is calculated using <a href="https://github.com/JuliaQuantumControl/QuantumGradientGenerators.jl">QuantumGradientGenerators</a>. With <code>gradient_method=:taylor</code>, it is evaluated via a Taylor series, see Eq. (20) in Kuprov and Rogers,  J. Chem. Phys. 131, 234108 (2009) [<a href="../references/#KuprovJCP09">17</a>].</p></li><li><p><code>taylor_grad_max_order=100</code>: If given with <code>gradient_method=:taylor</code>, the maximum number of terms in the Taylor series. If <code>taylor_grad_check_convergence=true</code> (default), if the Taylor series does not convergence within the given number of terms, throw an an error. With <code>taylor_grad_check_convergence=true</code>, this is the exact order of the Taylor series.</p></li><li><p><code>taylor_grad_tolerance=1e-16</code>: If given with <code>gradient_method=:taylor</code> and <code>taylor_grad_check_convergence=true</code>, stop the Taylor series when the norm of the term falls below the given tolerance. Ignored if <code>taylor_grad_check_convergence=false</code>.</p></li><li><p><code>taylor_grad_check_convergence=true</code>: If given as <code>true</code> (default), check the convergence after each term in the Taylor series an stop as soon as the norm of the term drops below the given number. If <code>false</code>, stop after exactly <code>taylor_grad_max_order</code> terms.</p></li><li><p><code>lambda_a=1</code>: A weight for the running cost <code>J_a</code>.</p></li><li><p><code>grad_J_a</code>: A function to calculate the gradient of <code>J_a</code>. If not given, it will be automatically determined.</p></li><li><p><code>upper_bound</code>: An upper bound for the value of any optimized control. Time-dependent upper bounds can be specified via <code>pulse_options</code>.</p></li><li><p><code>lower_bound</code>: A lower bound for the value of any optimized control. Time-dependent lower bounds can be specified via <code>pulse_options</code>.</p></li><li><p><code>pulse_options</code>: A dictionary that maps every control (as obtained by <a href="../api/quantum_propagators/#QuantumPropagators.Controls.get_controls"><code>get_controls</code></a> from the <code>problem.trajectories</code>) to a dict with the following possible keys:</p><ul><li><code>:upper_bounds</code>: A vector of upper bound values, one for each intervals of the time grid. Values of <code>Inf</code> indicate an unconstrained upper bound for that time interval, respectively the global <code>upper_bound</code>, if given.</li><li><code>:lower_bounds</code>: A vector of lower bound values. Values of <code>-Inf</code> indicate an unconstrained lower bound for that time interval,</li></ul></li><li><p><code>update_hook</code>: Not implemented</p></li><li><p><code>info_hook</code>: A function (or tuple of functions) that receives the same arguments as <code>update_hook</code>, in order to write information about the current iteration to the screen or to a file. The default <code>info_hook</code> prints a table with convergence information to the screen. Runs after <code>update_hook</code>. The <code>info_hook</code> function may return a tuple, which is stored in the list of <code>records</code> inside the <a href="#GRAPE.GrapeResult"><code>GrapeResult</code></a> object.</p></li><li><p><code>check_convergence</code>: A function to check whether convergence has been reached. Receives a <a href="#GRAPE.GrapeResult"><code>GrapeResult</code></a> object <code>result</code>, and should set <code>result.converged</code> to <code>true</code> and <code>result.message</code> to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with <code>∘</code>. The convergence check is performed after any calls to <code>update_hook</code> and <code>info_hook</code>.</p></li><li><p><code>x_tol</code>: Parameter for Optim.jl</p></li><li><p><code>f_tol</code>: Parameter for Optim.jl</p></li><li><p><code>g_tol</code>: Parameter for Optim.jl</p></li><li><p><code>show_trace</code>: Parameter for Optim.jl</p></li><li><p><code>extended_trace</code>:  Parameter for Optim.jl</p></li><li><p><code>show_every</code>: Parameter for Optim.jl</p></li><li><p><code>allow_f_increases</code>: Parameter for Optim.jl</p></li><li><p><code>optimizer</code>: An optional Optim.jl optimizer (<code>Optim.AbstractOptimizer</code> instance). If not given, an <a href="https://github.com/Gnimuc/LBFGSB.jl">L-BFGS-B</a> optimizer will be used.</p></li><li><p><code>prop_method</code>: The propagation method to use for each trajectory, see below.</p></li><li><p><code>verbose=false</code>: If <code>true</code>, print information during initialization</p></li></ul><p><strong>Trajectory propagation</strong></p><p>GRAPE may involve three types of propagation:</p><ul><li>A forward propagation for every <a href="../api/quantum_control_base/#QuantumControlBase.Trajectory"><code>Trajectory</code></a> in the <code>problem</code></li><li>A backward propagation for every trajectory</li><li>A backward propagation of a <a href="https://juliaquantumcontrol.github.io/QuantumGradientGenerators.jl/dev/api/#QuantumGradientGenerators.GradGenerator">gradient generator</a> for every trajectory.</li></ul><p>The keyword arguments for each propagation (see <a href="../api/quantum_propagators/#QuantumPropagators.propagate"><code>propagate</code></a>) are determined from any properties of each <a href="../api/quantum_control_base/#QuantumControlBase.Trajectory"><code>Trajectory</code></a> that have a <code>prop_</code> prefix, cf. <a href="../api/quantum_control_base/#QuantumControlBase.init_prop_trajectory"><code>init_prop_trajectory</code></a>.</p><p>In situations where different parameters are required for the forward and backward propagation, instead of the <code>prop_</code> prefix, the <code>fw_prop_</code> and <code>bw_prop_</code> prefix can be used, respectively. These override any setting with the <code>prop_</code> prefix. Similarly, properties for the backward propagation of the gradient generators can be set with properties that have a <code>grad_prop_</code> prefix. These prefixes apply both to the properties of each <a href="../api/quantum_control_base/#QuantumControlBase.Trajectory"><code>Trajectory</code></a> and the problem keyword arguments.</p><p>Note that the propagation method for each propagation must be specified. In most cases, it is sufficient (and recommended) to pass a global <code>prop_method</code> problem keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/GRAPE.jl/blob/2b5646664b4159a5d6170ec2369ce5e8072a405c/src/optimize.jl#L13-L148">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/quantum_control_base/">« QuantumControlBase</a><a class="docs-footer-nextpage" href="../api/quantum_control_index/">Index »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/QuantumControl.jl">QuantumControl.jl</a> v0.9.0+dev docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Sunday 21 April 2024 19:23">Sunday 21 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

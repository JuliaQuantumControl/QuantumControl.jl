var documenterSearchIndex = {"docs":
[{"location":"#QuantumControl","page":"Home","title":"QuantumControl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for QuantumControl.","category":"page"},{"location":"#Control-problems","page":"Home","title":"Control problems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ControlProblem\nObjective","category":"page"},{"location":"#QuantumControlBase.ControlProblem","page":"Home","title":"QuantumControlBase.ControlProblem","text":"A full control problem with multiple objectives.\n\nControlProblem(\n   objectives=<list of objectives>,\n   pulse_options=<dict of controls to pulse options>,\n   tlist=<time grid>,\n   kwargs...\n)\n\nNote that the control problem can only be instantiated via keyword arguments.\n\nThe objectives are a list of Objective instances, each defining an initial state, a dynamical generator for the evolution of the state, and (optionally) a target for the evolution.\n\nThe pulse_options are a dictionary (IdDict) mapping controls that occur in the objectives to properties specific to the control method.\n\nThe tlist is the time grid on which the time evolution of the initial states of each objective should be propagated.\n\nThe remaining kwargs are keyword arguments that are passed directl to the optimal control method. These typically include e.g. the optimization functional.\n\nThe control problem is solved by finding a set of controls that simultaneously fulfill all objectives.\n\n\n\n\n\n","category":"type"},{"location":"#QuantumControlBase.Objective","page":"Home","title":"QuantumControlBase.Objective","text":"A single optimization objective.\n\nObjective(\n    initial_state=<intial state>,\n    generator=<dynamical generator>,\n    [target=<optional target state or specification>]\n)\n\nNote that the objective can only be instantiated via keyword arguments.\n\n\n\n\n\n","category":"type"},{"location":"#Discretization","page":"Home","title":"Discretization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"discretize\ndiscretize_on_midpoints","category":"page"},{"location":"#QuantumControlBase.discretize","page":"Home","title":"QuantumControlBase.discretize","text":"Evaluate control at every point of tlist.\n\nvalues = discretize(control, tlist; via_midpoints=true)\n\ndiscretizes the given control to a Vector of values defined on the points of tlist.\n\nIf control is a function, it will will first be evaluated at the midpoint of tlist, see discretize_on_midpoints, and then the values on the midpoints are converted to values on tlist. This discretization is more stable than directly evaluationg the control function at the values of tlist, and ensures that repeated round-trips between discretize and discretize_on_midpoints can be done safely, see the note in the documentation of discretize_on_midpoints.\n\nThe latter can still be achieved by passing via_midpoints=false. While such a direct discretization is suitable e.g. for plotting, but it is unsuitable for round-trips between discretize and discretize_on_midpoints  (constant controls on tlist may result in a zig-zag on the intervals of tlist).\n\nIf control is a vector, it will be returned un-modified if it is of the same length as tlist. Otherwise, control must have one less value than tlist, and is assumed to be defined on the midpoins of tlist. In that case, discretize acts as the inverse of discretize_on_midpoints. See discretize_on_midpoints for how control values on tlist and control values on the intervals of tlist are related.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumControlBase.discretize_on_midpoints","page":"Home","title":"QuantumControlBase.discretize_on_midpoints","text":"Evaluate control at the midpoints of tlist.\n\nvalues = discretize_on_midpoints(control, tlist)\n\ndiscretizes the given control to a Vector of values on the midpoints of tlist. Hence, the resulting values will contain one less value than tlist.\n\nIf control is a vector of values defined on tlist (i.e., of the same length as tlist), it will be converted to a vector of values on the intervals of tlist. The value for the first and last \"midpoint\" will remain the original values at the beginning and end of tlist, in order to ensure exact bounary conditions. For all other midpoints, the value for that midpoint will be calculated by \"un-averaging\".\n\nFor example, for a control and tlist of length 5, consider the following diagram:\n\ntlist index:       1   2   3   4   5\ntlist:             ⋅   ⋅   ⋅   ⋅   ⋅   input values cᵢ (i ∈ 1..5)\n                   |̂/ ̄ ̄ ̂\\ / ̂\\ / ̂ ̄ ̄\\|̂\nmidpoints:         x     x   x     x   output values pᵢ (i ∈ 1..4)\nmidpoints index:   1     2   3     4\n\nWe will have p₁=c₁ for the first value, p₄=c₅ for the last value. For all other points, the control values cᵢ = fracp_i-1 + p_i2 are the average of the values on the midpoints. This implies the \"un-averaging\" for the midpoint values pᵢ = 2 c_i - p_i-1.\n\nnote: Note\nAn arbitrary input control array may not be compatible with the above averaging formula. In this case, the conversion will be \"lossy\" (discretize will not recover the original control array; the difference should be considered a \"discretization error\"). However, any further round-trip conversions between points and intervals are bijective and preserve the boundary conditions. In this case, the discretize_on_midpoints and discretize methods are each other's inverse. This also implies that for an optimal control procedure, it is safe to modify midpoint values. Modifying the the values on the time grid directly on the other hand may accumulate discretization errors.\n\nIf control is a vector of one less length than tlist, it will be returned unchanged, under the assumption that the input is already properly discretized.\n\nIf control is a function, the function will be directly evaluated at the midpoints marked as x in the above diagram..\n\n\n\n\n\n","category":"function"},{"location":"#Time-dependencies","page":"Home","title":"Time dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"setcontrolvals\nsetcontrolvals!\ngetcontrols","category":"page"},{"location":"#QuantumControlBase.setcontrolvals","page":"Home","title":"QuantumControlBase.setcontrolvals","text":"Construct G by plugging values into a general generator.\n\nG = setcontrolvals(generator, vals_dict)\nsetcontrolvals!(G, generator, vals_dict)\n\nevaluates the specific dynamical generator G by plugging in values into the general generator according to vals_dict.\n\nThe vals_dict is a dictionary (IdDict) mapping controls as returned by getcontrols(generator) to values.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumControlBase.setcontrolvals!","page":"Home","title":"QuantumControlBase.setcontrolvals!","text":"In-place version of setcontrolvals.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumControlBase.getcontrols","page":"Home","title":"QuantumControlBase.getcontrols","text":"Extract a Tuple of controls.\n\ncontrols = getcontrols(generator)\n\nextracts the controls from a single dynamical generator.\n\ncontrols = getcontrols(objectives)\n\nextracts the controls from a list of objectives (i.e., from each objective's generator)\n\nIn either case, controls that occur multiple times, either in a single generator, or throughout the different objectives, will occur only once in the result.\n\nBy default, assumes that any generator is a nested Tuple, e.g. (H0, (H1, ϵ1), (H2, ϵ2), ...) and extracts (ϵ1, ϵ2)\n\nEach control must be a valid argument for discretize.\n\n\n\n\n\n","category":"function"},{"location":"#Control-shapes","page":"Home","title":"Control shapes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"flattop\nbox\nblackman","category":"page"},{"location":"#QuantumControlBase.flattop","page":"Home","title":"QuantumControlBase.flattop","text":"Flat shape (one) with a switch-on/switch-off from zero.\n\nflattop(t; t₀, T, t_rise, t_fall=t_rise, func=:blackman)\n\nevaluates a shape function that starts at 0 at t=t₀, and ramps to to 1 during the t_rise interval. The function then remains at value 1, before ramping down to 0 again during the interval t_fall before T. For t  t₀ and t  T, the shape is zero.\n\nThe default switch-on/-off shape is half of a Blackman window (see blackman).\n\nFor func=:sinsq, the switch-on/-off shape is a sine-squared curve.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumControlBase.box","page":"Home","title":"QuantumControlBase.box","text":"Box shape (Theta-function).\n\nbox(t, t₀, T)\n\nevaluates the Heaviside (Theta-) function Theta(t) = 1 for t_0 le t le T; and Theta(t) = 0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumControlBase.blackman","page":"Home","title":"QuantumControlBase.blackman","text":"Blackman window shape.\n\nblackman(t, t₀, T; a=0.16)\n\ncalculates\n\nB(t t_0 T) =\n    frac12left(\n        1 - a - cosleft(2π fract - t_0T - t_0right)\n        + a cosleft(4π fract - t_0T - t_0right)\n    right)\n\nfor a scalar t, with a = 0.16.\n\nSee http://en.wikipedia.org/wiki/Window_function#Blackman_windows\n\nA Blackman shape looks nearly identical to a Gaussian with a 6-sigma interval between t₀ and T.  Unlike the Gaussian, however, it will go exactly to zero at the edges. Thus, Blackman pulses are often preferable to Gaussians.\n\n\n\n\n\n","category":"function"},{"location":"#Propagation","page":"Home","title":"Propagation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"propagate\ninitpropwrk\npropstep!\nChebyWrk\ncheby_coeffs!\ncheby_coeffs\nNewtonWrk\nExpPropWrk\ncheby!\nnewton!\nexpprop!","category":"page"},{"location":"#QuantumPropagators.propagate","page":"Home","title":"QuantumPropagators.propagate","text":"Propagate a state over an entire time grid.\n\npropagate(state, genfunc, tlist;\n          backwards=false; wrk=nothing, method=:auto, storage=nothing,\n          observables=(<store state>, ), hook=nothing)\n\npropagates state over the time grid in tlist, using piecewise-constant dynamical generators (Hamiltonians or Liouvillians) determined by genfunc, and returns the resulting propagated state. The propagation is performed by calling propstep! for every interval in tlist.\n\nFor the i'th time interval, genfunc(tlist, i) must return the generator for that time interval. Generally, when approximating a time-continuous dynamical generator as piecewise-constant on the time grid, it should be evaluated at the midpoint of the interval. A possible exception is the first and last interval, which may be better evaluated at tlist[1] and tlist[end] to ensure exact boundary conditions like control fields that are exactly zero.\n\nIn addition to the two positional parameters indicating the time interval, genfunc will also receive the state (the input state for the propagation step), backwards, storage, observables, and init as keyword arguments. These additional parameters may be used for unusual equations of motion beyond the standard Schrödinger or Liouville-von-Neumann equation, e.g. state would enter the genfunc for a Gross–Pitaevskii equation. For standard equations of motion that do not use the additional parameters, it is best to capture the keyword arguments to genfunc with a definition like\n\ngenfunc(tlist, i; kwargs...) = ...\n\nThe propagation method is determined by wrk, see initpropwrk and `propstep!: If wrk is not given, it will be created internally for the given method with initpropwrk; for the default method=:auto, initpropwrk will attempt to choose the most appropriate method for the given parameters, using the generator returned by genfunc with i=1 and the keyword argument init=true.\n\nIn general, there is no requirement that tlist has a constant time step, although some propagation methods (most notably cheby!) only support a uniform time grid.\n\nIf storage is given as an Array, it will be filled with data determined by the observables. The default \"observable\" results in the propagated states at every point in time being stored. The storage array should be created with init_storage. See its documentation for details.\n\nThe storage parameter may also be given as true, and a new storage array will be created internally with init_storage and returned instead of the propagated state.\n\nIf backwards is true, the input state is assumed to be at time tlist[end], and the propagation progresses backwards in time (with a negative time step dt). If storage is given, it will be filled back-to-front during the backwards propagation.\n\nIf hook is given as a callable, it will be called after each propagation step, as hook(state, generator, tlist, i, wrk, observables) where i is the index of the time interval on tlist covered by the propagation step (0 for the initial state, respectives lastindex(tlist) for the backward propagation).  The hook is called before calculating any observables. Example usage includes writing data to file, or modyfing state, e.g. removing amplitude from the lowest and highest level to mitigate \"truncation error\".\n\nThe propagate routine returns the propagated state at tlist[end], respectively tlist[1] if backwards=true, or a storage array with the stored states / observable data if storage=true.\n\n\n\n\n\nPropagate the initial state of a control objective.\n\npropagate(obj, tlist; controls_map=IdDict(), kwargs...)\n\npropagates obj.initial_state under the dynamics described by obj.generator.\n\nThe optional dict control_map may be given to replace the controls in obj.generator (as obtained by getcontrols) with custom functions or vectors, e.g. with the controls resulting from optimization.\n\nAll kwargs are forwarded to QuantumPropagators.propagate.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumPropagators.initpropwrk","page":"Home","title":"QuantumPropagators.initpropwrk","text":"Initialize a workspace for propagation.\n\nwrk = initpropwrk(state, tlist, generator...; method=:auto, kwargs...)\n\nThe resulting wrk can be passed to propagate or propstep!.\n\nArguments\n\nstate: An exemplary state for the propagation (e.g., the initial state)\ntlist: The time grid over which propagate will be called. Must include at least to points in order to determine the propagation time step to prepare. If the propagation will be over a tlist with a variable dt, the full tlist must be passed here.\ngenerator: An exemplary (non-time-dependent) dynamical generator. For full generality (if method=:cheby), the given generator should have a spectral range sufficiently large to encompass the entire propagation. If given multiple times, a spectral envelope enclosing all the generators will be determined automatically. In this case, you should pass the generators with the extremal values of all the controls.\nmethod: The propagation method to use. The default value of :auto attempts to choose the best method available, based on the properties of the given state, tlist, and generator. Alternative values are :cheby and :newton, and :expprop.\n\nAll other kwargs are filtered and passed to the contructor for returned workspace, e.g. limit for method=:cheby or m_max for method=:newton.\n\n\n\n\n\nwrk = initpropwrk(obj, tlist; method=:auto, kwargs...)\n\ninitializes a workspace for the propagation of a control Objective.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumPropagators.propstep!","page":"Home","title":"QuantumPropagators.propstep!","text":"Perform a single propagation step in-place.\n\npropstep!(state, generator, dt, wrk;, kwargs...)\n\nThe propagation method is determined by wrk, see initpropwrk. The kwargs are forwarded to the underlying method\n\n\n\n\n\n","category":"function"},{"location":"#QuantumPropagators.ChebyWrk","page":"Home","title":"QuantumPropagators.ChebyWrk","text":"Workspace for the Chebychev propagation routine.\n\n    ChebyWrk(Ψ, Δ, E_min, dt; limit=1e-12)\n\ninitializes the workspace for the propagation of a state similar to Ψ under a Hamiltonian with eigenvalues between E_min and E_min + Δ, and a time step dt. Chebychev coefficients smaller than the given limit are discarded.\n\n\n\n\n\n","category":"type"},{"location":"#QuantumPropagators.cheby_coeffs!","page":"Home","title":"QuantumPropagators.cheby_coeffs!","text":"Calculate Chebychev coefficients in-place.\n\nWrites the coefficients into coeffs. Returns the number n of coefficients required for convergence, or the size of coeffs, whichever is less.\n\ncoeffs: An array to hold the Chebychev cofficients. On output, the elements  1 through n will hold the calculated coefficients, while the remaining  elements will be unchanged\ndt: the time step\n\n\n\n\n\n","category":"function"},{"location":"#QuantumPropagators.cheby_coeffs","page":"Home","title":"QuantumPropagators.cheby_coeffs","text":"Calculate Chebychev coefficients.\n\nReturn an array of coefficiencts larger than limit.\n\nArgs:\n\nΔ: the spectral radius of the underlying operator\ndt: the time step\n\n\n\n\n\n","category":"function"},{"location":"#QuantumPropagators.NewtonWrk","page":"Home","title":"QuantumPropagators.NewtonWrk","text":"    NewtonWrk(v0, m_max=10)\n\nWorkspace for the Newton-with-restarted-Arnoldi propagation routine.\n\nInitializes the workspace for the propagation of a vector v0, using a maximum Krylov dimension of m_max in each restart iteration. Note that m_max should be smaller than the length of v0.\n\n\n\n\n\n","category":"type"},{"location":"#QuantumPropagators.ExpPropWrk","page":"Home","title":"QuantumPropagators.ExpPropWrk","text":"    ExpPropWrk(v0)\n\nWorkspace for propagation via direct matrix exponentiation.\n\nInitializes the workspace for the propagation of a vector v0\n\n\n\n\n\n","category":"type"},{"location":"#QuantumPropagators.cheby!","page":"Home","title":"QuantumPropagators.cheby!","text":"Evaluate Ψ = exp(-i H dt) Ψ in-place.\n\nArgs:\n\nΨ: on input, initial vector. Will be overwritten with result.\nH: Hermitian operator\ndt: time step\nE_min: minimum eigenvalue of H, to be used instead of the E_min from the  initialization of wrk. The same wrk may be used for different values  E_min, as long as the spectra radius Δ and the time step dt are the  same as those used for the initialization of wrk.\n\nThe routine will not allocate any internal storage. This implementation requires copyto! lmul!, and axpy! to be implemented for Ψ, and the three-argument mul! for Ψ and H.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumPropagators.newton!","page":"Home","title":"QuantumPropagators.newton!","text":"newton!(Ψ, H, dt, wrk, func=(z -> exp(-1im*z)); norm_min=1e-14, relerr=1e-12,\n        max_restarts=50)\n\nEvaluate Ψ = func(H*dt) Ψ using a Newton-with-restarted-Arnoldi scheme.\n\nArguments\n\nΨ: The state to propagate, will be overwritten in-place with the propagated state\nH: Operator acting on Ψ. Together with dt, this is the argument to func\ndt: Implicit time step. Together with H, this is the argument to func\nwkr: Work array, initialized with NewtonWrk\nfunc: The function to apply to H dt, taking a single (scalar) complex-valued argument z in place of H dt. The default func is to evaluate the time evoluation operator for the Schrödinger equation\nnorm_min: the minium norm at which to consider a state similar to Ψ as zero\nrelerr: The relative error defining the convergence condition for the restart iteration. Propagation stops when the norm of the accumulated Ψ is stable up to the given relative error\nmax_restart: The maximum number of restart iterations. Exceeding max_restart will throw an AssertionError.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumPropagators.expprop!","page":"Home","title":"QuantumPropagators.expprop!","text":"expprop!(Ψ, H, dt, wrk, func=(z -> exp(-1im*z)))\n\nEvaluate Ψ = func(H*dt) Ψ by directly evaluating U = func(H*dt), i.e. by matrix exponentiation for the default func, and then multiplying U and Ψ in-place with mul!.\n\nThe workspace wrk must be initialized with ExpPropWrk to provide storage for a temporary state.\n\n\n\n\n\n","category":"function"},{"location":"#Storage","page":"Home","title":"Storage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"init_storage\nwrite_to_storage!\nget_from_storage!\nmap_observable\nmap_observables","category":"page"},{"location":"#QuantumPropagators.init_storage","page":"Home","title":"QuantumPropagators.init_storage","text":"Create a storage array for propagate.\n\nstorage = init_storage(state, tlist)\n\ncreates a storage array suitable for storing a state for each point in tlist.\n\nstorage = init_storage(state, tlist, observables))\n\ncreates a storage array suitable for the data generated by the observables applied to state, see map_observables, for each point in tlist.\n\nstorage = init_storage(data, nt))\n\ncreates a storage arrays suitable for storing data nt times, where nt=length(tlist). By default, this will be a vector of typeof(data) and length nt, or a n × nt Matrix with the same eltype as data if data is a Vector of length n.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumPropagators.write_to_storage!","page":"Home","title":"QuantumPropagators.write_to_storage!","text":"Place data into storage for time slot i.\n\n    write_to_storage!(storage, i, state, observables)\n\nFor a storage array created by init_storage, store the data obtains from map_observables into the storage for time slot i. This delegates to the more general\n\n    write_to_storage!(storage, i, data)\n\nConceptually, this corresponds roughly to storage[i] = data, but storage may have its own idea on how to store data for a specific time slot. For example, with the default init_storage Vector data will be stored in a matrix, and write_to_storage! will in this case write data to the i'th column of the matrix.\n\nFor a given type of storage and data, it is the developer's responsibility that init_storage and write_to_storage! are compatible.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumPropagators.get_from_storage!","page":"Home","title":"QuantumPropagators.get_from_storage!","text":"Obtain data from storage\n\nget_from_storage!(state, storage, i)\n\nextracts data from the storage for the i'th time slot. Invese of write_to_storage!\n\n\n\n\n\n","category":"function"},{"location":"#QuantumPropagators.map_observable","page":"Home","title":"QuantumPropagators.map_observable","text":"Apply a single observable to state.\n\ndata = map_observable(observable, state)\n\nBy default, observable is assumed to be callable, and the above is equivalent to data = observable(state).\n\nIf observable is a matrix and state is a vector evaluate the expectation value of the observable as dot(state, observable, state).\n\n\n\n\n\n","category":"function"},{"location":"#QuantumPropagators.map_observables","page":"Home","title":"QuantumPropagators.map_observables","text":"Obtain \"observable\" data from state.\n\ndata = map_observables(observables, state)\n\ncalculates the data for a tuple of observables applied to state. For a single observable (tuple of length 1), simply return the result of map_observable.\n\nFor multiple observables, return the tuple resulting from applying map_observable for each observable. If the tuple is \"uniform\" (all elements are of the same type, e.g. if each observable calculates the expectation value of a Hermitian operator), it is converted to a Vector. This allows for compact storage in a storage array, see init_storage.\n\n\n\n\n\n","category":"function"},{"location":"#Optimization","page":"Home","title":"Optimization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"optimize_pulses","category":"page"},{"location":"#Krotov.optimize_pulses","page":"Home","title":"Krotov.optimize_pulses","text":"Use Krotov's method to optimize the given optimization problem.\n\nresult = optimize_pulses(problem)\n\noptimizes the control problem, see QuantumControlBase.ControlProblem.\n\nParameters are taken from the keyword arguments used in the instantiation of problem.\n\nRequired problem keyword arguments\n\nThe optimization functional is given implicitly via the mandatory problem keyword argument chi.\n\nOptional problem keyword arguments\n\nThe following problem keyword arguments are supported (with default values):\n\nsigma=nothing: Function that calculate the second-order contribution. If  not given, the first-order Krotov method is used.\niter_start=0: the initial iteration number\niter_stop=5000: the maximum iteration number\ncheck_convergence: a function to check whether convergence has been reached. Receives a KrotovResult object result, and should set result.converged to true and result.message to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with ∘.\nprop_method=:auto: The propagation method to use\n\n\n\n\n\n","category":"function"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}

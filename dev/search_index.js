var documenterSearchIndex = {"docs":
[{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"EditURL = \"../../generate_api.jl\"","category":"page"},{"location":"api/quantum_control_base/#QuantumControlBasePackage","page":"QuantumControlBase","title":"QuantumControlBase Package","text":"","category":"section"},{"location":"api/quantum_control_base/#Index","page":"QuantumControlBase","title":"Index","text":"","category":"section"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"gdeftgttexttgt gdeftroperatornametr gdefReoperatornameRe gdefImoperatornameIm","category":"page"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"Pages   = [\"quantum_control_base.md\"]","category":"page"},{"location":"api/quantum_control_base/#QuantumControlBaseAPI","page":"QuantumControlBase","title":"QuantumControlBase","text":"","category":"section"},{"location":"api/quantum_control_base/#Public","page":"QuantumControlBase","title":"Public","text":"","category":"section"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"@optimize_or_load\nControlProblem\nMinimalObjective\nObjective\nWeightedObjective\nchain_infohooks\ndefault_optimization_savename_kwargs\nliouvillian\nload_optimization\noptimization_savename\noptimize\npropagate_objective\npropagate_objectives","category":"page"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"QuantumControlBase.@optimize_or_load\nQuantumControlBase.ControlProblem\nQuantumControlBase.MinimalObjective\nQuantumControlBase.Objective\nQuantumControlBase.WeightedObjective\nQuantumControlBase.chain_infohooks\nQuantumControlBase.default_optimization_savename_kwargs\nQuantumControlBase.liouvillian\nQuantumControlBase.load_optimization\nQuantumControlBase.optimization_savename\nQuantumControlBase.optimize\nQuantumControlBase.propagate_objective\nQuantumControlBase.propagate_objectives","category":"page"},{"location":"api/quantum_control_base/#QuantumControlBase.@optimize_or_load","page":"QuantumControlBase","title":"QuantumControlBase.@optimize_or_load","text":"Run optimize and store the result, or load the result if it exists.\n\nresult, file = @optimize_or_load(\n    path=\"\",\n    problem;\n    method=<method>,\n    filename=nothing,\n    suffix=\"jld2\",\n    prefix=DrWatson.default_prefix(config),\n    tag=DrWatson.readenv(\"DRWATSON_TAG\", true),\n    gitpath=DrWatson.projectdir(),\n    storepatch::Bool=DrWatson.readenv(\"DRWATSON_STOREPATCH\", false),\n    force=false,\n    verbose=true,\n    wsave_kwargs=Dict(),\n    savename_kwargs=DEFAULT_OPTIMIZATION_SAVENAME_KWARGS,\n    metadata=nothing,\n    dry_run=false,\n    kwargs...\n)\n\nruns result = optimize(problem; method=<method>, kwargs...) and stores result in an automatically named file inside path. The automatic file name is determined by optimization_savename and can be overriden by passing an explicit filename. The full path to the output file (joinpath(path, filename)) is returned as file.\n\nIn addition to the result, the data in the output file may also contain some metadata, e.g. (automatically) \"gitcommit\" containing the git commit hash of the project the produced the file, and \"script\" with the file name and line number where @optimize_or_load was called, see load_optimization. If metadata is given as a dict on input, the data it contains will be included in the output file.\n\nIf file already exists (and force=false), load the result from that file instead of running the optimization.\n\nIf dry_run=true, return (nothing, file). Depending on verbose, this will print information about whether file would be loaded or generated.\n\nThe @optimize_or_load macro is intended to integrate well with the DrWatson framework for scientific projects and utilizes several configuration options and utility functions from DrWatson, see below. Note that even though DrWatson is recomended, you are not required to use if for your projects in order to use @optimize_or_load or any other part of QuantumControl.\n\nI/O Keywords\n\nThe following keyword arguments determine where the result is stored and in which format.\n\nfilename: A file name to override the automatic file name. The filename  should not contain slashes: use path for the folder where filename  should be created.\nsuffix, prefix, savename_kwargs: Parameters for optimization_savename, which determines the automatic file name\ntag: Whether to record the current \"gitcommit\" as metadata alongside the  optimization result, via  DrWatson.tagsave.  If not given explicitly, determine automatically from suffix or the  extension of filename.\ngitpath, storepatch: Passed to DrWatson.tagsave if tag is true.\nforce: If true, run and store the optimization regardless of whether file already exists.\nverbose: If true, print info about the process, if file does not exist.\nwsave_kwargs: Additional keyword arguments to pass to DrWatson.wsave, e.g., to enable compression\n\nAll other keyword arguments are passed directly to optimize.\n\nRelated Functions\n\noptimization_savename: Function that determines the automatic filename\nDrWatson.@produce_or_load: The lower-level backend implementing the functionality of @optimize_or_load.\nload_optimization: Function to load a file produced by @optimize_or_load\n\n\n\n\n\n","category":"macro"},{"location":"api/quantum_control_base/#QuantumControlBase.ControlProblem","page":"QuantumControlBase","title":"QuantumControlBase.ControlProblem","text":"A full control problem with multiple objectives.\n\nControlProblem(\n   objectives=<list of objectives>,\n   pulse_options=<dict of controls to pulse options>,\n   tlist=<time grid>,\n   kwargs...\n)\n\nNote that the control problem can only be instantiated via keyword arguments.\n\nThe objectives are a list of AbstractControlObjective instances, each defining an initial state and a dynamical generator for the evolution of that state. Usually, the objective will also include a target state (see Objective) and possibly a weight (see WeightedObjective).\n\nThe pulse_options are a dictionary (IdDict) mapping controls that occur in the objectives to properties specific to the control method.\n\nThe tlist is the time grid on which the time evolution of the initial states of each objective should be propagated.\n\nThe remaining kwargs are keyword arguments that are passed directly to the optimal control method. These typically include e.g. the optimization functional.\n\nThe control problem is solved by finding a set of controls that simultaneously fulfill all objectives.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_control_base/#QuantumControlBase.MinimalObjective","page":"QuantumControlBase","title":"QuantumControlBase.MinimalObjective","text":"Minmal optimization objective (initial state and dynamical generator only).\n\nObjective(;\n    initial_state=<initial_state>,\n    generator=<generator>,\n)\n\ndescribes and optimization objective like the standard Objective, except for functionals that are not expressed with respect to some target_state. Having only an initial_state and a generator, this is the minimal data structure that is a valid instance of AbstractControlObjective.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_control_base/#QuantumControlBase.Objective","page":"QuantumControlBase","title":"QuantumControlBase.Objective","text":"Standard optimization objective.\n\nObjective(;\n    initial_state=<initial_state>,\n    generator=<generator>,\n    target_state=<target_state>\n)\n\ndescribes an optimization objective where the time evaluation of the given initial_state under the given generator aims towards target_state. The generator here is e.g. a time-dependent Hamiltonian or Liouvillian.\n\nThe most common control problems in quantum control, e.g. state-to-state transitions or quantum gate implementations can be expressed by simultaneously fulfilling multiple objectives of this type.\n\nNote that the objective can only be instantiated via keyword arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_control_base/#QuantumControlBase.WeightedObjective","page":"QuantumControlBase","title":"QuantumControlBase.WeightedObjective","text":"Standard optimization objective with a weight.\n\nWeightedObjective(;\n    initial_state=<initial_state>,\n    generator=<genenerator>,\n    target_state=<target_state>,\n    weight=<weight>\n)\n\ninitializes a control objective like Objective, but with an additional weight parameter (a float generally between 0 and 1) that weights the objective relative to other objectives that are part of the same control problem.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_control_base/#QuantumControlBase.chain_infohooks","page":"QuantumControlBase","title":"QuantumControlBase.chain_infohooks","text":"Combine multiple info_hook functions.\n\nchain_infohooks(funcs...)\n\ncombines funcs into a single Function that can be passes as info_hook to ControlProblem or any optimize-function.\n\nEach function in func must be a suitable info_hook by itself. This means that it should receive the optimization workspace object as its first positional parameter, then positional parameters specific to the optimization method, and then an arbitrary number of data parameters. It must return either nothing or a tuple of \"info\" objects (which will end up in the records field of the optimization result).\n\nWhen chaining infohooks, the funcs will be called in series, and the \"info\" objects will be accumulated into a single result tuple. The combined results from previous funcs will be given to the subsequent funcs as data parameters. This allows for the infohooks in the chain to communicate.\n\nThe chain will return the final combined result tuple, or nothing if all funcs return nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.default_optimization_savename_kwargs","page":"QuantumControlBase","title":"QuantumControlBase.default_optimization_savename_kwargs","text":"Set the default savename_kwargs for optimization_savename.\n\nsavename_kwargs = default_optimization_savename_kwargs(;kwargs...)\n\nsets entries in the DEFAULT_OPTIMIZATION_SAVENAME_KWARGS used in optimization_savename and thus determines the automatic name used to store optimization results.\n\nUse\n\ndefault_optimization_savename_kwargs(reset=true)\n\nto clear the settings from any previous call to default_optimization_savename_kwargs.\n\nThe following keyword arguments are supported, cf. DrWatson.savename:\n\naccesses - List of strings indicating which fields (keys in kwargs of ControlProblem or kwargs of optimize/@optimize_or_load) can be included in the output filename. By default, all fields with values matching allowedtypes (excluding anonymous functions) are used.\nallowedtypes - List of types of values eligible to be included in the filename. Defaults to [Real, String, Symbol, TimeType, Function]\nconnector - String used to separate key-value pairs in the output filename. Defaults to \"_\".\ndigits - Used in round when formatting numbers, if no custom val_to_string.\nequals - String used between keys and values. Defaults to \"=\".\nignores - List of strings indicating which fields should be ignored.\nsigdigits - Used in round when formatting numbers, if no custom val_to_string.\nsort - Whether to sort the fields alphabetically (default). If false, the resulting file name my not be stable.\nval_to_string - Function to convert values to string.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.liouvillian","page":"QuantumControlBase","title":"QuantumControlBase.liouvillian","text":"Construct a Liouvillian super-operator.\n\nℒ = liouvillian(Ĥ, c_ops=(); convention=:LvN)\n\ncalculates the sparse Liouvillian super-operator ℒ from the Hamiltonian Ĥ and a list c_ops of Lindblad operators.\n\nWith convention=:LvN, applying the resulting ℒ to a vectorized density matrix ρ⃗ calculates fracddt vecrho(t) = ℒ vecrho(t) equivalent to the Liouville-von-Neumann equation for the density matrix ρ,\n\nfracddt ρ(t)\n= -i H ρ(t) + sum_kleft(\n    A_k ρ A_k^dagger\n    - frac12 A_k^dagger A_k ρ\n    - frac12 ρ A_k^dagger A_k\n  right)\n\nwhere the Lindblad operators A_k are the elements of c_ops.\n\nThe Hamiltonian H may be time-dependent, using a nested-tuple format by default, e.g., (Ĥ₀, (H₁, ϵ₁), (H₂, ϵ₂)), where ϵ₁ and ϵ₂ are functions of time. In this case, the resulting ℒ will also be in nested tuple format, ℒ = (ℒ₀, (ℒ₁, ϵ₁), (ℒ₂, ϵ₂)), where the initial element contains the superoperator ℒ₀ for the static component of the Liouvillian, i.e., the commutator with the drift Hamiltonian Ĥ₀, plus the dissipator (sum over k), as a sparse matrix. Time-dependent Lindblad operators are not supported. The remaining elements are tuples (ℒ₁, ϵ₁) and (ℒ₂, ϵ₂) corresponding to the commutators with the two control Hamiltonians, where ℒ₁ and ℒ₂ again are sparse matrices.\n\nIf H is not time-dependent, the resulting ℒ will be a single-element tuple containing the Liouvillian as a sparse matrix, ℒ = (ℒ₀, ).\n\nWith convention=:TDSE, the Liouvillian will be constructed for the equation of motion i hbar fracddt vecrho(t) = ℒ vecrho(t) to match exactly the form of the time-dependent Schrödinger equation. While this notation is not standard in the literature of open quantum systems, it has the benefit that the resulting ℒ can be used in a numerical propagator for a (non-Hermitian) Schrödinger equation without any change. Thus, for numerical applications, convention=:TDSE is generally preferred. The returned ℒ between the two conventions differs only by a factor of i, since we generally assume hbar=1.\n\nThe convention keyword argument is mandatory, to force a conscious choice.\n\nSee Goerz et. al. \"Optimal control theory for a unitary operation under dissipative evolution\", arXiv 1312.0111v2, Appendix B.2 for the explicit construction of the Liouvillian superoperator as a sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.load_optimization","page":"QuantumControlBase","title":"QuantumControlBase.load_optimization","text":"Load a previously stored optimization.\n\nresult = load_optimization(filename; verbose=true, kwargs...)\n\nrecovers a result previously stored by @optimize_or_load.\n\nresult, metadata = load_optimization(filename; return_metadata=true, kwargs...)\n\nalso obtains a metadata dict containing e.g., \"gitcommit\" or \"script\" depending on the options to @optimize_or_load.\n\nCalling load_optimization with verbose=true (default) will show the metadata after loading the file.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.optimization_savename","page":"QuantumControlBase","title":"QuantumControlBase.optimization_savename","text":"Determine an automatic filename for storing an optimization result.\n\nfile = optimization_savename(\n    path=\"\",\n    problem;\n    method=<method>,\n    suffix=\"jld2\",\n    prefix=\"\",\n    savename_kwargs=DEFAULT_OPTIMIZATION_SAVENAME_KWARGS,\n    kwargs...,\n)\n\nfinds an appropriate automatic filename for the result of optimize(problem; method=<method>, kwargs...).\n\nBy default, the file has the structure <path>/<prefix>_<key1>=<value1>_..._<keyN>=<valueN>_method=<method>.jld2 where the key-value pairs are a subset of the keyword arguments used to instantiate problem, respectively the keyword arguments in kwargs. The prefix is best used as a \"name\" for the optimization problem to ensure a unique file name.\n\nWhich key-value pairs that are taken into account and the way they are formatted can be customized via savename_kwargs. See default_optimization_savename_kwargs for the supported options.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.optimize","page":"QuantumControlBase","title":"QuantumControlBase.optimize","text":"Optimize a quantum control problem.\n\nopt_result = optimize(problem; method=<method>, kwargs...)\n\noptimizes towards a solution of given problem with the given optimization method. Any keyword argument temporarily overrides the corresponding keyword argument in problem.\n\n\n\n\n\nopt_result = optimize(problem; method=:krotov, kwargs...)\n\noptimizes problem using Krotov's method, see Krotov.optimize_krotov.\n\n\n\n\n\nopt_result = optimize(problem; method=:GRAPE, kwargs...)\n\noptimizes problem using GRadident Ascent Pulse Engineering (GRAPE), see GRAPE.optimize_grape.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.propagate_objective","page":"QuantumControlBase","title":"QuantumControlBase.propagate_objective","text":"Propagate with the dynamical generator of a control objective.\n\npropagate_objective(obj, tlist; method=:auto, initial_state=obj.initial_state,\n                    controls_map=IdDict(), kwargs...)\n\npropagates initial_state under the dynamics described by obj.generator.\n\nThe optional dict control_map may be given to replace the controls in obj.generator (as obtained by getcontrols) with custom functions or vectors, e.g. with the controls resulting from optimization, see also substitute_controls.\n\nIf obj has a property/field prop_method or fw_prop_method, its value will be used as the default for method instead of :auto. An explicit keyword argument for method always overrides the default.\n\nAll other kwargs are forwarded to the underlying QuantumPropagators.propagate method for obj.initial_state.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.propagate_objectives","page":"QuantumControlBase","title":"QuantumControlBase.propagate_objectives","text":"Propagate multiple objectives in parallel.\n\nresult = propagate_objectives(objectives, tlist; use_threads=true, kwargs...)\n\nruns propagate_objective for every objective in objectives, collects and returns a vector of results. The propagation happens in parallel if use_threads=true (default). All keyword parameters are passed to propagate_objective, except that if initial_state is given, it must be a vector of initial states, one for each objective. Likewise, to pass pre-allocated storage arrays to storage, a vector of storage arrays must be passed. A simple storage=true will still work to return a vector of storage results.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#Private","page":"QuantumControlBase","title":"Private","text":"","category":"section"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"resetgradvec!\nAbstractControlObjective\nGradVector\nGradGenerator\nTimeDependentGradGenerator","category":"page"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"QuantumControlBase.resetgradvec!\nQuantumControlBase.AbstractControlObjective\nQuantumControlBase.GradVector\nQuantumControlBase.GradGenerator\nQuantumControlBase.TimeDependentGradGenerator","category":"page"},{"location":"api/quantum_control_base/#QuantumControlBase.resetgradvec!","page":"QuantumControlBase","title":"QuantumControlBase.resetgradvec!","text":"Reset the given gradient vector for a new gradient evaluation.\n\nresetgradvec!(Ψ̃::GradVector)\n\nzeroes out Ψ̃.grad_states but leaves Ψ̃.state unaffected.\n\nresetgradvec!(Ψ̃::GradVector, Ψ)\n\nadditionally sets Ψ̃.state to Ψ.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.AbstractControlObjective","page":"QuantumControlBase","title":"QuantumControlBase.AbstractControlObjective","text":"Base class for a single optimization objective.\n\nAll objectives must have a field initial_state and a field generator, at minimum. Also, objectives must be able to be instantiated via keyword arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_control_base/#QuantumControlBase.GradVector","page":"QuantumControlBase","title":"QuantumControlBase.GradVector","text":"Extended state-vector for the dynamic gradient.\n\nΨ̃ = GradVector(Ψ, num_controls)\n\nfor an initial state Ψ and num_controls control fields.\n\nThe GradVector conceptually corresponds to a direct-sum (block) column-vector Ψ = (Ψ₁ Ψ₂  Ψₙ Ψ)^T, where n is num_controls. With a matching G as in the documentation of TimeDependentGradGenerator, we have\n\nG Ψ = beginpmatrix\nH Ψ₁ + H₁Ψ \nvdots \nH Ψₙ + HₙΨ \nH Ψ\nendpmatrix\n\nand\n\ne^-i G dt beginpmatrix 0  vdots  0  Ψ endpmatrix\n= beginpmatrix\nfracϵ₁ e^-i H dt Ψ \nvdots \nfracϵₙ e^-i H dt Ψ \ne^-i H dt Ψ\nendpmatrix\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_control_base/#QuantumControlBase.GradGenerator","page":"QuantumControlBase","title":"QuantumControlBase.GradGenerator","text":"Static generator for the standard dynamic gradient.\n\nG::GradGenerator = evalcontrols(G_of_t::TimeDependentGradGenerator, vals_dict)\n\nis the result of plugging in specific values for all controls in a TimeDependentGradGenerator. See evalcontrols and evalcontrols!.\n\nThe resulting object can be multiplied directly with a GradVector, e.g., in the process of evaluating a piecewise-constant time propagation.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_control_base/#QuantumControlBase.TimeDependentGradGenerator","page":"QuantumControlBase","title":"QuantumControlBase.TimeDependentGradGenerator","text":"Extended generator for the standard dynamic gradient.\n\nG̃ = TimeDependentGradGenerator(G)\n\ncontains the original time-dependent generator G (a Hamiltonian or Liouvillian) in G̃.G, a vector of control derivatives Gϵₗ(t) in G̃.control_derivs, and the controls in G̃.controls.\n\nFor a generator G = H(t) = H₀ + ϵ₁(t) H₁ +  +  ϵₙ(t) Hₙ, this extended generator encodes the block-matrix\n\nG = beginpmatrix\n         H(t)    0      dots     0       H₁     \n         0       H(t)   dots     0       H₂     \n    vdots              ddots            vdots \n         0       0      dots     H(t)    Hₙ     \n         0       0      dots     0       H(t)\nendpmatrix\n\nNote that the Gϵₗ(t) (Hₗ in the above example) are functions, to account for the possibility of non-linear control terms, see getcontrolderiv.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_control_base/#QuantumControlBaseConditionalThreadsAPI","page":"QuantumControlBase","title":"QuantumControlBase.ConditionalThreads","text":"","category":"section"},{"location":"api/quantum_control_base/#Private-2","page":"QuantumControlBase","title":"Private","text":"","category":"section"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"@threadsif","category":"page"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"QuantumControlBase.ConditionalThreads.@threadsif","category":"page"},{"location":"api/quantum_control_base/#QuantumControlBase.ConditionalThreads.@threadsif","page":"QuantumControlBase","title":"QuantumControlBase.ConditionalThreads.@threadsif","text":"Conditionally apply multi-threading to for loops.\n\nThis is a variation on Base.Threads.@threads that adds a run-time boolean flag to enable or disable threading. It is intended for internal use in packages building on QuantumControlBase.\n\nUsage:\n\nusing QuantumControlBase.ConditionalThreads: @threadsif\n\nfunction optimize(objectives; use_threads=true)\n    @threadsif use_threads for k = 1:length(objectives)\n    # ...\n    end\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/quantum_control_base/#QuantumControlBaseFunctionalsAPI","page":"QuantumControlBase","title":"QuantumControlBase.Functionals","text":"","category":"section"},{"location":"api/quantum_control_base/#Public-2","page":"QuantumControlBase","title":"Public","text":"","category":"section"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"J_T_re\nJ_T_sm\nJ_T_ss\ngate_functional\nmake_chi\nmake_gate_chi\nmake_gradient","category":"page"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"QuantumControlBase.Functionals.J_T_re\nQuantumControlBase.Functionals.J_T_sm\nQuantumControlBase.Functionals.J_T_ss\nQuantumControlBase.Functionals.gate_functional\nQuantumControlBase.Functionals.make_chi\nQuantumControlBase.Functionals.make_gate_chi\nQuantumControlBase.Functionals.make_gradient","category":"page"},{"location":"api/quantum_control_base/#QuantumControlBase.Functionals.J_T_re","page":"QuantumControlBase","title":"QuantumControlBase.Functionals.J_T_re","text":"Real-part functional.\n\nJ_T_re(ϕ, objectives; τ=nothing)\n\ncalculates\n\nJ_Ttextre = 1 - F_textre quadin begincases\n    0 2  textin Hilbert space \n    0 1  textin Liouville space\nendcases\n\nAll arguments are passed to f_tau while evaluating F_textre in F_re.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.Functionals.J_T_sm","page":"QuantumControlBase","title":"QuantumControlBase.Functionals.J_T_sm","text":"Square-modulus functional.\n\nJ_T_sm(ϕ, objectives; τ=nothing)\n\ncalculates\n\nJ_Ttextsm = 1 - F_textsm quadin 0 1\n\nAll arguments are passed to f_tau while evaluating F_textsm in F_sm.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.Functionals.J_T_ss","page":"QuantumControlBase","title":"QuantumControlBase.Functionals.J_T_ss","text":"State-to-state phase-insensitive functional.\n\nJ_T_ss(ϕ, objectives; τ=nothing)\n\ncalculates\n\nJ_Ttextss = 1 - F_textss in 0 1\n\nAll arguments are passed to F_ss.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.Functionals.gate_functional","page":"QuantumControlBase","title":"QuantumControlBase.Functionals.gate_functional","text":"Convert a functional from acting on a gate to acting on propagated states.\n\nJ_T = gate_functional(J_T_U; kwargs...)\n\nconstructs a functional J_T that meets the requirements for make_gradient and make_chi. That is, the output J_T takes positional positional arguments ϕ and objectives. The input functional J_T_U is assumed to have the signature J_T_U(U; kwargs...) where U is a matrix with elements U_ij = Ψ_iϕ_j, where Ψ_i is the initial_state of the i'th objectives (assumed to be the i'th canonical basis state) and ϕ_j is the result of forward-propagating Ψ_j. That is, U is the projection of the time evolution operator into the subspace defined by the basis in the initial_states of the  objectives.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.Functionals.make_chi","page":"QuantumControlBase","title":"QuantumControlBase.Functionals.make_chi","text":"Return a function that evaluates χ_k = -J_Tϕ_k.\n\nchi! = make_chi(J_T, objectives; force_zygote=false)\n\ncreates a function chi!(χ, ϕ, objectives; τ=nothing) that sets χ_k = -J_Tϕ_k. This is the state used as the boundary condition for the backward propagation propagation in Krotov's method, as well as GRAPE if grad_J_T_via_chi! is used. It is defined as a Wirtinger derivative, see make_gradient.\n\nThe function J_T must take a vector of states ϕ and a vector of objectives as positional parameters, and a vector τ as a keyword argument, see e.g. J_T_sm. If all objectives define a target_state, then τ will be the overlap of the states ϕ with those target states. The functional J_T may or may not use those overlaps. Likewise, the resulting chi! may or may not use the keyword parameter τ.\n\nFor functionals where -J_Tϕ_k is known analytically, that analytic derivative will be returned, e.g.,\n\nJ_T_sm → chi_sm!,\nJ_T_re → chi_re!,\nJ_T_ss → chi_ss!.\n\nOtherwise, or if force_zygote=true, automatic differentiation via Zygote is used to calculate the derivative directly from J_T.\n\ntip: Tip\nIn order to extend make_chi with an analytic implementation for a new J_T function, define a new method make_analytic_chi like so:make_analytic_chi(::typeof(J_T_sm), objectives) = chi_sm!which links make_chi for J_T_sm to chi_sm!.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.Functionals.make_gate_chi","page":"QuantumControlBase","title":"QuantumControlBase.Functionals.make_gate_chi","text":"Return a function to evaluate χ_k = -J_T(U)ϕ_k via the chain rule.\n\nchi! = make_gate_chi(J_T_U, objectives; use_finite_differences=false, kwargs...)\n\nreturns a function equivalent to\n\nchi! = make_chi(gate_functional(J_T_U; kwargs...), objectives)\n\nbeginsplit\n    χ_k\n    = -fracϕ_k J_T \n    = - frac12 sum_i (_U J_T)_ik frac U_ikϕ_k \n    = - frac12 sum_i (_U J_T)_ik Ψ_i\nendsplit\n\nwhere Ψ_i is the basis state stored as the initial_state of the i'th objective, see gate_functional.\n\nThe gradient _U J_T is obtained via automatic differentiation, or via finite differences if use_finite_differences=true.\n\nCompared to the more general make_chi, make_gate_chi will generally have a slightly smaller numerical overhead, as it pushes the use of automatic differentiation down by one level.\n\nWith use_finite_differences=true, this routine serves to test and debug gradients for gate functionals obtained by automatic differentiation.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.Functionals.make_gradient","page":"QuantumControlBase","title":"QuantumControlBase.Functionals.make_gradient","text":"Return a function that evaluates the gradient J_T.\n\ngrad_func! = make_gradient(J_T, objectives; via=:tau, force_zygote=false)\n\ncreates a function gradfunc!(∇J_T, τ, ∇τ) that takes a vector τ of values τ_k and a vector ∇τ of gradients τ_k where the (ln)'th element of τ_k is τ_kϵ_ln, and writes the element (ln) of the gradient ∇J_T as J_Tϵ_ln. The definition of τ_k depends on via, see below. The ϵ_ln are the values of the control control field discretized to the midpoints of a time grid. The index l numbers the control and n numbers the time slice. The gradient (like the controls) are assumed to be vectorized. That is, J_T is a vector of values with a double-index (ln).\n\nThe passed J_T parameter corresponding to the functional J_T must be a function that takes a vector of forward-propagates states ϕ and a vector of objectives as positional parameters.  It must also accept a vector τ as a keyword argument, which contains the overlaps of the states in ϕ and the target_state fields of the objectives. If the objectices do not define target_states, or if the τ-values are not available, J_T must accept τ=nothing. See J_T_sm for an example.\n\nGradient via τ\n\nFor via=:tau (default), we define\n\nτ_k  ϕ_k^tgtϕ_k(T)\n\nas the overlap of ϕ_k(T) resulting from the forward propagation of the initial_state ϕ_k  of the k'th objective under the pulse values ϵ_ln, and ϕ_k^tgt as the target_state of the k'th objective.\n\nWe then understand J_T as a function of the τ_k, and evaluate the elements of J_T via the chain rule:\n\n(J_T)_ln  fracJ_T(τ_k)ϵ_ln\n= 2Resum_k\n    fracJ_Tτ_k\n    fracτ_kϵ_ln\n\nSince the τ_k are complex numbers,\n\nfracJ_Tτ_k = frac12left(\n    frac J_T Reτ_k\n    - i frac J_T Imτ_k\nright)\n\nis defined as the Wirtinger derivative, and\n\nfracτ_kϵ_ln = fracReτ_kϵ_ln + i fracImτ_kϵ_ln\n\nis simply the derivative of a complex number with respect to the real-valued ϵ_ln.\n\nThus, the returned grad_func! effectively encodes the outer derivative J_Tτ_k. For functionals where that derivative is known analytically, the analytic expression is used, e.g., J_T_sm → grad_J_T_sm!.\n\nOtherwise, or if force_zygote=true, the outer derivative is determined directly from J_T, via automatic differentiation (using Zygote).\n\nGradient via χ\n\nFor via=:chi, the functional J_T is understood directly as a function of the forward-propagated states ϕ_k instead of a function of overlaps with the target states. This is useful in particular if the objectives do not define objectives and/or the functional J_T cannot be expressed in terms of overlaps.\n\nAgain we apply a chain rule to calculate the elements of the gradient J_T:\n\nbeginsplit\n(J_T)_ln  fracJ_T(ϕ_k(T))ϵ_ln\n= 2Resum_k\n    fracJ_Tϕ_k(T)\n    fracϕ_k(T)ϵ_ln \n= -2 Re sum_k fracϵ_ln χ_k(T)ϕ_k(T)\nendsplit\n\nwith\n\nχ_k\n= -fracJ_Tϕ_k(T)\n= -frac12left(\n    leftvert fracJ_TReϕ_k rightrangle\n    + i leftvert fracJ_TImϕ_k rightrangle\n    right)\n\nas a matrix-calculus extension of the Wirtinger derivative. This definition of χ_k (note the minus sign!) matches the definition of the boundary condition in Krotov's method, and for a given functional J_T, the states χ_k can be obtained with make_chi.\n\nWe define\n\nτ_k  χ_k(T)ϕ_k(T)\n\nand associate the gradfunc! argument ∇τ[k][l, n] with\n\n(τ_k)_ln = fracτ_k ϵ_ln\n\nso that structurally, (J_T)_ln is the same as for via=:tau, just that τ_k is now defined with respect to the boundary condition state χ_k instead of the target state ϕ_k^tgt.\n\nThe returned grad_func! that encodes the above equations is grad_J_T_via_chi!. This is independent of J_T, since the dependency on the functional J_T is entirely encoded in the states χ_k(T), and thus the gradient ∇τ. Also, force_zygote=true has no effect for via=:chi. Instead, force_zygote should be passed to the underlying make_chi.\n\ntip: Tip\nIn order to extend make_gradient with an analytic implementation for a new J_T function, define a new method like so:make_gradient(::typeof(J_T_sm), objectives, via::Val{:tau}) = grad_J_T_sm!which links make_gradient for J_T_sm to grad_J_T_sm!.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#Private-3","page":"QuantumControlBase","title":"Private","text":"","category":"section"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"grad_J_T_via_chi!\nF_re\ngrad_J_T_sm!\nf_tau\nF_ss\nchi_ss!\nF_sm\nchi_re!\nchi_sm!","category":"page"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"QuantumControlBase.Functionals.grad_J_T_via_chi!\nQuantumControlBase.Functionals.F_re\nQuantumControlBase.Functionals.grad_J_T_sm!\nQuantumControlBase.Functionals.f_tau\nQuantumControlBase.Functionals.F_ss\nQuantumControlBase.Functionals.chi_ss!\nQuantumControlBase.Functionals.F_sm\nQuantumControlBase.Functionals.chi_re!\nQuantumControlBase.Functionals.chi_sm!","category":"page"},{"location":"api/quantum_control_base/#QuantumControlBase.Functionals.grad_J_T_via_chi!","page":"QuantumControlBase","title":"QuantumControlBase.Functionals.grad_J_T_via_chi!","text":"Gradient for an arbitrary functional evaluated via χ-states.\n\ngrad_J_T_via_chi!(∇J_T, τ, ∇τ)\n\nsets the (vectorized) elements of the gradient ∇J_T to the gradient J_Tϵ_ln for an arbitrary functional J_T=J_T(ϕ_k(T)), under the assumption that\n\nbeginaligned\n    τ_k = χ_kϕ_k(T) quad textwith quad χ_k = -J_Tϕ_k(T)\n    quad textand \n    τ_kln = τ_kϵ_ln\nendaligned\n\nwhere ϕ_k(T) is a state resulting from the forward propagation of some initial state ϕ_k under the pulse values ϵ_ln where l numbers the controls and n numbers the time slices. The τ_k are the elements of τ and τ_kln corresponds to ∇τ[k][l, n].\n\nIn this case,\n\n(J_T)_ln = J_Tϵ_ln = -2 Re sum_k τ_kln\n\nsee make_gradient.\n\nNote that the definition of the χ_k matches exactly the definition of the boundary condition for the backward propagation in Krotov's method, see make_chi. Specifically, there is a minus sign in front of the derivative, compensated by the minus sign in the factor (-2) of the final (J_T)_ln.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.Functionals.F_re","page":"QuantumControlBase","title":"QuantumControlBase.Functionals.F_re","text":"Real-part fidelity.\n\nF_re(ϕ, objectives; τ=nothing)\n\ncalculates\n\nF_textre = Ref_τ quadin begincases\n    -1 1  textin Hilbert space \n    0 1  textin Liouville space\nendcases\n\nAll arguments are passed to f_tau to evaluate f_τ.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.Functionals.grad_J_T_sm!","page":"QuantumControlBase","title":"QuantumControlBase.Functionals.grad_J_T_sm!","text":"Gradient for J_T_sm.\n\ngrad_J_T_sm!(∇J_T, τ, ∇τ)\n\nanalytically sets the elements of the gradient ∇J_T according to\n\nfrac J_Ttextsm(τ_k)partial ϵ_ln\n= frac1N^2 sum_k=1^N sum_k=1^Nleft\n        fracpartial τ_k^*ϵ_ln τ_k +\n        τ_k^* fracpartial τ_k^*ϵ_ln\n   right\n= -frac2N Re sum_k=1^N sum_k=1^N\n  τ_k^* fracτ_kpartial ϵ_ln\n\nwith all quantities as defined in make_gradient.\n\nNote: this function can be obtained with make_gradient(J_T_sm, objectives, via=:tau).\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.Functionals.f_tau","page":"QuantumControlBase","title":"QuantumControlBase.Functionals.f_tau","text":"Average complex overlap of the target states with forward-propagated states.\n\nf_tau(ϕ, objectives; τ=nothing)\n\ncalculates\n\nf_τ = frac1N sum_k=1^N w_k τ_k\n\nwith\n\nτ_k = ϕ_k^tgtϕ_k(T)\n\nin Hilbert space, or\n\nτ_k = trρ_k^tgtdagger ρ_k(T)\n\nin Liouville space, where ϕ_k or ρ_k are the elements of ϕ, and ϕ_k^tgt or ρ_k^tgt are the target states from the target_state field of the objectives. If τ is given as a keyword argument, it must contain the values τ_k according to the above definition. Otherwise, the τ_k values will be calculated internally.\n\nN is the number of objectives, and w_k is an optional weight for each objective. For any objective that has a weight attribute (cf. WeightedObjective), the w_k is taken from that attribute; otherwise, w_k = 1. The weights, if present, are not automatically normalized, they are assumed to have values such that the resulting f_τ lies in the unit circle of the complex plane. Usually, this means that the weights should sum to N.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.Functionals.F_ss","page":"QuantumControlBase","title":"QuantumControlBase.Functionals.F_ss","text":"State-to-state phase-insensitive fidelity.\n\nF_ss(ϕ, objectives; τ=nothing)\n\ncalculates\n\nF_textss = frac1N sum_k=1^N w_k τ_k^2 quadin 0 1\n\nwith N, w_k and τ_k as in f_tau.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.Functionals.chi_ss!","page":"QuantumControlBase","title":"QuantumControlBase.Functionals.chi_ss!","text":"Krotov-states χ for functional J_T_ss.\n\nchi_ss!(χ, ϕ, objectives; τ=nothing)\n\nsets the elements of χ according to\n\nχ_k\n= -frac J_Ttextss ϕ_k(T)\n= frac1N w_k τ_k ϕ^tgt_k\n\nwith ϕ^tgt_k, τ_k and w_k as defined in f_tau.\n\nNote: this function can be obtained with make_chi(J_T_ss, objectives).\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.Functionals.F_sm","page":"QuantumControlBase","title":"QuantumControlBase.Functionals.F_sm","text":"Square-modulus fidelity.\n\nF_sm(ϕ, objectives; τ=nothing)\n\ncalculates\n\nF_textsm = f_τ^2  quadin 0 1\n\nAll arguments are passed to f_tau to evaluate f_τ.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.Functionals.chi_re!","page":"QuantumControlBase","title":"QuantumControlBase.Functionals.chi_re!","text":"Krotov-states χ for functional J_T_re.\n\nchi_re!(χ, ϕ, objectives; τ=nothing)\n\nsets the elements of χ according to\n\nχ_k\n= -frac J_Ttextre ϕ_k(T)\n= frac12N w_k ϕ^tgt_k\n\nwith ϕ^tgt_k and w_k as defined in f_tau.\n\nNote: this function can be obtained with make_chi(J_T_re, objectives).\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.Functionals.chi_sm!","page":"QuantumControlBase","title":"QuantumControlBase.Functionals.chi_sm!","text":"Krotov-states χ for functional J_T_sm.\n\nchi_sm!(χ, ϕ, objectives; τ=nothing)\n\nsets the elements of χ according to\n\nχ_k\n= -fracpartial J_Ttextsmpartial ϕ_k(T)\n= frac1N^2 w_k sum_j^N w_j τ_j ϕ_k^tgt\n\nwith ϕ^tgt_k, τ_j and w_k as defined in f_tau.\n\nNote: this function can be obtained with make_chi(J_T_sm, objectives).\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBaseShapesAPI","page":"QuantumControlBase","title":"QuantumControlBase.Shapes","text":"","category":"section"},{"location":"api/quantum_control_base/#Public-3","page":"QuantumControlBase","title":"Public","text":"","category":"section"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"blackman\nbox\nflattop","category":"page"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"QuantumControlBase.Shapes.blackman\nQuantumControlBase.Shapes.box\nQuantumControlBase.Shapes.flattop","category":"page"},{"location":"api/quantum_control_base/#QuantumControlBase.Shapes.blackman","page":"QuantumControlBase","title":"QuantumControlBase.Shapes.blackman","text":"Blackman window shape.\n\nblackman(t, t₀, T; a=0.16)\n\ncalculates\n\nB(t t_0 T) =\n    frac12left(\n        1 - a - cosleft(2π fract - t_0T - t_0right)\n        + a cosleft(4π fract - t_0T - t_0right)\n    right)\n\nfor a scalar t, with a = 0.16.\n\nSee http://en.wikipedia.org/wiki/Window_function#Blackman_windows\n\nA Blackman shape looks nearly identical to a Gaussian with a 6-sigma interval between t₀ and T.  Unlike the Gaussian, however, it will go exactly to zero at the edges. Thus, Blackman pulses are often preferable to Gaussians.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.Shapes.box","page":"QuantumControlBase","title":"QuantumControlBase.Shapes.box","text":"Box shape (Theta-function).\n\nbox(t, t₀, T)\n\nevaluates the Heaviside (Theta-) function Theta(t) = 1 for t_0 le t le T; and Theta(t) = 0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.Shapes.flattop","page":"QuantumControlBase","title":"QuantumControlBase.Shapes.flattop","text":"Flat shape (amplitude 1.0) with a switch-on/switch-off from zero.\n\nflattop(t; T, t_rise, t₀=0.0, t_fall=t_rise, func=:blackman)\n\nevaluates a shape function that starts at 0 at t=t₀, and ramps to to 1 during the t_rise interval. The function then remains at value 1, before ramping down to 0 again during the interval t_fall before T. For t  t₀ and t  T, the shape is zero.\n\nThe default switch-on/-off shape is half of a Blackman window (see blackman).\n\nFor func=:sinsq, the switch-on/-off shape is a sine-squared curve.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBaseTestUtilsAPI","page":"QuantumControlBase","title":"QuantumControlBase.TestUtils","text":"","category":"section"},{"location":"api/quantum_control_base/#Public-4","page":"QuantumControlBase","title":"Public","text":"","category":"section"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"dummy_control_problem\nrandom_complex_matrix\nrandom_complex_sparse_matrix\nrandom_hermitian_matrix\nrandom_hermitian_real_matrix\nrandom_hermitian_sparse_matrix\nrandom_hermitian_sparse_real_matrix\nrandom_real_matrix\nrandom_real_sparse_matrix\nrandom_state_vector\ntest","category":"page"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"QuantumControlBase.TestUtils.dummy_control_problem\nQuantumControlBase.TestUtils.random_complex_matrix\nQuantumControlBase.TestUtils.random_complex_sparse_matrix\nQuantumControlBase.TestUtils.random_hermitian_matrix\nQuantumControlBase.TestUtils.random_hermitian_real_matrix\nQuantumControlBase.TestUtils.random_hermitian_sparse_matrix\nQuantumControlBase.TestUtils.random_hermitian_sparse_real_matrix\nQuantumControlBase.TestUtils.random_real_matrix\nQuantumControlBase.TestUtils.random_real_sparse_matrix\nQuantumControlBase.TestUtils.random_state_vector\nQuantumControlBase.TestUtils.test","category":"page"},{"location":"api/quantum_control_base/#QuantumControlBase.TestUtils.dummy_control_problem","page":"QuantumControlBase","title":"QuantumControlBase.TestUtils.dummy_control_problem","text":"Set up a dummy control problem.\n\nproblem = dummy_control_problem(;\n    N=10, n_objectives=1, n_controls=1, n_steps=50, dt=1.0, sparsity=0.5,\n    complex_operators=true, hermitian=true, kwargs...)\n\nSets up a control problem with random (sparse) Hermitian matrices.\n\nArguments\n\nN: The dimension of the Hilbert space\nn_objectives: The number of objectives in the optimization. All objectives will have the same Hamiltonian, but random initial and target states.\nn_controls: The number of controls, that is, the number of control terms in the control Hamiltonian. Each control is an array of random values, normalized on the intervals of the time grid.\nn_steps: The number of time steps (intervals of the time grid)\ndt: The time step\nsparsity: The sparsity of the Hamiltonians, as a number between 0.0 and 1.0. For sparsity=1.0, the Hamiltonians will be dense matrices.\ncomplex_operators: Whether or not the drift/control operators will be complex-valued or real-valued.\nhermitian: Whether or not all drift/control operators will be Hermitian matrices.\nkwargs: All other keyword arguments are passed on to ControlProblem\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.TestUtils.random_complex_matrix","page":"QuantumControlBase","title":"QuantumControlBase.TestUtils.random_complex_matrix","text":"Construct a random complex matrix of size N×N with spectral radius ρ.\n\nrandom_complex_matrix(N, ρ)\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.TestUtils.random_complex_sparse_matrix","page":"QuantumControlBase","title":"QuantumControlBase.TestUtils.random_complex_sparse_matrix","text":"Construct a random sparse complex matrix.\n\nrandom_complex_sparse_matrix(N, ρ, sparsity)\n\nreturns a matrix of size N×N with spectral radius ρ and the given sparsity (number between zero and one that is the approximate fraction of non-zero elements).\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.TestUtils.random_hermitian_matrix","page":"QuantumControlBase","title":"QuantumControlBase.TestUtils.random_hermitian_matrix","text":"Construct a random Hermitian matrix of size N×N with spectral radius ρ.\n\nrandom_hermitian_matrix(N, ρ)\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.TestUtils.random_hermitian_real_matrix","page":"QuantumControlBase","title":"QuantumControlBase.TestUtils.random_hermitian_real_matrix","text":"Construct a random Hermitian real matrix of size N×N with spectral radius ρ.\n\nrandom_hermitian_real_matrix(N, ρ)\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.TestUtils.random_hermitian_sparse_matrix","page":"QuantumControlBase","title":"QuantumControlBase.TestUtils.random_hermitian_sparse_matrix","text":"Construct a random sparse Hermitian matrix.\n\nrandom_hermitian_sparse_matrix(N, ρ, sparsity)\n\nreturns a matrix of size N×N with spectral radius ρ and the given sparsity (number between zero and one that is the approximate fraction of non-zero elements).\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.TestUtils.random_hermitian_sparse_real_matrix","page":"QuantumControlBase","title":"QuantumControlBase.TestUtils.random_hermitian_sparse_real_matrix","text":"Construct a random sparse Hermitian real matrix.\n\nrandom_hermitian_sparse_real_matrix(N, ρ, sparsity)\n\nreturns a matrix of size N×N with spectral radius ρ and the given sparsity (number between zero and one that is the approximate fraction of non-zero elements).\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.TestUtils.random_real_matrix","page":"QuantumControlBase","title":"QuantumControlBase.TestUtils.random_real_matrix","text":"Construct a random real-valued matrix of size N×N with spectral radius ρ.\n\nrandom_real_matrix(N, ρ)\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.TestUtils.random_real_sparse_matrix","page":"QuantumControlBase","title":"QuantumControlBase.TestUtils.random_real_sparse_matrix","text":"Construct a random sparse real-valued matrix.\n\nrandom_real_sparse_matrix(N, ρ, sparsity)\n\nreturns a matrix of size N×N with spectral radius ρ and the given sparsity (number between zero and one that is the approximate fraction of non-zero elements).\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.TestUtils.random_state_vector","page":"QuantumControlBase","title":"QuantumControlBase.TestUtils.random_state_vector","text":"Return a random, normalized Hilbert space state vector of dimension N.\n\nrandom_state_vector(N)\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.TestUtils.test","page":"QuantumControlBase","title":"QuantumControlBase.TestUtils.test","text":"Run a package test-suite in a subprocess.\n\ntest(\n    file=\"test/runtests.jl\";\n    root=pwd(),\n    project=\"test\",\n    code_coverage=\"user\",\n    show_coverage=(code_coverage == \"user\"),\n    color=<inherit>,\n    compiled_modules=<inherit>,\n    startup_file=<inherit>,\n    depwarn=<inherit>,\n    inline=<inherit>,\n    check_bounds=\"yes\",\n    track_allocation=<inherit>,\n    threads=<inherit>,\n    genhtml=false,\n    covdir=\"coverage\"\n)\n\nruns the test suite of the package located at root by running include(file) inside a new julia process.\n\nThis is similar to what Pkg.test() does, but differs in the \"sandboxing\" approach. While Pkg.test() creates a new temporary sandboxed environment, test() uses an existing environment in project (the test subfolder by default). This allows testing against the dev-versions of other packages. It requires that the test folder contains both a Project.toml and a Manifest.toml file.\n\nThe test() function also differs from directly including test/runtests.jl in the REPL in that it can generate coverage data and reports (this is only possible when running tests in a subprocess).\n\nIf show_coverage is passed as true (default), a coverage summary is shown. Further, if genhtml is true, a full HTML coverage report will be generated in covdir (relative to root). This requires the genhtml executable (part of the lcov package). Instead of true, it is also possible to pass the path to the genhtml exectuable.\n\nAll other keyword arguments correspond to the respective command line flag for the julia executable that is run as the subprocess.\n\nThis function is intended to be exposed in a project's development-REPL.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#Private-4","page":"QuantumControlBase","title":"Private","text":"","category":"section"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"optimize_with_dummy_method\nDummyOptimizationResult","category":"page"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"QuantumControlBase.TestUtils.optimize_with_dummy_method\nQuantumControlBase.TestUtils.DummyOptimizationResult","category":"page"},{"location":"api/quantum_control_base/#QuantumControlBase.TestUtils.optimize_with_dummy_method","page":"QuantumControlBase","title":"QuantumControlBase.TestUtils.optimize_with_dummy_method","text":"Run a dummy optimization.\n\nresult = optimize(problem, method=:dummymethod)\n\nruns through and \"optimization\" of the given problem where in each iteration, the amplitude of the guess pulses is diminished by 10%. The (summed) vector norm of the the control serves as the value of the optimization functional.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.TestUtils.DummyOptimizationResult","page":"QuantumControlBase","title":"QuantumControlBase.TestUtils.DummyOptimizationResult","text":"Result returned by optimize_with_dummy_method.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_control_base/#QuantumControlBaseWeylChamberAPI","page":"QuantumControlBase","title":"QuantumControlBase.WeylChamber","text":"","category":"section"},{"location":"api/quantum_control_base/#Public-5","page":"QuantumControlBase","title":"Public","text":"","category":"section"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"D_PE\ncanonical_gate\ngate_concurrence\nin_weyl_chamber\nlocal_invariants\nunitarity\nweyl_chamber_coordinates\nweyl_chamber_region","category":"page"},{"location":"api/quantum_control_base/","page":"QuantumControlBase","title":"QuantumControlBase","text":"QuantumControlBase.WeylChamber.D_PE\nQuantumControlBase.WeylChamber.canonical_gate\nQuantumControlBase.WeylChamber.gate_concurrence\nQuantumControlBase.WeylChamber.in_weyl_chamber\nQuantumControlBase.WeylChamber.local_invariants\nQuantumControlBase.WeylChamber.unitarity\nQuantumControlBase.WeylChamber.weyl_chamber_coordinates\nQuantumControlBase.WeylChamber.weyl_chamber_region","category":"page"},{"location":"api/quantum_control_base/#QuantumControlBase.WeylChamber.D_PE","page":"QuantumControlBase","title":"QuantumControlBase.WeylChamber.D_PE","text":"Perfect-entanglers distance measure.\n\nD = D_PE(U; unitarity_weight=0.0, absolute_square=false)\n\nFor a given two-qubit gate U, this is defined via the local_invariants g_1, g_2, g_3 as\n\nD = g_3 sqrtg_1^2 + g_2^2 - g_1\n\nThis describes the geometric distance of the quantum gate from the polyhedron of perfect entanglers in the Weyl chamber.\n\nThis equation is only meaningful under the assumption that U is unitary. If the two-qubit level are a logical subspace embedded in a larger physical Hilbert space, loss of population from the logical subspace may lead to a non-unitary U. In this case, the unitarity measure can be added to the functional by giving a unitary_weight ∈ [0, 1) that specifies the relative proportion of the D term and the unitarity term.\n\nBy specifying absolute_square=true, the functional is modified as D  D², optimizing specifically for the boundary of the perfect entanglers polyhedron. This accounts for the fact that D can take negative values inside the polyhedron, as well as the W1 region of the Weyl chamber (the one adjacent to SWAP). This may be especially useful in a system with population loss (unitarity_weight > 0), as it avoids situations where the optimization goes deeper into the perfect entanglers while increasing population loss.\n\nwarning: Warning\nThe functional does not check which region of the Weyl chamber the quantum gate is in. When using this for an optimization where the guess leads to a point in the W1 region of the Weyl chamber (close to SWAP), the sign of the functional must be flipped, or else it will optimize for SWAP. Alternatively, use absolute_square=true.\n\ntip: Tip\nThe functional can be converted into the correct form for an optimization that uses one objective for each logical basis state by using QuantumControl.Functionals.gate_functional.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.WeylChamber.canonical_gate","page":"QuantumControlBase","title":"QuantumControlBase.WeylChamber.canonical_gate","text":"Construct the canonical gate for the given Weyl chamber coordinates.\n\nÛ = canonical_gate(c₁, c₂, c₃)\n\nconstructs the two qubit gate U as\n\nU = expleftifracπ2 (c_1 σ_x σ_x + c_2 σ_y σ_y + c_3 σ_z σ_z)right\n\nwhere σ_xyz are the Pauli matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.WeylChamber.gate_concurrence","page":"QuantumControlBase","title":"QuantumControlBase.WeylChamber.gate_concurrence","text":"Calculate the maximum gate concurrence.\n\nC = gate_concurrence(U)\nC = gate_concurrence(c₁, c₂, c₃)\n\ncalculates that maximum concurrence C  0 1 that the two two-qubit gate U, respectively the gate described by the Weyl chamber coordinates c₁, c₂, c₃ (see weyl_chamber_coordinates) can generate.\n\nSee Kraus, Cirac, Phys. Rev. A 63, 062309 (2001)\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.WeylChamber.in_weyl_chamber","page":"QuantumControlBase","title":"QuantumControlBase.WeylChamber.in_weyl_chamber","text":"Check whether a given gate is in (a specific region of) the Weyl chamber.\n\nin_weyl_chamber(c₁, c₂, c₃)\n\nchecks whether c₁, c₂, c₃ are valid Weyl chamber coordinates.\n\nin_weyl_chamber(U; region=\"PE\")\nin_weyl_chamber(c₁, c₂, c₃; region=\"PE\")\n\nchecks whether the two-qubit gate U, respectively the gate described by the Weyl chamber coordinates c₁, c₂, c₃ (see weyl_chamber_coordinates) is a perfect entangler. The region can be any other of the regions returned by weyl_chamber_region.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.WeylChamber.local_invariants","page":"QuantumControlBase","title":"QuantumControlBase.WeylChamber.local_invariants","text":"Calculate the local invariants g₁, g₂, g₃ for a two-qubit gate.\n\ng₁, g₂, g₃ = local_invariants(U)\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.WeylChamber.unitarity","page":"QuantumControlBase","title":"QuantumControlBase.WeylChamber.unitarity","text":"Unitarity of a matrix.\n\npop_loss = 1 - unitarity(U)\n\nmeasures the loss of population from the subspace described by U. E.g., for a two-qubit gate, U is a 4×4 matrix. The unitarity is defined as Retr(U^U)  N where N is the dimension of U.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.WeylChamber.weyl_chamber_coordinates","page":"QuantumControlBase","title":"QuantumControlBase.WeylChamber.weyl_chamber_coordinates","text":"Calculate the Weyl chamber coordinates c₁, c₂, c₃ for a two-qubit gate.\n\nc₁, c₂, c₃ = weyl_chamber_coordinates(U)\n\ncalculates the Weyl chamber coordinates using the algorithm described in Childs et al., PRA 68, 052311 (2003).\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_control_base/#QuantumControlBase.WeylChamber.weyl_chamber_region","page":"QuantumControlBase","title":"QuantumControlBase.WeylChamber.weyl_chamber_region","text":"Identify which region of the Weyl chamber a given gate is located in.\n\nregion = weyl_chamber_region(U)\nregion = weyl_chamber_region(c₁, c₂, c₃)\n\nidentifies which region of the Weyl chamber the given two-qubit gate U, respectively the gate identified by the Weyl chamber coordinates c₁, c₂, c₃ (see weyl_chamber_coordinates) is in, as a string. Possible outputs are:\n\n\"PE\": gate is in the polyhedron of perfect entanglers.\n\"W0\": gate is between the identity and the perfect entanglers.\n\"W0*\": gate is between CPHASE(2π) and the perfect entanglers.\n\"W1\": gate is between SWAP and the perfect entanglers.\n\nFor invalid Weyl chamber coordinates, an empty string is returned.\n\n\n\n\n\n","category":"function"},{"location":"history/#History","page":"History","title":"History","text":"","category":"section"},{"location":"history/","page":"History","title":"History","text":"Each release of QuantumControl.jl is determined by the compatible versions of the JuliaQuantumControl packages.","category":"page"},{"location":"history/","page":"History","title":"History","text":"<table>\n    <thead class=\"membership-tiers text-left\">\n    <tr>\n        <th class=\"rotated-text\" scope=\"col\"><div><span>QuantumControl</span></div></th>\n        <th class=\"non-rotated-text\" scope=\"col\"><div><span>Release Date</span></div></th>\n        <th class=\"rotated-text\" scope=\"col\"><div><span>QuantumPropagators</span></div></th>\n        <th class=\"rotated-text\" scope=\"col\"><div><span>QuantumControlBase</span></div></th>\n        <th class=\"rotated-text\" scope=\"col\"><div><span>Krotov</span></div></th>\n        <th class=\"rotated-text\" scope=\"col\"><div><span>GRAPE</span></div></th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <th scope=\"row\"><a href=\"https://github.com/JuliaQuantumControl/QuantumControl.jl/releases/tag/v0.2.0\">0.2.0</a></th>\n        <td>2022-03-23</td>\n        <td><a href=\"https://github.com/JuliaQuantumControl/QuantumPropagators.jl/releases/tag/v0.1.4\">0.1.4</a></td>\n        <td><a href=\"https://github.com/JuliaQuantumControl/QuantumControlBase.jl/releases/tag/v0.3.0\">0.3.0</a></td>\n        <td><a href=\"https://github.com/JuliaQuantumControl/Krotov.jl/releases/tag/v0.2.0\">0.2.0</a></td>\n        <td><a href=\"https://github.com/JuliaQuantumControl/GRAPE.jl/releases/tag/v0.2.0\">0.2.0</a></td>\n    </tr>\n    <tr>\n        <th scope=\"row\"><a href=\"https://github.com/JuliaQuantumControl/QuantumControl.jl/releases/tag/v0.1.0\">0.1.0</a></th>\n        <td>2022-02-15</td>\n        <td><a href=\"https://github.com/JuliaQuantumControl/QuantumPropagators.jl/releases/tag/v0.1.0\">0.1.0</a></td>\n        <td><a href=\"https://github.com/JuliaQuantumControl/QuantumControlBase.jl/releases/tag/v0.2.0\">0.2.0</a></td>\n        <td><a href=\"https://github.com/JuliaQuantumControl/Krotov.jl/releases/tag/v0.1.0\">0.1.0</a></td>\n        <td><a href=\"https://github.com/JuliaQuantumControl/GRAPE.jl/releases/tag/v0.1.0\">0.1.0</a></td>\n    </tr>\n    <tr>\n        <th scope=\"row\"><a href=\"https://github.com/JuliaQuantumControl/QuantumControl.jl/releases/tag/v0.0.4\">0.0.4</a></th>\n        <td>2022-02-07</td>\n        <td><a href=\"https://github.com/JuliaQuantumControl/QuantumPropagators.jl/releases/tag/v0.1.0\">0.1.0</a></td>\n        <td><a href=\"https://github.com/JuliaQuantumControl/QuantumControlBase.jl/releases/tag/v0.1.0\">0.1.0</a></td>\n        <td><a href=\"https://github.com/JuliaQuantumControl/Krotov.jl/releases/tag/v0.1.0\">0.1.0</a></td>\n        <td><a href=\"https://github.com/JuliaQuantumControl/GRAPE.jl/releases/tag/v0.0.3\">0.0.3</a></td>\n    </tr>\n    <tr>\n        <th scope=\"row\"><a href=\"https://github.com/JuliaQuantumControl/QuantumControl.jl/releases/tag/v0.0.3\">0.0.3</a></th>\n        <td>2022-01-03</td>\n        <td><a href=\"https://github.com/JuliaQuantumControl/QuantumPropagators.jl/releases/tag/v0.0.3\">0.0.3</a></td>\n        <td><a href=\"https://github.com/JuliaQuantumControl/QuantumControlBase.jl/releases/tag/v0.0.3\">0.0.3</a></td>\n        <td><a href=\"https://github.com/JuliaQuantumControl/Krotov.jl/releases/tag/v0.0.3\">0.0.3</a></td>\n        <td><a href=\"https://github.com/JuliaQuantumControl/GRAPE.jl/releases/tag/v0.0.2\">0.0.2</a></td>\n    </tr>\n    <tr>\n        <th scope=\"row\"><a href=\"https://github.com/JuliaQuantumControl/QuantumControl.jl/releases/tag/v0.0.2\">0.0.2</a></th>\n        <td>2021-10-02</td>\n        <td>^0.0</td>\n        <td>^0.0</td>\n        <td>^0.0</td>\n        <td>—</td>\n    </tr>\n    </tbody>\n</table>","category":"page"},{"location":"api/grape/","page":"GRAPE","title":"GRAPE","text":"EditURL = \"../../generate_api.jl\"","category":"page"},{"location":"api/grape/#GRAPEPackage","page":"GRAPE","title":"GRAPE Package","text":"","category":"section"},{"location":"api/grape/#Index","page":"GRAPE","title":"Index","text":"","category":"section"},{"location":"api/grape/","page":"GRAPE","title":"GRAPE","text":"gdeftgttexttgt gdeftroperatornametr gdefReoperatornameRe gdefImoperatornameIm","category":"page"},{"location":"api/grape/","page":"GRAPE","title":"GRAPE","text":"Pages   = [\"grape.md\"]","category":"page"},{"location":"api/grape/#GRAPEAPI","page":"GRAPE","title":"GRAPE","text":"","category":"section"},{"location":"api/grape/#Private","page":"GRAPE","title":"Private","text":"","category":"section"},{"location":"api/grape/","page":"GRAPE","title":"GRAPE","text":"print_table\noptimize_grape\nGrapeResult","category":"page"},{"location":"api/grape/","page":"GRAPE","title":"GRAPE","text":"GRAPE.print_table\nGRAPE.optimize_grape\nGRAPE.GrapeResult","category":"page"},{"location":"api/grape/#GRAPE.print_table","page":"GRAPE","title":"GRAPE.print_table","text":"Print optimization progress as a table.\n\nThis functions serves as the default info_hook for an optimization with GRAPE.\n\n\n\n\n\n","category":"function"},{"location":"api/grape/#GRAPE.optimize_grape","page":"GRAPE","title":"GRAPE.optimize_grape","text":"Optimize a control problem using GRAPE.\n\nresult = optimize_grape(problem)\n\noptimizes the given control problem, returning a GrapeResult.\n\nnote: Note\nIt is recommended to call optimize with method=:GRAPE instead of calling optimize_grape directly.\n\nKeyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of problem.\n\nRequired problem keyword arguments\n\nJ_T: A function J_T(ϕ, objectives; τ=τ) that evaluates the final time functional from a vector ϕ of forward-propagated states and problem.objectives. For all objectives that define a target_state, the element τₖ of the vector τ will contain the overlap of the state ϕₖ with the target_state of the k'th objective, or NaN otherwise.\n\nOptional problem keyword arguments\n\ngradient_via: A flag indicating how the gradient of J_T should be  calculated. One of :tau, :chi. If all objectives in problem define a  target_function, the default is gradient_via=:tau. This understands the  functional J_T as a function of the complex overlaps between the  propagated states and the target states, and evaluates the gradient via the  chain rule. For functionals that cannot be expressed in terms of the overlap  of propagated and target states, and/or if not all objectives define a  target state, gradient_via=:chi because the default. In this case, the  functional J_T is understood as a function of the forward-propagated  states directly, and the full gradient is again calculated by the chain  rule. See make_gradient for details.\ngradient:  A function to evaluate the gradient of J_T. By default, it is constructed via make_gradient. If given manually, it must meet the interface described by make_gradient. Most importantly, it must be consistent with the chosen gradient_via.\nchi: If gradient_via=:chi, a function that constructs the χ-states for  the backward propagation, see make_gradient for details. By  default, it is constructed via make_chi. If given manually, it  must meet the same interface described in make_chi.\nforce_zygote=false: Whether to force the use of automatic differentiation in make_gradient and make_chi. This disables analytic gradients. The only reason to do this is for testing/benchmarking analytic vs automatic gradients.\nupdate_hook: Not implemented\ninfo_hook: A function that receives the same arguments as update_hook, in order to write information about the current iteration to the screen or to a file. The default info_hook prints a table with convergence information to the screen. Runs after update_hook. The info_hook function may return a tuple, which is stored in the list of records inside the GrapeResult object.\ncheck_convergence: A function to check whether convergence has been reached. Receives a GrapeResult object result, and should set result.converged to true and result.message to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with ∘. The convergence check is performed after any calls to update_hook and info_hook.\nx_tol: Parameter for Optim.jl\nf_tol: Parameter for Optim.jl\ng_tol: Parameter for Optim.jl\nshow_trace: Parameter for Optim.jl\nextended_trace:  Parameter for Optim.jl\nshow_every: Parameter for Optim.jl\nallow_f_increases: Parameter for Optim.jl\noptimizer: An optional Optim.jl optimizer (Optim.AbstractOptimizer instance). If not given, an L-BFGS-B optimizer will be used.\nprop_method/fw_prop_method/bw_prop_method: The propagation method to use for each objective, see below.\nprop_method/fw_prop_method/grad_prop_method: The propagation method to use for the extended gradient vector for each objective, see below.\nverbose=false: If true, print information during initialization\n\nThe propagation method for the forward propagation of each objective is determined by the first available item of the following:\n\na fw_prop_method keyword argument\na prop_method keyword argument\na property fw_prop_method of the objective\na property prop_method of the objective\nthe value :auto\n\nThe propagation method for the backward propagation is determined similarly, but with bw_prop_method instead of fw_prop_method. The propagation method for the forward propagation of the extended gradient vector for each objective is determined from grad_prop_method, fw_prop_method, prop_method in order of precedence.\n\n\n\n\n\n","category":"function"},{"location":"api/grape/#GRAPE.GrapeResult","page":"GRAPE","title":"GRAPE.GrapeResult","text":"Result object returned by optimize_grape.\n\n\n\n\n\n","category":"type"},{"location":"api/krotov/","page":"Krotov","title":"Krotov","text":"EditURL = \"../../generate_api.jl\"","category":"page"},{"location":"api/krotov/#KrotovPackage","page":"Krotov","title":"Krotov Package","text":"","category":"section"},{"location":"api/krotov/#Index","page":"Krotov","title":"Index","text":"","category":"section"},{"location":"api/krotov/","page":"Krotov","title":"Krotov","text":"gdeftgttexttgt gdeftroperatornametr gdefReoperatornameRe gdefImoperatornameIm","category":"page"},{"location":"api/krotov/","page":"Krotov","title":"Krotov","text":"Pages   = [\"krotov.md\"]","category":"page"},{"location":"api/krotov/#KrotovAPI","page":"Krotov","title":"Krotov","text":"","category":"section"},{"location":"api/krotov/#Public","page":"Krotov","title":"Public","text":"","category":"section"},{"location":"api/krotov/","page":"Krotov","title":"Krotov","text":"LogisticParametrization\nLogisticSqParametrization\nSquareParametrization\nTanhParametrization\nTanhSqParametrization","category":"page"},{"location":"api/krotov/","page":"Krotov","title":"Krotov","text":"Krotov.LogisticParametrization\nKrotov.LogisticSqParametrization\nKrotov.SquareParametrization\nKrotov.TanhParametrization\nKrotov.TanhSqParametrization","category":"page"},{"location":"api/krotov/#Krotov.LogisticParametrization","page":"Krotov","title":"Krotov.LogisticParametrization","text":"Parametrization with a Logistic function that enforces ϵmin < ϵ(t) < ϵmax.\n\n\n\n\n\n","category":"function"},{"location":"api/krotov/#Krotov.LogisticSqParametrization","page":"Krotov","title":"Krotov.LogisticSqParametrization","text":"Parametrization with a Logistic-Square function that enforces 0 ≤ ϵ(t) < ϵ_max.\n\n\n\n\n\n","category":"function"},{"location":"api/krotov/#Krotov.SquareParametrization","page":"Krotov","title":"Krotov.SquareParametrization","text":"Parametrization ϵ(t) = u²(t), enforcing pulse values ≥ 0.\n\n\n\n\n\n","category":"function"},{"location":"api/krotov/#Krotov.TanhParametrization","page":"Krotov","title":"Krotov.TanhParametrization","text":"Parametrization with a tanh function that enforces ϵmin < ϵ(t) < ϵmax.\n\n\n\n\n\n","category":"function"},{"location":"api/krotov/#Krotov.TanhSqParametrization","page":"Krotov","title":"Krotov.TanhSqParametrization","text":"Parametrization with a tanh² function that enforces 0  ϵ(t)  ϵ_max.\n\n\n\n\n\n","category":"function"},{"location":"api/krotov/#Private","page":"Krotov","title":"Private","text":"","category":"section"},{"location":"api/krotov/","page":"Krotov","title":"Krotov","text":"PulseParametrization\noptimize_krotov\nprint_table\nNoParametrization\nKrotovResult","category":"page"},{"location":"api/krotov/","page":"Krotov","title":"Krotov","text":"Krotov.PulseParametrization\nKrotov.optimize_krotov\nKrotov.print_table\nKrotov.NoParametrization\nKrotov.KrotovResult","category":"page"},{"location":"api/krotov/#Krotov.PulseParametrization","page":"Krotov","title":"Krotov.PulseParametrization","text":"Specification for a \"time-local\" pulse parametrization.\n\nThe parametrization is given as a collection of three functions:\n\nϵ(u(t))\nu(ϵ(t))\nϵu as a function of u(t).\n\n\n\n\n\n","category":"type"},{"location":"api/krotov/#Krotov.optimize_krotov","page":"Krotov","title":"Krotov.optimize_krotov","text":"Optimize a control problem using Krotov's method.\n\nresult = optimize_krotov(problem)\n\noptimizes the given control problem, returning a KrotovResult.\n\nnote: Note\nIt is recommended to call optimize with method=:krotov instead of calling optimize_krotov directly.\n\nKeyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of problem.\n\nRequired problem keyword arguments\n\nJ_T: A function J_T(ϕ, objectives) that evaluates the final time functional from a list ϕ of forward-propagated states and problem.objectives.\n\nOptional problem keyword arguments\n\nThe following keyword arguments are supported (with default values):\n\nchi: A function chi!(χ, ϕ, objectives) what receives a list ϕ of the forward propagates state and must set -χₖ=J_Tϕₖ. If not given, it will be automatically determined from J_T via make_chi\nforce_zygote=false: Whether to force the use of automatic differentiation when calling make_chi.\nsigma=nothing: Function that calculate the second-order contribution. If not given, the first-order Krotov method is used.\niter_start=0: the initial iteration number\niter_stop=5000: the maximum iteration number\nprop_method/fw_prop_method/bw_prop_method: The propagation method to use for each objective, see below.\nupdate_hook: A function that receives the Krotov workspace, the iteration number, the list of updated pulses and the list of guess pulses as positional arguments. The function may mutate any of its arguments. This may be used e.g. to apply a spectral filter to the updated pulses, or to update propagation workspaces inside the Krotov workspace.\ninfo_hook: A function that receives the same argumens as update_hook, in order to write information about the current iteration to the screen or to a file. The default info_hook prints a table with convergence information to the screen. Runs after update_hook. The info_hook function may return a tuple, which is stored in the list of records inside the KrotovResult object.\ncheck_convergence: a function to check whether convergence has been reached. Receives a KrotovResult object result, and should set result.converged to true and result.message to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with ∘. The convergence check is performed after any calls to update_hook and info_hook.\nverbose=false: If true, print information during initialization\n\nThe propagation method for the forward propagation of each objective is determined by the first available item of the following:\n\na fw_prop_method keyword argument\na prop_method keyword argument\na property fw_prop_method of the objective\na property prop_method of the objective\nthe value :auto\n\nThe propagation method for the backword propagation is determined similarly, but with bw_prop_method instead of fw_prop_method.\n\n\n\n\n\n","category":"function"},{"location":"api/krotov/#Krotov.print_table","page":"Krotov","title":"Krotov.print_table","text":"Print optimization progress as a table.\n\nThis functions serves as the default info_hook for an optimization with Krotov's method.\n\n\n\n\n\n","category":"function"},{"location":"api/krotov/#Krotov.NoParametrization","page":"Krotov","title":"Krotov.NoParametrization","text":"Parametrization where ϵ(t)  u(t).\n\n\n\n\n\n","category":"function"},{"location":"api/krotov/#Krotov.KrotovResult","page":"Krotov","title":"Krotov.KrotovResult","text":"Result object returned by optimize_krotov.\n\n\n\n\n\n","category":"type"},{"location":"howto/#Howto","page":"Howto","title":"Howto","text":"","category":"section"},{"location":"howto/","page":"Howto","title":"Howto","text":"TODO","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"EditURL = \"../../generate_api.jl\"","category":"page"},{"location":"api/quantum_propagators/#QuantumPropagatorsPackage","page":"QuantumPropagators","title":"QuantumPropagators Package","text":"","category":"section"},{"location":"api/quantum_propagators/#Index","page":"QuantumPropagators","title":"Index","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"gdeftgttexttgt gdeftroperatornametr gdefReoperatornameRe gdefImoperatornameIm","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Pages   = [\"quantum_propagators.md\"]","category":"page"},{"location":"api/quantum_propagators/#QuantumPropagatorsAPI","page":"QuantumPropagators","title":"QuantumPropagators","text":"","category":"section"},{"location":"api/quantum_propagators/#Public","page":"QuantumPropagators","title":"Public","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"initprop\npropagate\npropstep!\nreinitprop!\nset_state!","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"QuantumPropagators.initprop\nQuantumPropagators.propagate\nQuantumPropagators.propstep!\nQuantumPropagators.reinitprop!\nQuantumPropagators.set_state!","category":"page"},{"location":"api/quantum_propagators/#QuantumPropagators.initprop","page":"QuantumPropagators","title":"QuantumPropagators.initprop","text":"Initialize a Propagator.\n\npropagator = initprop(\n    state, generator, tlist;\n    method=:auto,\n    backward=false,\n    inplace=true,\n    piecewise=nothing,\n    pwc=nothing,\n    kwargs...\n)\n\ninitializes a propagator for the time propagation of the given state over a time grid tlist under the time-dependent generator (Hamiltonian/Liouvillian) generator.\n\nArguments\n\nstate: The \"initial\" state for the propagation. For backward=false, this state is taken to be at initial time (tlist[begin]); and for backward=true, at the final time (tlist[end])\ngenerator: The time-dependent generator of the dynamics\ntlist: The time grid over which which the propagation is defined. This may or may not be equidistant.\n\nKeyword arguments\n\nmethod: The propagation method to use. The default value of :auto attempts to choose the best method available, based on the properties of the given state, tlist, and generator, cf. choose_propmethod\nbackward: If true, initialize the propagator for a backward propagation. The resulting propagator.t will be tlist[end], and subsequent calls to propstep! will move backward on tlist.\ninplace: If true, the state property of the resulting propagator will be changed in-place by any call to propstep!. If false, each call to propstep! changes the reference for propgator.state, and the progation will not use any in-place operations. Not all propagation methods may support both in-place and not-in-place propagation. In-place propagation is generally more efficient but may not be compatible, e.g., with automatic differentiation.\npiecewise: If given a a boolean, true enforces that the resulting propagator is a PiecewisePropagator, and false enforces is not to be a PiecewisePropagator\npwc: Like piecewise, for for the stronger PWCPropagator\n\nAll other kwargs are method-dependent and are ignored for methods that do not support them.\n\nThe type of the returned propagator is a sub-type of AbstractPropagator, respectively a sub-type of PiecewisePropagator if piecewise=true or a sub-type of PWCPropagator if pwc=true.\n\nSee also\n\nreinitprop! — Re-initialize a propagator\npropagate — Higher-level propagation interface\n\n\n\n\n\ncheby_propagator = initprop(\n    state,\n    generator,\n    tlist;\n    method=:cheby,\n    inplace=true,\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    control_ranges=nothing,\n    specrange_method=:auto,\n    specrange_buffer=0.01,\n    cheby_coeffs_limit=1e-12,\n    check_normalization=false,\n    specrange_kwargs...\n)\n\ninitializes a ChebyPropagator.\n\nMethod-specific keyword arguments\n\ncontrol_ranges: a dict the maps the controls in generator (see getcontrols) to a tuple of min/max values. The Chebychev coefficients will be calculated based on a spectral envelope that assumes that each control can take arbitrary values within the min/max range. If not given, the ranges are determined automatically. Specifying manual control ranges can be useful when the the control amplitudes (parameters) may change during the propagation, e.g. in a sequential-update control scheme.\nspecrange_method: Method to pass to the specrange function\nspecrange_buffer: An additional factor by which to enlarge the estimated  spectral range returned by specrange, in order to ensure that Chebychev coefficients are based on an overestimation of the spectral range.\ncheby_coeffs_limit: The maximum magnitude of Chebychev coefficients that should be treated as non-zero\ncheck_normalization: Check whether the Hamiltonian has been properly normalized, i.e., that the spectral range of generator has not been underestimated. This slowes down the propagation, but is advisable for novel generators.\nspecrange_kwargs: All further keyword arguments are passed to the specrange function\n\n\n\n\n\nnewton_propagator = initprop(\n    state,\n    generator,\n    tlist,\n    method::Val{:newton};\n    inplace=true,\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    m_max=10,\n    func=(z -> exp(-1im * z)),\n    norm_min=1e-14,\n    relerr=1e-12,\n    max_restarts=50,\n    _...\n)\n\ninitializes a NewtonPropagator.\n\nMethod-specific keyword arguments\n\nm_max: maximum Krylov dimension, cf. NewtonWrk\nfunc, norm_min, relerr, max_restarts: parameter to pass to newton!\n\n\n\n\n\nexp_propagator = initprop(\n    state,\n    generator,\n    tlist,\n    method::Val{:expprop};\n    inplace=true,\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    func=(H_dt -> exp(-1im * H_dt))\n    convert_state=_exp_prop_convert_state(state),\n    convert_operator=_exp_prop_convert_operator(generator),\n    _...\n)\n\ninitializes an ExpPropagator.\n\nMethod-specific keyword arguments\n\nfunc: The function to evaluate. The argument H_dt is obtained by constructing an operator H from generator via the evalcontrols function and the multiplied with the time step dt for the current time interval. The propagation then simply multiplies the return value of func with the current state\nconvert_state:  Type to which to temporarily convert states before multiplying the return value of func.\nconvert_operator: Type to which to convert the operator H before multiplying it with dt and plugging the result into func\n\nThe convert_state and convert_operator parameters are useful for when the generator and or state are unusual data structures for which the relevant methods to calculate func are not defined. Often, it is easier to temporarily convert them to standard complex matrices and vectors than to implement the missing methods.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.propagate","page":"QuantumPropagators","title":"QuantumPropagators.propagate","text":"Propagate a state over an entire time grid.\n\nstate = propagate(\n    state,\n    generator,\n    tlist;\n    method=:auto,\n    backward=false,\n    inplace=true,\n    verbose=false,\n    piecewise=nothing,\n    pwc=nothing,\n    storage=nothing,\n    observables=(<store state>, ),\n    callback=nothing,\n    showprogress=false,\n    initprop_kwargs...)\n\npropagates state of the entire time grid and returns the propagates states, or a storage array of data collected during the propagation.\n\nArguments\n\nstate: The \"initial\" state for the propagation. For backward=false, this state is taken to be at initial time (tlist[begin]); and for backward=true, at the final time (tlist[end])\ngenerator: The time-dependent generator of the dynamics\ntlist: The time grid over which which the propagation is defined. This may or may not be equidistant.\n\nKeyword arguments\n\nmethod: The propagation method to use. The default value of :auto attempts to choose the best method available, based on the properties of the given state, tlist, and generator.\nbackward: If true, propagate backward in time\ninplace: If true, propagate using in-place operations. If false, avoid in-place operations. Not all propagation methods support both in-place and not-in-place propagation.\npiecewise: If given a a boolean, limit the propagation to \"piecewise\" methods, respectively disallow piecewise methods\npwc: If given a a boolean, limit the propagation to piecewise-constant methods, respectively disallow piecewise-constant methods\nstorage: Flag whether to store and return the propagated states / observables, or pre-allocated storage array. See Notes below.\nobservables: Converters for data to be stored in storage. See Notes below.\ncallback: Function to call after each propagation step. See Notes below.\nshowprogess: Whether to show a progress bar. See Notes below.\n\nAll remaining keyword arguments are passed to initprop to initialize the Propagator that is used internally to drive the optimization. Unknown keyword arguments will be ignored.\n\nNotes\n\nIn general, there is no requirement that tlist has a constant time step, although some propagation methods (most notably cheby!) only support a uniform time grid.\n\nIf storage is given as an Array, it will be filled with data determined by the observables. The default \"observable\" results in the propagated states at every point in time being stored. The storage array should be created with init_storage. See its documentation for details.\n\nThe storage parameter may also be given as true, and a new storage array will be created internally with init_storage and returned instead of the propagated state:\n\ndata = propagate(\n    state, generator, tlist; method=:auto\n    backward=false; storage=true, observables=observables,\n    callback=nothing, showprogress=false, kwargs...)\n\nIf backward is true, the input state is assumed to be at time tlist[end], and the propagation progresses backward in time (with a negative time step dt). If storage is given, it will be filled back-to-front during the backward propagation.\n\nIf callback is given as a callable, it will be called after each propagation step, as callback(propagator, observables) where propagator is Propagator object driving the propagation. The callback is called before calculating any observables. Example usage includes writing data to file, or modifying state via set_state!, e.g., removing amplitude from the lowest and highest level to mitigate \"truncation error\".\n\nIf showprogress is given as true, a progress bar will be shown for long-running propagationn. In order to customize the progress bar, showprogress may also be a function that receives length(tlist) and returns a ProgressMeter.Progress instance.\n\nIf in_place=false is given, the propagation avoids in-place operations. This is slower than inplace=true, but is often required in the context of automatic differentiation (AD), e.g., with Zygote. That is, use in_place=false if propagate is called inside a function to be passed to Zygote.gradient, Zygote.pullback, or a similar function. In an AD context, storage and showprogress should not be used.\n\nThe propagate routine returns the propagated state at tlist[end], respectively tlist[1] if backward=true, or a storage array with the stored states / observable data if storage=true.\n\nSee also\n\ninitprop — Propagate via a Propagator object\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.propstep!","page":"QuantumPropagators","title":"QuantumPropagators.propstep!","text":"Advance the propagator by a single time step.\n\nstate = propstep!(propagator)\n\nreturns the state obtained from propagating to the next point on the time grid from propagator.t, respectively the previous point if propagator.backward is true.\n\nWhen the propagation would lead out of the time grid, propstep! leaves propagator unchanged and returns nothing. Thus, a return value of nothing may be used to signal that a propagation has completed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.reinitprop!","page":"QuantumPropagators","title":"QuantumPropagators.reinitprop!","text":"Re-initialize a propagator.\n\nreinitprop!(propagator, state; kwargs...)\n\nresets the propagator to state at the beginning of the time grid, respectively the end of the time grid if propagator.backward is true.\n\nAt a minimum, this is equivalent to a call to set_state! follow by a call to set_t!, but some propagators may have additional requirements on re-initialization, such as refreshing expansion coefficients for ChebyPropagator. In this case, the kwargs may be additional keyword arguments specific to the concrete type of propagator.\n\n\n\n\n\nreinitprop!(\n    propagator::ChebyPropagator,\n    state;\n    transform_control_ranges=((c, ϵ_min, ϵ_max, check) => (ϵ_min, ϵ_max)),\n    kwargs...\n)\n\nre-initializes an existing ChebyPropagator. This may or may not involve recalculating the Chebychev coefficients based on the current control amplitudes in propagator.parameters.\n\nMethod-specific keyword arguments\n\ntransform_control_ranges: a function (c, ϵ_min, ϵ_max, check) => (ϵ_min′, ϵ_max′). For each control c, the function is called with check=true and ϵ_min (ϵ_max) the current minimum (maximum) values for the control from propagator.parameters). The Chebychev coefficients will be recalculated if the existing coefficients were obtained assuming a range for c outside the returned ϵ_min′, ϵ_max′.\nIf the coefficients do need to be recalculated, transform_control_ranges is called a second time with check=false, and the returned (ϵ_min′, ϵ_max′) are used for estimating the new spectral range.\nFor example,\nfunction transform_control_ranges(c, ϵ_min, ϵ_max, check)\n    if check\n        return (min(ϵ_min, 2 * ϵ_min), max(ϵ_max, 2 * ϵ_max))\n    else\n        return (min(ϵ_min, 5 * ϵ_min), max(ϵ_max, 5 * ϵ_max))\n    end\nend\nwill re-calculate the Chebychev coefficients only if the current amplitudes differ by more than a factor of two from the ranges that were used when initializing the propagator (control_ranges parameter in initprop, which would have had to overestimate the actual amplitudes by at least a factor of two).  When re-calculating, the control_ranges will overestimate the amplitudes by a factor of five. With this transform_control_ranges, the propagation will be stable as long as the amplitudes do not change dynamically by more than a factor of 2.5 from their original range, while also not re-calculating coefficients unnecessarily in each pass because of modest changes in the amplitudes.\nThe transform_control_ranges argument is only relevant in the context of optimal control, where the same propagator will be used for many iterations with changing control field amplitudes.\n\nAll other keyword arguments are ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.set_state!","page":"QuantumPropagators","title":"QuantumPropagators.set_state!","text":"Set the current state of the propagator.\n\nset_state!(propagator, state)\n\nsets the propagator.state property. In order to mutate the current state after a call to propstep!, the following pattern is recommended:\n\nΨ = propagator.state\nmutate!(Ψ)\nset_state!(propagator, Ψ)\n\nThis is guaranteed to work efficiently both for in-place and not-in-place propagators, without incurring unnecessary copies.\n\nwarning: Warning\nmutate!(propagator.state)by itself is not a safe operation. Always follow it byset_state!(propagator, propagator.state)\n\nSee also\n\nset_t! — set propagator.t.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#Private","page":"QuantumPropagators","title":"Private","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"AbstractPropagator\nExpPropagator\ncheby_get_spectral_envelope\nPWCPropagator\nset_t!\nNewtonPropagator\nChebyPropagator\nPiecewisePropagator\nchoose_propmethod","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"QuantumPropagators.AbstractPropagator\nQuantumPropagators.ExpPropagator\nQuantumPropagators.cheby_get_spectral_envelope\nQuantumPropagators.PWCPropagator\nQuantumPropagators.set_t!\nQuantumPropagators.NewtonPropagator\nQuantumPropagators.ChebyPropagator\nQuantumPropagators.PiecewisePropagator\nQuantumPropagators.choose_propmethod","category":"page"},{"location":"api/quantum_propagators/#QuantumPropagators.AbstractPropagator","page":"QuantumPropagators","title":"QuantumPropagators.AbstractPropagator","text":"Abstract base type for all Propagator objects.\n\nAll Propagator objects must be instantiated via initprop and implement the following interface.\n\nProperties\n\nstate (read-only): The current quantum state in the propagation\ntlist (read-only): The time grid for the propatation\nt (read-only): The time at which state is defined. An element of tlist.\nparameters: parameters that determine the dynamics. The structure of the parameters depends on the concrete Propagator type (i.e., the propagation method). Mutating the parameters affects subsequent propagation steps.\nbackward: Boolean flag to indicate whether the propagation moves forward or backward in time\ninplace: Boolean flag to indicate whether propagator.state is modified in-place or is recreated by every call of propstep! or set_state!. For inplace=true, we find Ψ = propagator.state; propstep!(propagator); propagator.state === Ψ to be true, while for inplace=false it is false.\n\nConcrete Propagator types may have additional properties or fields, but these should be considered private.\n\nMethods\n\nreinitprop! — reset the propagator to a new initial state at the beginning of the time grid (or the end, for backward propagation)\npropstep! – advance the propagator by one step forward (or backward) on the time grid.\nset_state! — safely mutate the current quantum state of the propagation. Note that directly mutating the state property is not safe. However, Ψ = propagator.state; mutate!(Ψ), set_state!(propagator, Ψ) is guaranteed to be safe and efficient for both in-place and not-in-place propagators.\nset_t! — safely mutate the current time (propagator.t), snapping to the values of tlist.\n\nSee also\n\nPiecewisePropagator — specialization of AbstractPropagator for piecewise propagation methods.\nPWCPropagator — specialization of PiecewisePropagator for piecewise-constant propagation methods.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.ExpPropagator","page":"QuantumPropagators","title":"QuantumPropagators.ExpPropagator","text":"Propagator for propagation via direct exponentiation (method=:expprop)\n\nThis is a PWCPropagator.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.cheby_get_spectral_envelope","page":"QuantumPropagators","title":"QuantumPropagators.cheby_get_spectral_envelope","text":"Determine the spectral envelope of a generator.\n\nE_min, E_max = cheby_get_spectral_envelope(generator, control_ranges, method;\n                                           kwargs...)\n\nestimates a lower bound E_min the lowest eigenvalue of the generator for any values of the controls specified by control_ranges, and an upper bound E_max for the highest eigenvalue.\n\nThis is done by constructing operators from the extremal values for the controls as specified in control_ranges and taking the smallest/largest return values from specrange for those operators.\n\nArguments\n\ngenerator: dynamical generator, e.g. a time-dependent\ncontrol_ranges: a dict that maps controls that occur in generator (cf. getcontrols to a tuple of mimimum and maximum amplitude for that control\nmethod: method name to pass to  specrange\nkwargs: Any remaining keyword arguments are passed to specrange\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.PWCPropagator","page":"QuantumPropagators","title":"QuantumPropagators.PWCPropagator","text":"PiecewisePropagator sub-type for piecewise-constant propagators.\n\nLike the more general PiecewisePropagator, this is characterized by propagator.parameters mapping the controls in the generator to a vector of amplitude value on the midpoints of the time grid intervals.\n\nThe propagation will use these values as constant within each interval.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.set_t!","page":"QuantumPropagators","title":"QuantumPropagators.set_t!","text":"Set the current time for the propagation.\n\nset_t!(propagator, t)\n\nSets propagator.t to the given value of t, where t must be an element of propagator.tlist.\n\nSee also\n\nset_state! — set propagator.state\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.NewtonPropagator","page":"QuantumPropagators","title":"QuantumPropagators.NewtonPropagator","text":"Propagator for Newton propagation (method=:newton).\n\nThis is a PWCPropagator.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.ChebyPropagator","page":"QuantumPropagators","title":"QuantumPropagators.ChebyPropagator","text":"Propagator for Chebychev propagation (method=:cheby).\n\nThis is a PWCPropagator.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.PiecewisePropagator","page":"QuantumPropagators","title":"QuantumPropagators.PiecewisePropagator","text":"AbstractPropagator sub-type for piecewise propagators.\n\nA piecewise propagator is determined by a single parameter per control and time grid interval. Consequently, the propagator.parameters are a dictionary mapping the controls found in the generator via getcontrols to a vector of values defined on the intervals of the time grid, see discretize_on_midpoints. This does not necessarily imply that these values are the piecewise-constant amplitudes for the intervals. A general piecwise propagatore might use interpolation to obtain actual amplitudes within any given time interval.\n\nWhen the amplitudes are piecewise-constant, the propagator should be a concrete intantiation of a PWCPropagator.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.choose_propmethod","page":"QuantumPropagators","title":"QuantumPropagators.choose_propmethod","text":"Choose a suitable propagation method.\n\nmethod = choose_propmethod(generator, state, tlist;\n                           pwc=nothing, piecewise=nothing, inplace=true)\n\nidentifies a suitable propagation method for the given generator, state and tlist. If piecewise or pwc are given as true, only consider methods that result in in a PiecewisePropagator or PWCPropagator, respectively. If piecewise or pwc are given as false, disregard any methods that result in these propagators. Only propagators that support the given inplace are taken into account.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagatorsArnoldiAPI","page":"QuantumPropagators","title":"QuantumPropagators.Arnoldi","text":"","category":"section"},{"location":"api/quantum_propagators/#Private-2","page":"QuantumPropagators","title":"Private","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"arnoldi!\ndiagonalize_hessenberg_matrix\nextend_arnoldi!","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"QuantumPropagators.Arnoldi.arnoldi!\nQuantumPropagators.Arnoldi.diagonalize_hessenberg_matrix\nQuantumPropagators.Arnoldi.extend_arnoldi!","category":"page"},{"location":"api/quantum_propagators/#QuantumPropagators.Arnoldi.arnoldi!","page":"QuantumPropagators","title":"QuantumPropagators.Arnoldi.arnoldi!","text":"m = arnoldi!(Hess, q, m, Ψ, H, dt=1.0; extended=true, norm_min=1e-15)\n\nCalculate the Hessenberg matrix and Arnoldi vectors of H dt, from Ψ.\n\nFor a given order m, the m×m Hessemberg matrix is calculated and stored in in the pre-allocated Hess. Further  an array of m normalized Arnoldi vectors is stored in in the pre-allocated q, plus one additional unnormalized Arnoldi vector.  The unnormalized m+1st vector could be used to easily extend a given m×m Hessenberg matrix to a (m+1)×(m+1) matrix.\n\nIf the extended Hessenberg matrix is requested (extended=true, default), the m+1st Arnoldi vector is also normalized, and it's norm will be stored in m+1, m entry of the (extended) Hessenberg matrix, which is an (m+1)×(m+1) matrix.\n\nReturn the size m of the calculated Hessenberg matrix. This will usually be the input m, except when the Krylov dimension of H starting from Ψ is less then m. E.g., if Ψ is an eigenstate of H, the returned m will be 1.\n\nSee http://en.wikipedia.org/wiki/Arnoldi_iteration for a description of the algorithm.\n\nArguments\n\nHess::Matrix{ComplexF64}: Pre-allocated storage for the Hessemberg matrix.  Can be uninitialized on input. The matrix must be at least of size m×m, or  (m+1)×(m+1) if extended=true. On output, the m×m sub-matrix of Hess  (with the returned output m) will contain the Hessenberg matrix, and all  other elements of Hess be be set to zero.\nq: Pre-allocated array of states similar to Ψ, as storage for the calculated Arnoldi vectors. These may be un-initialized on input. Must be at least of length m+1\nm: The requested dimensions of the output Hessenberg matrix.\nΨ: The starting vector for the Arnoldi procedure. This can be of any type,  as long as Φ = H * Ψ results in a vector similar to Ψ, there is an inner  products of Φ and Ψ (Ψ⋅Φ is defined), and norm(Ψ) is defined.\nH: The operator (up to dt) for which to calculate the Arnoldi procedure. Can be of any type, as long as H * Ψ is defined.\ndt: The implicit time step; the total operator for which to calculate the Arnoldi procedure is H * dt\nextended: If true (default), calculate the extended Hessenberg matrix, and normalized the final Arnoldi vector\nnorm_min: the minimum value of the norm of Ψ at which Ψ should be  considered the zero vector\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Arnoldi.diagonalize_hessenberg_matrix","page":"QuantumPropagators","title":"QuantumPropagators.Arnoldi.diagonalize_hessenberg_matrix","text":"diagonalize_hessenberg_matrix(Hess, m; accumulate=false)\n\nDiagonalize the m × m top left submatrix of the given Hessenberg matrix.\n\nIf accumulate is true, return the concatenated eigenvalues for Hess[1:1,1:1] to Hess[1:m,1:m], that is, all sumatrices of size 1 through m.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Arnoldi.extend_arnoldi!","page":"QuantumPropagators","title":"QuantumPropagators.Arnoldi.extend_arnoldi!","text":"Extend dimension of Hessenberg matrix by one.\n\nextend_arnoldi!(Hess, q, m, H, dt; norm_min=1e-15)\n\nextends the entries in Hess from size (m-1)×(m-1) to size m×m, and the list q of Arnoldi vectors from m to (m+1). It is assumed that the input Hess was created by a call to arnoldi! with extended=false or a previous call to extend_arnoldi!. Note that Hess itself is not resized, so it must be allocated to size m×m or greater on input.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagatorsChebyAPI","page":"QuantumPropagators","title":"QuantumPropagators.Cheby","text":"","category":"section"},{"location":"api/quantum_propagators/#Public-2","page":"QuantumPropagators","title":"Public","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"ChebyWrk\ncheby\ncheby!\ncheby_coeffs\ncheby_coeffs!","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"QuantumPropagators.Cheby.ChebyWrk\nQuantumPropagators.Cheby.cheby\nQuantumPropagators.Cheby.cheby!\nQuantumPropagators.Cheby.cheby_coeffs\nQuantumPropagators.Cheby.cheby_coeffs!","category":"page"},{"location":"api/quantum_propagators/#QuantumPropagators.Cheby.ChebyWrk","page":"QuantumPropagators","title":"QuantumPropagators.Cheby.ChebyWrk","text":"Workspace for the Chebychev propagation routine.\n\nChebyWrk(Ψ, Δ, E_min, dt; limit=1e-12)\n\ninitializes the workspace for the propagation of a state similar to Ψ under a Hamiltonian with eigenvalues between E_min and E_min + Δ, and a time step dt. Chebychev coefficients smaller than the given limit are discarded.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.Cheby.cheby","page":"QuantumPropagators","title":"QuantumPropagators.Cheby.cheby","text":"Evaluate Ψ = exp(i- H dt) Ψ.\n\nΨ_out = cheby(Ψ, H, dt, wrk; E_min=nothing, check_normalization=false)\n\nacts like cheby! but does not modify Ψ in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Cheby.cheby!","page":"QuantumPropagators","title":"QuantumPropagators.Cheby.cheby!","text":"Evaluate Ψ = exp(-i H dt) Ψ in-place.\n\ncheby!(Ψ, H, dt, wrk; E_min=nothing, check_normalization=false)\n\nArguments\n\nΨ: on input, initial vector. Will be overwritten with result.\nH: Hermitian operator\ndt: time step\nwrk: internal workspace\nE_min: minimum eigenvalue of H, to be used instead of the E_min from the  initialization of wrk. The same wrk may be used for different values  E_min, as long as the spectra radius Δ and the time step dt are the  same as those used for the initialization of wrk.\ncheck_normalizataion: perform checks that the H does not exceed the spectral radius for which the the workspace was initialized.\n\nThe routine will not allocate any internal storage. This implementation requires copyto! lmul!, and axpy! to be implemented for Ψ, and the three-argument mul! for Ψ and H.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Cheby.cheby_coeffs","page":"QuantumPropagators","title":"QuantumPropagators.Cheby.cheby_coeffs","text":"Calculate Chebychev coefficients.\n\na::Vector{Float64} = cheby_coeffs(Δ, dt; limit=1e-12)\n\nreturn an array of coefficiencts larger than limit.\n\nArguments\n\nΔ: the spectral radius of the underlying operator\ndt: the time step\n\nSee also cheby_coeffs! for an in-place version.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Cheby.cheby_coeffs!","page":"QuantumPropagators","title":"QuantumPropagators.Cheby.cheby_coeffs!","text":"Calculate Chebychev coefficients in-place.\n\nn::Int = cheby_coeffs!(coeffs, Δ, dt, limit=1e-12)\n\noverwrites the first n values in coeffs with new coefficients larger than limit for the given new spectral radius Δ and time step dt. The coeffs array will be resized if necessary, and may have a length > n on exit.\n\nSee also cheby_coeffs for an non-in-place version.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagatorsControlsAPI","page":"QuantumPropagators","title":"QuantumPropagators.Controls","text":"","category":"section"},{"location":"api/quantum_propagators/#Public-3","page":"QuantumPropagators","title":"Public","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"discretize\ndiscretize_on_midpoints\nevalcontrols\nevalcontrols!\nget_tlist_midpoints\ngetcontrolderiv\ngetcontrolderivs\ngetcontrols\nsubstitute_controls","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"QuantumPropagators.Controls.discretize\nQuantumPropagators.Controls.discretize_on_midpoints\nQuantumPropagators.Controls.evalcontrols\nQuantumPropagators.Controls.evalcontrols!\nQuantumPropagators.Controls.get_tlist_midpoints\nQuantumPropagators.Controls.getcontrolderiv\nQuantumPropagators.Controls.getcontrolderivs\nQuantumPropagators.Controls.getcontrols\nQuantumPropagators.Controls.substitute_controls","category":"page"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.discretize","page":"QuantumPropagators","title":"QuantumPropagators.Controls.discretize","text":"Evaluate control at every point of tlist.\n\nvalues = discretize(control, tlist; via_midpoints=true)\n\ndiscretizes the given control to a Vector of values defined on the points of tlist.\n\nIf control is a function, it will will first be evaluated at the midpoint of tlist, see discretize_on_midpoints, and then the values on the midpoints are converted to values on tlist. This discretization is more stable than directly evaluationg the control function at the values of tlist, and ensures that repeated round-trips between discretize and discretize_on_midpoints can be done safely, see the note in the documentation of discretize_on_midpoints.\n\nThe latter can still be achieved by passing via_midpoints=false. While such a direct discretization is suitable e.g. for plotting, but it is unsuitable for round-trips between discretize and discretize_on_midpoints  (constant controls on tlist may result in a zig-zag on the intervals of tlist).\n\nIf control is a vector, it will be returned un-modified if it is of the same length as tlist. Otherwise, control must have one less value than tlist, and is assumed to be defined on the midpoins of tlist. In that case, discretize acts as the inverse of discretize_on_midpoints. See discretize_on_midpoints for how control values on tlist and control values on the intervals of tlist are related.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.discretize_on_midpoints","page":"QuantumPropagators","title":"QuantumPropagators.Controls.discretize_on_midpoints","text":"Evaluate control at the midpoints of tlist.\n\nvalues = discretize_on_midpoints(control, tlist)\n\ndiscretizes the given control to a Vector of values on the midpoints of tlist. Hence, the resulting values will contain one less value than tlist.\n\nIf control is a vector of values defined on tlist (i.e., of the same length as tlist), it will be converted to a vector of values on the intervals of tlist. The value for the first and last \"midpoint\" will remain the original values at the beginning and end of tlist, in order to ensure exact bounary conditions. For all other midpoints, the value for that midpoint will be calculated by \"un-averaging\".\n\nFor example, for a control and tlist of length 5, consider the following diagram:\n\ntlist index:       1   2   3   4   5\ntlist:             ⋅   ⋅   ⋅   ⋅   ⋅   input values cᵢ (i ∈ 1..5)\n                   |̂/ ̄ ̄ ̂\\ / ̂\\ / ̂ ̄ ̄\\|̂\nmidpoints:         x     x   x     x   output values pᵢ (i ∈ 1..4)\nmidpoints index:   1     2   3     4\n\nWe will have p₁=c₁ for the first value, p₄=c₅ for the last value. For all other points, the control values cᵢ = fracp_i-1 + p_i2 are the average of the values on the midpoints. This implies the \"un-averaging\" for the midpoint values pᵢ = 2 c_i - p_i-1.\n\nnote: Note\nAn arbitrary input control array may not be compatible with the above averaging formula. In this case, the conversion will be \"lossy\" (discretize will not recover the original control array; the difference should be considered a \"discretization error\"). However, any further round-trip conversions between points and intervals are bijective and preserve the boundary conditions. In this case, the discretize_on_midpoints and discretize methods are each other's inverse. This also implies that for an optimal control procedure, it is safe to modify midpoint values. Modifying the the values on the time grid directly on the other hand may accumulate discretization errors.\n\nIf control is a vector of one less length than tlist, it will be returned unchanged, under the assumption that the input is already properly discretized.\n\nIf control is a function, the function will be directly evaluated at the midpoints marked as x in the above diagram..\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.evalcontrols","page":"QuantumPropagators","title":"QuantumPropagators.Controls.evalcontrols","text":"Replace the controls in generator with static values.\n\nG = evalcontrols(generator, vals_dict)\n\nreplaces the time-dependent controls in generator with the values in vals_dict and returns the static operator G.\n\nThe vals_dict is a dictionary (IdDict) mapping controls as returned by getcontrols(generator) to values.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.evalcontrols!","page":"QuantumPropagators","title":"QuantumPropagators.Controls.evalcontrols!","text":"In-place version of evalcontrols.\n\nevalcontrols!(G, generator, vals_dict)\n\nacts as evalcontrols, but modifies G in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.get_tlist_midpoints","page":"QuantumPropagators","title":"QuantumPropagators.Controls.get_tlist_midpoints","text":"Shift time grid values the interval midpoints\n\ntlist_midpoints = get_tlist_midpoints(tlist)\n\ntakes a vector tlist of length n and returns a vector of length n-1 containing the midpoint values of each interval. The intervals in tlist are not required to be uniform.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.getcontrolderiv","page":"QuantumPropagators","title":"QuantumPropagators.Controls.getcontrolderiv","text":"Get the derivative of the generator G w.r.t. the control ϵ(t).\n\nμ  = getcontrolderiv(generator, control)\n\nreturns nothing if the generator (Hamiltonian or Liouvillian) does not depend on control, or a function μ(v) that evaluates\n\nμ(v) = leftfracGϵ(t)rightvert_ϵ(t)=v\n\notherwise. That is, a call μ(v) will return the static operator resulting from evaluating the derivative of the dynamical generator G with respect to the control filed ϵ(t) at a particular point in time where the control field takes the value v.\n\nNote that for the common case of linear control terms, e.g., H = H_0 + sum_l ϵ_l(t) H_l, the derivative Hϵ_l(t) is simply the control Hamiltonian H_l. Thus, the resulting function μ will simply return H_l, ignoring the argument v.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.getcontrolderivs","page":"QuantumPropagators","title":"QuantumPropagators.Controls.getcontrolderivs","text":"Get a vector of the derivatives of generator w.r.t. each control.\n\ngetcontrolderivs(generator, controls)\n\nreturn as vector containing the derivative of generator with respect to each control in controls. The elements of the vector are either nothing if generator does not depend on that particular control, or a function μ(α) that evaluates the derivative for a particular value of the control, see getcontrolderiv.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.getcontrols","page":"QuantumPropagators","title":"QuantumPropagators.Controls.getcontrols","text":"Extract a Tuple of controls.\n\ncontrols = getcontrols(generator)\n\nextracts the controls from a single dynamical generator.\n\nBy default, assumes that any generator is a nested Tuple, e.g. (H0, (H1, ϵ1), (H2, ϵ2), ...) and extracts (ϵ1, ϵ2)\n\nEach control must be a valid argument for discretize.\n\n\n\n\n\ngetcontrols(operator)\n\nfor a static operator (matrix) returns an empty tuple.\n\n\n\n\n\ncontrols = getcontrols(objectives)\n\nextracts the controls from a list of objectives (i.e., from each objective's generator). Controls that occur multiple times in the different objectives will occur only once in the result.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.substitute_controls","page":"QuantumPropagators","title":"QuantumPropagators.Controls.substitute_controls","text":"Substitute the controls inside a generator with different controls.\n\nnew_generator = substitute_controls(generator, controls_map)\n\nCreates a new generator from generator by replacing any control that is in the dict controls_map with controls_map[control]. Controls that are not in controls_map are kept unchanged.\n\nThe substituted controls must be time-dependent; to substitute static values for the controls, converting the time-depdentned generator into a static operator, use evalcontrols.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagatorsExpPropAPI","page":"QuantumPropagators","title":"QuantumPropagators.ExpProp","text":"","category":"section"},{"location":"api/quantum_propagators/#Public-4","page":"QuantumPropagators","title":"Public","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"ExpPropWrk\nexpprop!","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"QuantumPropagators.ExpProp.ExpPropWrk\nQuantumPropagators.ExpProp.expprop!","category":"page"},{"location":"api/quantum_propagators/#QuantumPropagators.ExpProp.ExpPropWrk","page":"QuantumPropagators","title":"QuantumPropagators.ExpProp.ExpPropWrk","text":"ExpPropWrk(v0)\n\nWorkspace for propagation via direct matrix exponentiation.\n\nInitializes the workspace for the propagation of a vector v0\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.ExpProp.expprop!","page":"QuantumPropagators","title":"QuantumPropagators.ExpProp.expprop!","text":"expprop!(Ψ, H, dt, wrk; func=(H_dt -> exp(-1im * H_dt)), _...)\n\nEvaluate Ψ = func(H*dt) Ψ by directly evaluating U = func(H*dt), i.e. by matrix exponentiation for the default func, and then multiplying U and Ψ in-place with mul!.\n\nThe workspace wrk must be initialized with ExpPropWrk to provide storage for a temporary state.\n\nKeyword arguments besides func are ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#Private-3","page":"QuantumPropagators","title":"Private","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"expprop","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"QuantumPropagators.ExpProp.expprop","category":"page"},{"location":"api/quantum_propagators/#QuantumPropagators.ExpProp.expprop","page":"QuantumPropagators","title":"QuantumPropagators.ExpProp.expprop","text":"Ψ_out = expprop(Ψ, H, dt, wrk; func=(H_dt -> exp(-1im * H_dt)), _...)\n\nevaluates Ψ_out = func(H*dt) Ψ as in expprop!, but not acting in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagatorsNewtonAPI","page":"QuantumPropagators","title":"QuantumPropagators.Newton","text":"","category":"section"},{"location":"api/quantum_propagators/#Public-5","page":"QuantumPropagators","title":"Public","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"NewtonWrk\nnewton!","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"QuantumPropagators.Newton.NewtonWrk\nQuantumPropagators.Newton.newton!","category":"page"},{"location":"api/quantum_propagators/#QuantumPropagators.Newton.NewtonWrk","page":"QuantumPropagators","title":"QuantumPropagators.Newton.NewtonWrk","text":"NewtonWrk(v0, m_max=10)\n\nWorkspace for the Newton-with-restarted-Arnoldi propagation routine.\n\nInitializes the workspace for the propagation of a vector v0, using a maximum Krylov dimension of m_max in each restart iteration. Note that m_max should be smaller than the length of v0.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.Newton.newton!","page":"QuantumPropagators","title":"QuantumPropagators.Newton.newton!","text":"newton!(Ψ, H, dt, wrk; func=(z -> exp(-1im*z)), norm_min=1e-14, relerr=1e-12,\n        max_restarts=50, _...)\n\nEvaluate Ψ = func(H*dt) Ψ using a Newton-with-restarted-Arnoldi scheme.\n\nArguments\n\nΨ: The state to propagate, will be overwritten in-place with the propagated state\nH: Operator acting on Ψ. Together with dt, this is the argument to func\ndt: Implicit time step. Together with H, this is the argument to func\nwkr: Work array, initialized with NewtonWrk\nfunc: The function to apply to H dt, taking a single (scalar) complex-valued argument z in place of H dt. The default func is to evaluate the time evoluation operator for the Schrödinger equation\nnorm_min: the minium norm at which to consider a state similar to Ψ as zero\nrelerr: The relative error defining the convergence condition for the restart iteration. Propagation stops when the norm of the accumulated Ψ is stable up to the given relative error\nmax_restarts: The maximum number of restart iterations. Exceeding max_restarts will throw an AssertionError.\n\nAll other keyword arguments are ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#Private-4","page":"QuantumPropagators","title":"Private","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"extend_newton_coeffs!\nextend_leja!","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"QuantumPropagators.Newton.extend_newton_coeffs!\nQuantumPropagators.Newton.extend_leja!","category":"page"},{"location":"api/quantum_propagators/#QuantumPropagators.Newton.extend_newton_coeffs!","page":"QuantumPropagators","title":"QuantumPropagators.Newton.extend_newton_coeffs!","text":"extend_newton_coeffs!(a, n_a, leja, func, n_leja, radius)\n\nExtend the array a of existing Newton coefficients for the expansion of the func from n_a coefficients to n_leja coefficients. Return a new value n_a=n_a+n_leja with the total number of Newton coefficients in the updated a.\n\nArguments\n\na: On input, a zero-based array of length n_a or greater, containing Newton coefficients. On output, array containing a total n_leja coefficients. The array a will be resized if necessary, and may have a length greater than n_leja on output\nn_a:  The number of Newton coefficients in a, on input. Elements of a  beyond the first n_a elements will be overwritten.\nleja: Array of normalized Leja points, containing at least n_leja elements.\nfunc: Function for which to calcluate Newton coeffiecients\nn_leja: The number of elements in leja to use for calculating new coefficients, and the total number of Newton coefficients on output\nradius: Normalization radius for divided differences\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Newton.extend_leja!","page":"QuantumPropagators","title":"QuantumPropagators.Newton.extend_leja!","text":"extend_leja!(leja, n, newpoints, n_use)\n\nGiven an array of n (ordered) Leja points, extract n_use points from newpoints, and append them to the existing Leja points. The array leja should be sufficiently large to hold the new Leja points, which are appended after index n_old. It will be re-allocated if necessary and may have a size of up to 2*(n+n_use).\n\nArguments\n\nleja: Array of leja values. Must contain the \"old\" leja values to be kept  in leja(0:n-1). On output, n_use new leja points will be in  leja(n+:n+n_use-1), for the original value of n.  The leja array must  use zero-based indexing.\nn: On input, number of \"old\" leja points in leja. On output, total number of leja points (i.e. n=n+n_use)\nnewpoints: On input, candidate points for new leja points.  The n_use best values will be chosen and added to leja. On output, the values of new_points are undefined.\nn_use: Number of points that should be added to leja\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagatorsSpectralRangeAPI","page":"QuantumPropagators","title":"QuantumPropagators.SpectralRange","text":"","category":"section"},{"location":"api/quantum_propagators/#Public-6","page":"QuantumPropagators","title":"Public","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"specrange","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"QuantumPropagators.SpectralRange.specrange","category":"page"},{"location":"api/quantum_propagators/#QuantumPropagators.SpectralRange.specrange","page":"QuantumPropagators","title":"QuantumPropagators.SpectralRange.specrange","text":"Calculate the spectral range of a Hamiltonian H on the real axis.\n\nE_min, E_max = specrange(H; method=:auto, kwargs...)\n\ncalculates the approximate lowest and highest eigenvalues of H. Any imaginary part in the eigenvalues is ignored: the routine is intended for (although not strictly limited to) a Hermitian H.\n\nThis delegates to\n\nspecrange(H, method; kwargs...)\n\nfor the different methods.\n\nThe default method=:auto chooses the best method for the given H. This is :diag for small matrices, and :arnoldi otherwise. Keyword arguments not relevant to the underlying implementation will be ignored.\n\n\n\n\n\nE_min, E_max = specrange(H, :arnoldi; state=random_state(H), m_min=20,\n                         m_max=60, prec=1e-3, norm_min=1e-15, enlarge=true)\n\nuses Arnoldi iteration with state as the starting vector. It approximates the eigenvalues of H with between m_min and m_max Ritz values, until the lowest and highest eigenvalue are stable to a releative precision of prec. The norm_min parameter is passed to the underlying arnoldi!.\n\nIf enlarge=true (default) the returned E_min and E_max will be enlarged via a heuristic to slightly over-estimate the spectral radius instead of under-estimating it.\n\n\n\n\n\nE_min, E_max = specrange(H, :diag)\n\nuses exact diagonization via the standard eigvals function to obtain the smallest and largest eigenvalue. This should only be used for relatively small matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#Private-5","page":"QuantumPropagators","title":"Private","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"ritzvals\nrandom_state","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"QuantumPropagators.SpectralRange.ritzvals\nQuantumPropagators.SpectralRange.random_state","category":"page"},{"location":"api/quantum_propagators/#QuantumPropagators.SpectralRange.ritzvals","page":"QuantumPropagators","title":"QuantumPropagators.SpectralRange.ritzvals","text":"Calculate a vector for Ritz values converged to a given precision.\n\nR = ritzvals(G, state, m_min, m_max=2*m_min; prec=1e-5, norm_min=1e-15)\n\ncalculates a complex vector R of at least m_min and at most m_max Ritz values.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.SpectralRange.random_state","page":"QuantumPropagators","title":"QuantumPropagators.SpectralRange.random_state","text":"Random normalized quantum state.\n\n    Ψ = random_state(H)\n\nreturns a random normalized state compatible with the Hamiltonian H. This is intended to provide a starting vector for estimating the spectral radius of H via an Arnoldi method.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagatorsStorageAPI","page":"QuantumPropagators","title":"QuantumPropagators.Storage","text":"","category":"section"},{"location":"api/quantum_propagators/#Public-7","page":"QuantumPropagators","title":"Public","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"get_from_storage!\ninit_storage\nmap_observable\nmap_observables\nwrite_to_storage!","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"QuantumPropagators.Storage.get_from_storage!\nQuantumPropagators.Storage.init_storage\nQuantumPropagators.Storage.map_observable\nQuantumPropagators.Storage.map_observables\nQuantumPropagators.Storage.write_to_storage!","category":"page"},{"location":"api/quantum_propagators/#QuantumPropagators.Storage.get_from_storage!","page":"QuantumPropagators","title":"QuantumPropagators.Storage.get_from_storage!","text":"Obtain data from storage.\n\nget_from_storage!(state, storage, i)\n\nextracts data from the storage for the i'th time slot. Invese of write_to_storage!\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Storage.init_storage","page":"QuantumPropagators","title":"QuantumPropagators.Storage.init_storage","text":"Create a storage array for propagation.\n\nstorage = init_storage(state, tlist)\n\ncreates a storage array suitable for storing a state for each point in tlist.\n\nstorage = init_storage(state, tlist, observables))\n\ncreates a storage array suitable for the data generated by the observables applied to state, see map_observables, for each point in tlist.\n\nstorage = init_storage(data, nt))\n\ncreates a storage arrays suitable for storing data nt times, where nt=length(tlist). By default, this will be a vector of typeof(data) and length nt, or a n × nt Matrix with the same eltype as data if data is a Vector of length n.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Storage.map_observable","page":"QuantumPropagators","title":"QuantumPropagators.Storage.map_observable","text":"Apply a single observable to state.\n\ndata = map_observable(observable, state)\n\nBy default, observable is assumed to be callable, and the above is equivalent to data = observable(state).\n\nIf observable is a matrix and state is a vector evaluate the expectation value of the observable as dot(state, observable, state).\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Storage.map_observables","page":"QuantumPropagators","title":"QuantumPropagators.Storage.map_observables","text":"Obtain \"observable\" data from state.\n\ndata = map_observables(observables, state)\n\ncalculates the data for a tuple of observables applied to state. For a single observable (tuple of length 1), simply return the result of map_observable.\n\nFor multiple observables, return the tuple resulting from applying map_observable for each observable. If the tuple is \"uniform\" (all elements are of the same type, e.g. if each observable calculates the expectation value of a Hermitian operator), it is converted to a Vector. This allows for compact storage in a storage array, see init_storage.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Storage.write_to_storage!","page":"QuantumPropagators","title":"QuantumPropagators.Storage.write_to_storage!","text":"Place data into storage for time slot i.\n\nwrite_to_storage!(storage, i, state, observables)\n\nFor a storage array created by init_storage, store the data obtains from map_observables into the storage for time slot i. This delegates to the more general\n\nwrite_to_storage!(storage, i, data)\n\nConceptually, this corresponds roughly to storage[i] = data, but storage may have its own idea on how to store data for a specific time slot. For example, with the default init_storage Vector data will be stored in a matrix, and write_to_storage! will in this case write data to the i'th column of the matrix.\n\nFor a given type of storage and data, it is the developer's responsibility that init_storage and write_to_storage! are compatible.\n\n\n\n\n\n","category":"function"},{"location":"manual/#User-Manual","page":"User Manual","title":"User Manual","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"The User Manual describes the API of the QuantumControl package by outlining the general procedure for defining and solving quantum control problems. See the API for a detailed reference.","category":"page"},{"location":"manual/#Setting-up-control-problems","page":"User Manual","title":"Setting up control problems","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"Quantum control problems are described by instantiating ControlProblem. Remember that a quantum control problem aims to find control parameters in the dynamical generators (Hamiltonians, Liouvillians) of a quantum system to steer the dynamics of the system in some desired way. The dynamics of system are probed by one or more quantum states, each with its particular dynamical generator. To determine how well the system dynamics meet the desired behavior, we formulate an \"objective\" for each of those quantum states.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"Most commonly, this is represented by instantiating an Objective which contains the initial state, the generator for that state's dynamics, and a target state. A time grid for the dynamics is part of ControlProblem as tlist. The objective is fulfilled when the control parameters are chosen such that the initial state evolves into the target state.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"A control problem with a single such objective already encodes the common state-to-state problem, e.g. to initialize a system into an entangled state, or to control a chemical reaction. However, there are many control problems that require simultaneously solving more than one objective. For example, finding the control parameters that implement a two-qubit quantum gate O on a quantum computer naturally translates into four simultaneous objectives, one for each two-qubit basis state: 00  O 00, 01  O 01, 10  O 10, 00  O 11. By virtue of the linearity of Hilbert space, finding a simultaneous solution to these four objectives means the any state Ψ will then evolve as Ψ  O Ψ.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"Some optimal control frameworks treat the optimization of quantum gates by numerically evolving the gate itself, U(t=0) = I  O(t=T). This is perfectly compatible with our framework: we can have a single objective for an initial \"state\" U with a target \"state\" O. However, this approach does not scale well numerically when the logical subspace of the two-qubit gate is embedded in a significantly larger physical Hilbert space: U is quadratically larger than Ψ. Moreover, the various methods implemented in the QuantumControl package are inherently parallel with respect to multiple objectives. This is why we emphasize the formulation of the control problem in terms of multiple simultaneous objectives.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"Sometimes, some of the objectives may be more important than others. In this case, instead of the standard Objective, a WeightedObjective is available. There are also situations where the notion of a \"target state\" is not meaningful. Coming back to the example of two-qubit quantum gates, one may wish to maximize the entangling power of the quantum gate, without requiring a specific gate. We extract the information about the entangling power of the dynamical generator by tracking the time evolution of a set of states (the Bell basis, as it happens), but there is no meaningful notion of a \"target state\". In this example, a user may define their own objective as a subtype of QuantumControlBase.AbstractControlObjective and include only an initial state and the dynamical generator for that state, but no target state. Indeed, an initial state and a generator are the minimum components that constitute an objective.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"Mathematically, the control problem is solved by minimizing a functional that is calculated from the time-propagated states in the objectives. By convention, this functional is passed as a keyword argument J_T when instantiating the ControlProblem. Standard functionals are defined in the QuantumControl.Functionals module. Depending on the control method, there can be additional options, either mandatory (like the χ = J_Tϕ required for Krotov's method) or optional, like constraints on the control parameters. See the documentation of the various methods implementing optimize for the options required or supported by the different solvers. All of these options can be passed as keyword arguments when instantiating the ControlProblem[1], or they can be passed later to optimize/@optimize_or_load.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"[1]: The solvers that ship with QuantumControl ignore options they do not know about. So when setting up a ControlProblem it is safe to pass a superset of options for different optimization methods.","category":"page"},{"location":"manual/#Controls-and-control-parameters","page":"User Manual","title":"Controls and control parameters","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"The controls that the QuantumControl package optimizes are implicit in the dynamical generator (Hamiltonians, Liouvillians) of the Objectives in the ControlProblem.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"The QuantumControl.Controls.getcontrols method extracts the controls from the objectives. Each control is typically time-dependent, e.g. a function ϵ(t) or a vector of pulse values on a time grid. The default format for the dynamical generators is that of a \"nested\" tuple, e.g. (Ĥ₀, (Ĥ₁, ϵ₁), (Ĥ₂, ϵ₂)) where Ĥ₀, Ĥ₁ and Ĥ₂ are (sparse) matrices, and ϵ₁ and ϵ₂ are functions of time. The format corresponds to a time-dependent Hamiltonian H₀ + ϵ₁(t) H₁ + ϵ₂(t) H₂.  For custom types describing a Hamiltonian or Liouvillian, the QuantumControl.Controls.getcontrols method must be defined to extract the controls.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"For each control, QuantumControl.Controls.discretize and QuantumControl.Controls.discretize_on_midpoints discretizes the control to an existing time grid. For controls that are implemented through some custom type, these methods must be defined to enable piecewise-constant time propagation or an optimization that assumes piecewise-constant control (most notably, Krotov's method).","category":"page"},{"location":"manual/#Time-propagation","page":"User Manual","title":"Time propagation","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"The QuantumControl package uses (and includes) QuantumPropagators.jl as the numerical back-end for simulating the time evolution of all quantum states. The main high-level function provided from that package is propagate, which simulates the dynamics of a quantum state over an entire time grid. In the context of a ControlProblem consisting of one or more Objective, there is also a propagate_objective function that provides a more convenient interface, automatically using the initial state and the dynamical generator from the objective.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"A very typical overall workflow is to set up the control problem, then propagate the objectives with the guess control to see how the system behaves, run the optimization, and then propagate the objectives again with the optimized controls, to verify the success of the optimization. For plugging in the optimized controls, propagate_objective has a controls_map argument.","category":"page"},{"location":"manual/#Optimization","page":"User Manual","title":"Optimization","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"The most direct way to solve a ControlProblem is with the optimize routine. It has a mandatory method argument that then delegates the optimization to the appropriate sub-package implementing that method. However, if the optimization takes more than a few minutes to complete, you should use @optimize_or_load instead of just optimize. This routine runs the optimization and then write the result to file. When called again, it will then simply load the result instead of rerunning the optimization.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"A workflow @optimize_or_load using integrates particularly well with using the DrWatson package to organize your research project[2]. In fact, @optimize_or_load is directly inspired by DrWatson.produce_or_load and uses it under the hood. Just like produce_or_load, @optimize_or_load by default chooses an automatic filename that includes the keyword arguments that define the ControlProblem. That automatic filename is determined by the optimization_savename routine.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"[2]: You are encouraged, but not required to use DrWatson for your projects. Here, we merely borrow some concepts from DrWatson for automatically storing computational results.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"The @optimize_or_load also embeds some metadata in the output file, including (by default) the commit hash of the project repository containing the script that called @optimize_or_load and the filename of the script and line number where the call was made. This functionality is again borrowed from DrWatson.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"The output file written by @optimize_or_load can be read via the load_optimization function. This can recover both the optimization result and the metadata.","category":"page"},{"location":"examples/#examples-list","page":"List of Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Krotov-specific-examples","page":"List of Examples","title":"Krotov-specific examples","text":"","category":"section"},{"location":"examples/","page":"List of Examples","title":"List of Examples","text":"Optimization of a State-to-State Transfer in a Two-Level-System\nOptimization of a Dissipative Quantum Gate\nPulse Parametrization\nOptimization for a perfect entangler","category":"page"},{"location":"examples/#GRAPE-specific-examples","page":"List of Examples","title":"GRAPE-specific examples","text":"","category":"section"},{"location":"examples/","page":"List of Examples","title":"List of Examples","text":"Optimization of a State-to-State Transfer in a Two-Level-System\nOptimization for a perfect entangler","category":"page"},{"location":"glossary/#Glossary","page":"Glossary","title":"Glossary","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"In the context of the JuliaQuantumControl ecosystem, we apply the following nomenclature.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Generator","page":"Glossary","title":"Generator","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Dynamical generator (Hamiltonian / Liouvillian) for the time evolution of a state, i.e., the right-hand-side of the equation of motion (up to a factor of i) such that Ψ(t+dt) = e^-i H dt Ψ(t) in the infinitesimal limit. We use the symbols G, H, or L, depending on the context (general, Hamiltonian, Liouvillian).","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Examples for supported forms a Hamiltonian are the following, from the most general case to simplest and most common case of linear controls,","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"<img src=\"../assets/controlhams.svg\" width=\"80%\"/>","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The H_0 is the Drift Term and each term under the sum over l is a Control Term. In the most general case, Eq. (G1), the control term is a Hamiltonian that depends on a set of control amplitudes. More commonly, the control term is separable into the Control Amplitude a_l(t) and the Control Operator H_l. The control amplitude a_l(t) depends in turn on the Control Function   (or simply \"control\") ϵ_l(t), which is the function we can control directly. The control may further depend on a Pulse Parametrization, ϵ_l(t) = ϵ_l(u_l(t)) or a set of Control Parameters, ϵ_l(t) = ϵ_l(u_n).","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"In an open quantum system, the structure of Eqs. (G1–G3) is the same, but with Liouvillian (super-)operators acting on density matrices instead of Hamiltonians acting on state vectors. See liouvillian with convention=:TDSE.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Drift-Term","page":"Glossary","title":"Drift Term","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A term in the dynamical generator that does not depend on any controls.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Term","page":"Glossary","title":"Control Term","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A term in the dynamical generator that depends on one or more controls.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Function","page":"Glossary","title":"Control Function","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"(aka \"Control\") A function ϵ_l(t) in the Generator that is directly controllable, typically corresponding to a physical Control Field. Conceptually a function, but may be specified in terms of Control Parameters.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Field","page":"Glossary","title":"Control Field","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A function that corresponds directly to some kind of physical drive (laser amplitude, microwave pulse, etc.). The term can be ambiguous in that it usually corresponds to the Control Function ϵ(t), but depending on how the control problem is formulated, it can also correspond to the Control Amplitude a(t).","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Operator","page":"Glossary","title":"Control Operator","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"(aka \"control Hamiltonian/Liouvillian\"). The operator H_l in Eqs. (G2, G3). This is a static operator which forms the Control Term together with a Control Amplitude. The control generator is not a well-defined concept in the most general case of non-separable controls terms, Eq. (G1)","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Amplitude","page":"Glossary","title":"Control Amplitude","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The time-dependent coefficient for the Control Operator in Eq. (G2), or, in the most general case of Eq. (G1), a function on which the control term depends directly. The mapping from a Control Function to an Control Amplitude can encompass a variety of different concepts:","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Non-linear coupling of a control field to the operator, e.g., the quadratic coupling of the laser field to a Stark shift operator\nTransfer functions, e.g., to model the response of an electronic device to the optimal control field ϵ(t).\nNoise in the amplitude of the control field\nNon-controllable aspects of the control amplitude, e.g. a \"guided\" control amplitude a_l(t) = R(t) + ϵ_l(t) or a non-controllable envelope S(t) in a_l(t) = S(t) ϵ(t) that ensures switch-on- and switch-off in a CRAB pulse ϵ(t).","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"In Qiskit Dynamics, the \"control amplitude\" is called \"Signal\", see Connecting Qiskit Pulse with Qiskit Dynamics, where a Qiskit \"pulse\" corresponds roughly to our Control Function.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Parameters","page":"Glossary","title":"Control Parameters","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Non-time-dependent parameters that a Control Function depends on, ϵ(t) = ϵ(u_n t). One common parametrization of a control field is as a Pulse, where the control parameters are the amplitude of the field at discrete points of a time grid. Parametrization as a \"pulse\" is implicit in Krotov's method and standard GRAPE.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"More generally, the control parameters could also be spectral coefficients (CRAB) or simple parameters for an analytic pulse shape (e.g., position, width, and amplitude of a Gaussian shape). All optimal control methods find optimized control fields by varying the control parameters.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Pulse","page":"Glossary","title":"Pulse","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"(aka \"control pulse\") A control field discretized to a time grid, usually on the midpoints of the time grid, in a piecewise-constant approximation. Stored as a vector of floating point values. The parametrization of a control field as a \"pulse\" is implicit for Krotov's method and standard GRAPE. One might think of these methods to optimize the control fields directly, but a conceptually cleaner understanding is to think of the discretized \"pulse\" as a vector of control parameters for the time-continuous control field.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Pulse-Parametrization","page":"Glossary","title":"Pulse Parametrization","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The use of a function u(t) such that ϵ(t) = ϵ(u(t)) for the purpose of constraining the amplitude of the control field ϵ(t). See e.g. SquareParametrization, where ϵ(t) = u^2(t) to ensure that ϵ(t) is positive. Since Krotov's method inherently has no constraints on the optimized control fields, pulse parameterization is a method of imposing constraints on the amplitude in this context. This is different from, albeit related to, the Control Amplitude, e.g. a(ϵ(t)) = ϵ^2(t) in that the amplitude parameterization does not reflect how the control field physically couples to the control Hamiltonian. Note that \"parameterization\" here has nothing to do with the \"parametrization\" in terms of Control Parameters: the pulse parametrization is a parametrization with a function, whereas the control parameters are values.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Derivative","page":"Glossary","title":"Control Derivative","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The derivative of the dynamical Generator with respect to the control ϵ(t). In the case of linear controls terms in Eq. (G3), the control derivative is the Control Operator coupling to ϵ(t). In general, however, for non-linear control terms, the control derivatives still depends on the control fields and is thus time dependent. We commonly use the symbol μ for the control derivative (reminiscent of the dipole operator)","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Parameter-Derivative","page":"Glossary","title":"Parameter Derivative","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The derivative of a control with respect to a single control parameter. The derivative of the dynamical Generator with respect to that control parameter is then the product of the Control Derivative and the parameter derivative.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Gradient","page":"Glossary","title":"Gradient","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The derivative of the optimization functional with respect to all Control Parameters, i.e. the vector of all parameter derivatives.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"note: Note\nThe above nomenclature does not consistently extend throughout the quantum control literature: the terms \"control\"/\"control term\"/\"control Hamiltonian\", and \"control\"/\"control field\"/\"control function\"/\"control pulse\"/\"pulse\" are generally somewhat ambiguous. In particular, the distinction between \"control field\" and \"pulse\" (as a parametrization of the control field in terms of amplitudes on a time grid) here is somewhat artifcial and borrowed from the Krotov Python package. However, the terminology defined in this glossary is consistently applied within the JuliaQuantumControl organization, both in the documentation and in the names of members and methods.","category":"page"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"EditURL = \"../../generate_api.jl\"","category":"page"},{"location":"api/quantum_control/#QuantumControlAPI","page":"QuantumControl","title":"QuantumControl","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl re-exports the following members from QuantumControlBase and QuantumPropagators:","category":"page"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"@optimize_or_load\nControlProblem\nMinimalObjective\nObjective\nWeightedObjective\nchain_infohooks\ndefault_optimization_savename_kwargs\nget_from_storage!\ninit_storage\ninitprop\nliouvillian\nload_optimization\noptimization_savename\noptimize\npropagate\npropagate_objective\npropagate_objectives\npropstep!\nreinitprop!\nset_state!\nwrite_to_storage!","category":"page"},{"location":"api/quantum_control/#QuantumControlControlsAPI","page":"QuantumControl","title":"QuantumControl.Controls","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl.Controls.discretize\nQuantumControl.Controls.discretize_on_midpoints\nQuantumControl.Controls.evalcontrols\nQuantumControl.Controls.evalcontrols!\nQuantumControl.Controls.get_tlist_midpoints\nQuantumControl.Controls.getcontrolderiv\nQuantumControl.Controls.getcontrolderivs\nQuantumControl.Controls.getcontrols\nQuantumControl.Controls.substitute_controls","category":"page"},{"location":"api/quantum_control/#QuantumControlFunctionalsAPI","page":"QuantumControl","title":"QuantumControl.Functionals","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl.Functionals.J_T_re\nQuantumControl.Functionals.J_T_sm\nQuantumControl.Functionals.J_T_ss\nQuantumControl.Functionals.gate_functional\nQuantumControl.Functionals.make_chi\nQuantumControl.Functionals.make_gate_chi\nQuantumControl.Functionals.make_gradient","category":"page"},{"location":"api/quantum_control/#QuantumControlShapesAPI","page":"QuantumControl","title":"QuantumControl.Shapes","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl.Shapes.blackman\nQuantumControl.Shapes.box\nQuantumControl.Shapes.flattop","category":"page"},{"location":"api/quantum_control/#QuantumControlWeylChamberAPI","page":"QuantumControl","title":"QuantumControl.WeylChamber","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl.WeylChamber.D_PE\nQuantumControl.WeylChamber.canonical_gate\nQuantumControl.WeylChamber.gate_concurrence\nQuantumControl.WeylChamber.in_weyl_chamber\nQuantumControl.WeylChamber.local_invariants\nQuantumControl.WeylChamber.unitarity\nQuantumControl.WeylChamber.weyl_chamber_coordinates\nQuantumControl.WeylChamber.weyl_chamber_region","category":"page"},{"location":"api/quantum_control/#Subpackages","page":"QuantumControl","title":"Subpackages","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl contains the following sub-packages from the JuliaQuantumControl organization:","category":"page"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumPropagators\nQuantumControlBase\nKrotov\nGRAPE","category":"page"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"These (and their submodules) can be accessed directly, e.g.","category":"page"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"julia> using QuantumControl\n\njulia> QuantumControl.QuantumPropagators.SpectralRange.specrange\nspecrange (generic function with 5 methods)","category":"page"},{"location":"#QuantumControl.jl","page":"Home","title":"QuantumControl.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumControl.jl is a Julia framework for quantum optimal control.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quantum optimal control attempts to steer a quantum system in some desired way by finding optimal control parameters or control fields inside the system Hamiltonian or Liouvillian. Typical control tasks are the preparation of a specific quantum state or the realization of a logical gate in a quantum computer (\"pulse level control\"). Thus, quantum control theory is a critical part of realizing quantum technologies at the lowest level. Numerical methods of open-loop quantum control (methods that do not involve measurement feedback from a physical quantum device) such as Krotov's method and GRAPE address the control problem by simulating the dynamics of the system and then iteratively improving the value of a functional that encodes the desired outcome.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The QuantumControl.jl package collects the packages in the JuliaQuantumControl organization and provides a single coherent API for solving the quantum control problem.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the installation instructions on Github.\nLook at a simple example for a state-to-state transition with Krotov's method to get a feeling for how the QuantumControl package is intended to be used, or look at the larger list of Examples.\nRead the Glossary and User Manual to understand the philosophy of the framework.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"glossary.md\",\n    \"manual.md\",\n    \"howto.md\",\n]\nDepth = 2","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"examples/index.md\",\n]","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"api/quantum_control.md\",\n]\nDepth = 1","category":"page"},{"location":"#Sub-Packages","page":"Home","title":"Sub-Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"api/quantum_propagators.md\",\n    \"api/quantum_control_base.md\",\n    \"api/krotov.md\",\n    \"api/grape.md\",\n]\nDepth = 1","category":"page"},{"location":"#History","page":"Home","title":"History","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"history.md\",\n]\nDepth = 1","category":"page"}]
}

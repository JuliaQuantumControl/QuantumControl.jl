var documenterSearchIndex = {"docs":
[{"location":"howto/#Howto","page":"Howto","title":"Howto","text":"","category":"section"},{"location":"howto/","page":"Howto","title":"Howto","text":"TODO","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]\nDepth = 4","category":"page"},{"location":"api/#QuantumControl","page":"API","title":"QuantumControl","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"optimize","category":"page"},{"location":"api/#QuantumControl.optimize","page":"API","title":"QuantumControl.optimize","text":"Optimize a quantum control problem.\n\nopt_result = optimize(problem; method=<method>, kwargs...)\n\noptimizes towards a solution of given problem with the given optimization method. All keyword arguments update (overwrite) parameters in problem\n\n\n\n\n\nopt_result = optimize(problem; method=:krotov, kwargs...)\n\noptimizes problem using Krotov's method, see Krotov.optimize_pulses.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"All other types and methods in QuantumControl or its submodules are re-exported from lower level packages (QuantumControlBase, QuantumPropagators, etc.):","category":"page"},{"location":"api/","page":"API","title":"API","text":"ControlProblem\nObjective\nWeightedObjective\ndiscretize\ndiscretize_on_midpoints\ngetcontrols\nget_control_parameters\nliouvillian\npropagate\npropstep!","category":"page"},{"location":"api/#QuantumControl.shapes","page":"API","title":"QuantumControl.shapes","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"QuantumControl.shapes.flattop\nQuantumControl.shapes.box\nQuantumControl.shapes.blackman","category":"page"},{"location":"api/#QuantumControl.functionals","page":"API","title":"QuantumControl.functionals","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"QuantumControl.functionals.F_ss\nQuantumControl.functionals.J_T_ss\nQuantumControl.functionals.chi_ss!\nQuantumControl.functionals.F_sm\nQuantumControl.functionals.J_T_sm\nQuantumControl.functionals.chi_sm!\nQuantumControl.functionals.F_re\nQuantumControl.functionals.J_T_re\nQuantumControl.functionals.chi_re!\nQuantumControl.functionals.grad_J_T_sm!","category":"page"},{"location":"api/#Krotov","page":"API","title":"Krotov","text":"","category":"section"},{"location":"api/#Public","page":"API","title":"Public","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Krotov.SquareParametrization\nKrotov.TanhParametrization\nKrotov.TanhSqParametrization\nKrotov.LogisticParametrization,\nKrotov.LogisticSqParametrization\nKrotov.optimize_pulses","category":"page"},{"location":"api/#Krotov.SquareParametrization","page":"API","title":"Krotov.SquareParametrization","text":"Parametrization ϵ(t) = u²(t), enforcing pulse values ≥ 0.\n\n\n\n\n\n","category":"function"},{"location":"api/#Krotov.TanhParametrization","page":"API","title":"Krotov.TanhParametrization","text":"Parametrization with a tanh function that enforces ϵmin < ϵ(t) < ϵmax.\n\n\n\n\n\n","category":"function"},{"location":"api/#Krotov.TanhSqParametrization","page":"API","title":"Krotov.TanhSqParametrization","text":"Parametrization with a tanh² function that enforces 0  ϵ(t)  ϵ_max.\n\n\n\n\n\n","category":"function"},{"location":"api/#Krotov.optimize_pulses","page":"API","title":"Krotov.optimize_pulses","text":"Use Krotov's method to optimize the given optimization problem.\n\nresult = optimize_pulses(problem; kwargs...)\n\noptimizes the given control problem, see QuantumControlBase.ControlProblem.\n\nKeyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of problem. Any kwargs passed directly to optimize_pulses will update (overwrite) the parameters in problem.\n\nRequired problem keyword arguments\n\nJ_T: A function J_T(ϕ, objectives) that evaluates the final time functional from a list ϕ of forward-propagated states and problem.objectives.\nchi: A function chi!(χ, ϕ, objectives) what receives a list ϕ of the forward propagates state and must set χₖ=J_Tϕₖ.\n\nOptional problem keyword arguments\n\nThe following keyword arguments are supported (with default values):\n\nsigma=nothing: Function that calculate the second-order contribution. If  not given, the first-order Krotov method is used.\niter_start=0: the initial iteration number\niter_stop=5000: the maximum iteration number\nprop_method=:auto: The propagation method to use\nupdate_hook: A function that receives the Krotov workspace, the iteration  number, the list of updated pulses and the list of guess pulses as  positional arguments. The function may mutate any of its arguments. This may  be used e.g. to apply a spectral filter to the updated pulses, or to update  propagation workspaces inside the Krotov workspace.\ninfo_hook: A function that receives the same argumens as update_hook, in  order to write information about the current iteration to the screen or to a  file. The default info_hook prints a table with convergence information to  the screen. Runs after update_hook. The info_hook function may return a  tuple, which is stored in the list of records inside the  KrotovResult object.\ncheck_convergence: a function to check whether convergence has been reached. Receives a KrotovResult object result, and should set result.converged to true and result.message to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with ∘. The convergence check is performed after any calls to update_hook and info_hook.\n\n\n\n\n\n","category":"function"},{"location":"api/#Private","page":"API","title":"Private","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Krotov]\nPrivate = true\nPublic = false","category":"page"},{"location":"api/#Krotov.KrotovResult","page":"API","title":"Krotov.KrotovResult","text":"Result object returned by optimize_pulses.\n\n\n\n\n\n","category":"type"},{"location":"api/#Krotov.PulseParametrization","page":"API","title":"Krotov.PulseParametrization","text":"Specification for a \"time-local\" pulse parametrization.\n\nThe parametrization is given as a collection of three functions:\n\nϵ(u(t))\nu(ϵ(t))\nϵu as a function of u(t).\n\n\n\n\n\n","category":"type"},{"location":"api/#Krotov.NoParametrization-Tuple{}","page":"API","title":"Krotov.NoParametrization","text":"Parametrization where ϵ(t)  u(t).\n\n\n\n\n\n","category":"method"},{"location":"api/#Krotov.print_table-Tuple{Any, Any, Vararg{Any, N} where N}","page":"API","title":"Krotov.print_table","text":"Default info_hook\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase","page":"API","title":"QuantumControlBase","text":"","category":"section"},{"location":"api/#Public-2","page":"API","title":"Public","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumControlBase]\nPrivate = false\nPublic = true","category":"page"},{"location":"api/#QuantumControlBase.ControlProblem","page":"API","title":"QuantumControlBase.ControlProblem","text":"A full control problem with multiple objectives.\n\nControlProblem(\n   objectives=<list of objectives>,\n   pulse_options=<dict of controls to pulse options>,\n   tlist=<time grid>,\n   kwargs...\n)\n\nNote that the control problem can only be instantiated via keyword arguments.\n\nThe objectives are a list of AbstractControlObjective instances, each defining an initial state and a dynamical generator for the evolution of that state. Usually, the objective will also include a target state (see Objective) and possibly a weight (see WeightedObjective.\n\nThe pulse_options are a dictionary (IdDict) mapping controls that occur in the objectives to properties specific to the control method.\n\nThe tlist is the time grid on which the time evolution of the initial states of each objective should be propagated.\n\nThe remaining kwargs are keyword arguments that are passed directly to the optimal control method. These typically include e.g. the optimization functional.\n\nThe control problem is solved by finding a set of controls that simultaneously fulfill all objectives.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumControlBase.GradGenerator","page":"API","title":"QuantumControlBase.GradGenerator","text":"Static generator for the standard dynamic gradient.\n\nG::GradGenerator = evalcontrols(G_of_t::TimeDependentGradGenerator, vals_dict)\n\nis the result of plugging in specific values for all controls in a TimeDependentGradGenerator. See evalcontrols and evalcontrols!.\n\nThe resulting object can be multiplied directly with a GradVector, e.g., in the process of evaluating a piecewise-constant time propagation.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumControlBase.GradVector","page":"API","title":"QuantumControlBase.GradVector","text":"Extended state-vector for the dynamic gradient.\n\nΨ̃ = GradVector(Ψ, num_controls)\n\nfor an initial state Ψ and num_controls control fields.\n\nThe GradVector conceptually corresponds to a direct-sum (block) column-vector Ψ = (Ψ₁ Ψ₂  Ψₙ Ψ)^T, where n is num_controls. With a matching G as in the documentation of TimeDependentGradGenerator, we have\n\nG Ψ = beginpmatrix\nH Ψ₁ + H₁Ψ \nvdots \nH Ψₙ + HₙΨ \nH Ψ\nendpmatrix\n\nand\n\ne^-i G dt beginpmatrix 0  vdots  0  Ψ endpmatrix\n= beginpmatrix\nfracϵ₁ e^-i H dt Ψ \nvdots \nfracϵₙ e^-i H dt Ψ \ne^-i H dt Ψ\nendpmatrix\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumControlBase.Objective","page":"API","title":"QuantumControlBase.Objective","text":"Standard optimization objective.\n\nObjective(;\n    initial_state=<initial_state>,\n    generator=<genenerator>,\n    target_state=<target_state>\n)\n\ndescribes an optimization objective where the time evoluation of the given initial_state under the given generator aims towards target_state. The generator here is e.g. a time-dependent Hamiltonian or Liouvillian.\n\nThe most common control problems in quantum control, e.g. state-to-state transitions or quantum gate implementations can be expressed by simultaneously fulfilling multiple objectives of this type.\n\nNote that the objective can only be instantiated via keyword arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumControlBase.TimeDependentGradGenerator","page":"API","title":"QuantumControlBase.TimeDependentGradGenerator","text":"Extended generator for the standard dynamic gradient.\n\nG̃ = TimeDependentGradGenerator(G)\n\ncontains the original time-dependent generator G (a Hamiltonian or Liouvillian) in G̃.G, a vector of control derivatives Gϵₗ(t) in G̃.control_derivs, and the controls in G̃.controls.\n\nFor a generator G = H(t) = H₀ + ϵ₁(t) H₁ +  +  ϵₙ(t) Hₙ, this extended generator encodes the block-matrix\n\nG = beginpmatrix\n         H(t)    0      dots     0       H₁     \n         0       H(t)   dots     0       H₂     \n    vdots              ddots            vdots \n         0       0      dots     H(t)    Hₙ     \n         0       0      dots     0       H(t)\nendpmatrix\n\nNote that the Gϵₗ(t) (Hₗ in the above example) are functions, to account for the possibility of non-linear control terms, see getcontrolderiv.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumControlBase.WeightedObjective","page":"API","title":"QuantumControlBase.WeightedObjective","text":"Standard optimization objective with a weight.\n\nWeightedObjective(;\n    initial_state=<initial_state>,\n    generator=<genenerator>,\n    target_state=<target_state>,\n    weight=<weight>\n)\n\ninitializes a control objective like Objective, but with an additional weight parameter (a float generally between 0 and 1) that weights the objective relative to other objectives that are part of the same control problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumControlBase.F_re-Tuple{Any, Any}","page":"API","title":"QuantumControlBase.F_re","text":"Real-part fidelity.\n\nF_re(ϕ, objectives; τ=nothing)\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.F_sm-Tuple{Any, Any}","page":"API","title":"QuantumControlBase.F_sm","text":"Square-modulus fidelity.\n\nF_sm(ϕ, objectives; τ=nothing)\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.F_ss-Tuple{Any, Any}","page":"API","title":"QuantumControlBase.F_ss","text":"State-to-state phase-insensitive fidelity.\n\nF_ss(ϕ, objectives; τ=nothing)\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.J_T_re-Tuple{Any, Any}","page":"API","title":"QuantumControlBase.J_T_re","text":"Real-part functional.\n\nJ_T_re(ϕ, objectives; τ=nothing)\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.J_T_sm-Tuple{Any, Any}","page":"API","title":"QuantumControlBase.J_T_sm","text":"Square-modulus functional.\n\nJ_T_sm(ϕ, objectives; τ=nothing)\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.J_T_ss-Tuple{Any, Any}","page":"API","title":"QuantumControlBase.J_T_ss","text":"State-to-state phase-insensitive functional.\n\nJ_T_ss(ϕ, objectives; τ=nothing)\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.blackman-Tuple{Any, Any, Any}","page":"API","title":"QuantumControlBase.blackman","text":"Blackman window shape.\n\nblackman(t, t₀, T; a=0.16)\n\ncalculates\n\nB(t t_0 T) =\n    frac12left(\n        1 - a - cosleft(2π fract - t_0T - t_0right)\n        + a cosleft(4π fract - t_0T - t_0right)\n    right)\n\nfor a scalar t, with a = 0.16.\n\nSee http://en.wikipedia.org/wiki/Window_function#Blackman_windows\n\nA Blackman shape looks nearly identical to a Gaussian with a 6-sigma interval between t₀ and T.  Unlike the Gaussian, however, it will go exactly to zero at the edges. Thus, Blackman pulses are often preferable to Gaussians.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.box-Tuple{Any, Any, Any}","page":"API","title":"QuantumControlBase.box","text":"Box shape (Theta-function).\n\nbox(t, t₀, T)\n\nevaluates the Heaviside (Theta-) function Theta(t) = 1 for t_0 le t le T; and Theta(t) = 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.chi_re!-Tuple{Any, Any, Any}","page":"API","title":"QuantumControlBase.chi_re!","text":"Krotov-states χ for functional J_T_re.\n\nchi_re!(χ, ϕ, objectives; τ=nothing)\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.chi_sm!-Tuple{Any, Any, Any}","page":"API","title":"QuantumControlBase.chi_sm!","text":"Krotov-states χ for functional J_T_sm.\n\nchi_sm!(χ, ϕ, objectives; τ=nothing)\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.chi_ss!-Tuple{Any, Any, Any}","page":"API","title":"QuantumControlBase.chi_ss!","text":"Krotov-states χ for functional J_T_ss.\n\nchi_ss!(χ, ϕ, objectives; τ=nothing)\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.discretize-Tuple{Function, Any}","page":"API","title":"QuantumControlBase.discretize","text":"Evaluate control at every point of tlist.\n\nvalues = discretize(control, tlist; via_midpoints=true)\n\ndiscretizes the given control to a Vector of values defined on the points of tlist.\n\nIf control is a function, it will will first be evaluated at the midpoint of tlist, see discretize_on_midpoints, and then the values on the midpoints are converted to values on tlist. This discretization is more stable than directly evaluationg the control function at the values of tlist, and ensures that repeated round-trips between discretize and discretize_on_midpoints can be done safely, see the note in the documentation of discretize_on_midpoints.\n\nThe latter can still be achieved by passing via_midpoints=false. While such a direct discretization is suitable e.g. for plotting, but it is unsuitable for round-trips between discretize and discretize_on_midpoints  (constant controls on tlist may result in a zig-zag on the intervals of tlist).\n\nIf control is a vector, it will be returned un-modified if it is of the same length as tlist. Otherwise, control must have one less value than tlist, and is assumed to be defined on the midpoins of tlist. In that case, discretize acts as the inverse of discretize_on_midpoints. See discretize_on_midpoints for how control values on tlist and control values on the intervals of tlist are related.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T<:Function","page":"API","title":"QuantumControlBase.discretize_on_midpoints","text":"Evaluate control at the midpoints of tlist.\n\nvalues = discretize_on_midpoints(control, tlist)\n\ndiscretizes the given control to a Vector of values on the midpoints of tlist. Hence, the resulting values will contain one less value than tlist.\n\nIf control is a vector of values defined on tlist (i.e., of the same length as tlist), it will be converted to a vector of values on the intervals of tlist. The value for the first and last \"midpoint\" will remain the original values at the beginning and end of tlist, in order to ensure exact bounary conditions. For all other midpoints, the value for that midpoint will be calculated by \"un-averaging\".\n\nFor example, for a control and tlist of length 5, consider the following diagram:\n\ntlist index:       1   2   3   4   5\ntlist:             ⋅   ⋅   ⋅   ⋅   ⋅   input values cᵢ (i ∈ 1..5)\n                   |̂/ ̄ ̄ ̂\\ / ̂\\ / ̂ ̄ ̄\\|̂\nmidpoints:         x     x   x     x   output values pᵢ (i ∈ 1..4)\nmidpoints index:   1     2   3     4\n\nWe will have p₁=c₁ for the first value, p₄=c₅ for the last value. For all other points, the control values cᵢ = fracp_i-1 + p_i2 are the average of the values on the midpoints. This implies the \"un-averaging\" for the midpoint values pᵢ = 2 c_i - p_i-1.\n\nnote: Note\nAn arbitrary input control array may not be compatible with the above averaging formula. In this case, the conversion will be \"lossy\" (discretize will not recover the original control array; the difference should be considered a \"discretization error\"). However, any further round-trip conversions between points and intervals are bijective and preserve the boundary conditions. In this case, the discretize_on_midpoints and discretize methods are each other's inverse. This also implies that for an optimal control procedure, it is safe to modify midpoint values. Modifying the the values on the time grid directly on the other hand may accumulate discretization errors.\n\nIf control is a vector of one less length than tlist, it will be returned unchanged, under the assumption that the input is already properly discretized.\n\nIf control is a function, the function will be directly evaluated at the midpoints marked as x in the above diagram..\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.evalcontrols!-Union{Tuple{D}, Tuple{Any, Tuple, D}} where D<:AbstractDict","page":"API","title":"QuantumControlBase.evalcontrols!","text":"In-place version of evalcontrols.\n\nevalcontrols!(G, generator, vals_dict)\n\nacts as evalcontrols, but modifies G in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.evalcontrols-Union{Tuple{D}, Tuple{Tuple, D}} where D<:AbstractDict","page":"API","title":"QuantumControlBase.evalcontrols","text":"Replace the controls in generator with static values.\n\nG = evalcontrols(generator, vals_dict)\n\nreplaces the time-dependent controls in generator with the values in vals_dict and returns the static operator G.\n\nThe vals_dict is a dictionary (IdDict) mapping controls as returned by getcontrols(generator) to values.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.flattop-Tuple{Any}","page":"API","title":"QuantumControlBase.flattop","text":"Flat shape (one) with a switch-on/switch-off from zero.\n\nflattop(t; t₀, T, t_rise, t_fall=t_rise, func=:blackman)\n\nevaluates a shape function that starts at 0 at t=t₀, and ramps to to 1 during the t_rise interval. The function then remains at value 1, before ramping down to 0 again during the interval t_fall before T. For t  t₀ and t  T, the shape is zero.\n\nThe default switch-on/-off shape is half of a Blackman window (see blackman).\n\nFor func=:sinsq, the switch-on/-off shape is a sine-squared curve.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.get_control_parameters-Tuple","page":"API","title":"QuantumControlBase.get_control_parameters","text":"Collect all control parameters from the given objectives.\n\nget_control_parameters(objectives...; kwargs...)\n\nreturns a vector of control parameters extracted from the controls in objectives. This first extracts the controls with [getcontrols] and then the \"control parameters\" from each control. What are the \"control parameters\" are depends on the type of the control. For controls that are function ϵ(t), the control parameters are the values of the control function on intervals of the time grid. The time grid in the case must be passed as a keyword argument tlist.\n\nThe control parameters for multiple controls will be concatenated in the returned vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.get_control_parameters-Tuple{Function}","page":"API","title":"QuantumControlBase.get_control_parameters","text":"get_control_parameters(func; tlist, on_midpoints=true)\n\nreturns the control parameters of a control function by discretizing to the time grid in tlist. By default, the discretization is on intervals (midpoints) of the time grid. With on_midpoints=false, the discretization will be on the actual points of the time grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.getcontrolderiv-Tuple{Tuple, Any}","page":"API","title":"QuantumControlBase.getcontrolderiv","text":"Get the derivative of the generator G w.r.t. the control ϵ(t).\n\nμ  = getcontrolderiv(generator, control)\n\nreturns nothing if the generator (Hamiltonian or Liouvillian) does not depend on control, or a function μ(v) that evaluates\n\nμ(v) = leftfracGϵ(t)rightvert_ϵ(t)=v\n\notherwise. That is, a call μ(v) will return the static operator resulting from evaluating the derivative of the dynamical generator G with respect to the control filed ϵ(t) at a particular point in time where the control field takes the value v.\n\nNote that for the common case of linear control terms, e.g., H = H_0 + sum_l ϵ_l(t) H_l, the derivative Hϵ_l(t) is simply the control Hamiltonian H_l. Thus, the resulting function μ will simply return H_l, ignoring the argument v.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.getcontrolderivs-Tuple{Any, Any}","page":"API","title":"QuantumControlBase.getcontrolderivs","text":"Get a vector of the derivatives of generator w.r.t. each control.\n\ngetcontrolderivs(generator, controls)\n\nreturn as vector containing the derivative of generator with respect to each control in controls. The elements of the vector are either nothing if generator does not depend on that particular control, or a function μ(α) that evaluates the derivative for a particular value of the control, see getcontrolderiv.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.getcontrols-Tuple{Tuple}","page":"API","title":"QuantumControlBase.getcontrols","text":"Extract a Tuple of controls.\n\ncontrols = getcontrols(generator)\n\nextracts the controls from a single dynamical generator.\n\ncontrols = getcontrols(objectives)\n\nextracts the controls from a list of objectives (i.e., from each objective's generator)\n\nIn either case, controls that occur multiple times, either in a single generator, or throughout the different objectives, will occur only once in the result.\n\nBy default, assumes that any generator is a nested Tuple, e.g. (H0, (H1, ϵ1), (H2, ϵ2), ...) and extracts (ϵ1, ϵ2)\n\nEach control must be a valid argument for discretize.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.grad_J_T_sm!-Tuple{Any, Any, Any}","page":"API","title":"QuantumControlBase.grad_J_T_sm!","text":"Gradient for J_T_sm.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.liouvillian","page":"API","title":"QuantumControlBase.liouvillian","text":"Construct a Liouvillian super-operator.\n\nℒ = liouvillian(Ĥ, c_ops=(); convention=:LvN)\n\ncalculates the sparse Liouvillian super-operator ℒ from the Hamiltonian Ĥ and a list c_ops of Lindblad operators.\n\nWith convention=:LvN, applying the resulting ℒ to a vectorized density matrix ρ⃗ calculates fracddt vecrho(t) = ℒ vecrho(t) equivalent to the Liouville-von-Neumann equation for the density matrix ρ,\n\nfracddt ρ(t)\n= -i H ρ(t) + sum_kleft(\n    A_k ρ A_k^dagger\n    - frac12 A_k^dagger A_k ρ\n    - frac12 ρ A_k^dagger A_k\n  right)\n\nwhere the Lindblad operators A_k are the elements of c_ops.\n\nThe Hamiltonian H may be time-dependent, using a nested-tuple format by default, e.g., (Ĥ₀, (H₁, ϵ₁), (H₂, ϵ₂)), where ϵ₁ and ϵ₂ are functions of time. In this case, the resulting ℒ will also be in nested tuple format, ℒ = (ℒ₀, (ℒ₁, ϵ₁), (ℒ₂, ϵ₂)), where the initial element contains the superoperator ℒ₀ for the static component of the Liouvillian, i.e., the commutator with the drift Hamiltonian Ĥ₀, plus the dissipator (sum over k), as a sparse matrix. Time-dependent Lindblad operators are not supported. The remaining elements are tuples (ℒ₁, ϵ₁) and (ℒ₂, ϵ₂) corresponding to the commutators with the two control Hamiltonians, where ℒ₁ and ℒ₂ again are sparse matrices.\n\nIf H is not time-dependent, the resulting ℒ will be a single-element tuple containing the Liouvillian as a sparse matrix, ℒ = (ℒ₀, ).\n\nWith convention=:TDSE, the Liouvillian will be constructed for the equation of motion -i hbar fracddt vecrho(t) = ℒ vecrho(t) to match exactly the form of the time-dependent Schrödinger equation. While this notation is not standard in the literature of open quantum systems, it has the benefit that the resulting ℒ can be used in a numerical propagator for a (non-Hermitian) Schrödinger equation without any change. Thus, for numerical applications, convention=:TDSE is generally preferred. The returned ℒ between the two conventions differs only by a factor of i, since we generally assume hbar=1.\n\nThe convention keyword argument is mandatory, to force a conscious choice.\n\nSee Goerz et. al. \"Optimal control theory for a unitary operation under dissipative evolution\", arXiv 1312.0111v2, Appendix B.2 for the explicit construction of the Liouvillian superoperator as a sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumControlBase.obj_genfunc-Tuple{QuantumControlBase.AbstractControlObjective, Any}","page":"API","title":"QuantumControlBase.obj_genfunc","text":"Construct a genfunc suitable for propagate from an objective.\n\ngenfunc = obj_genfunc(obj, tlist; controls_map=IdDict())\n\ncan be passed to propagate to propagate under the dynamical generator in obj. If given, controls_map defines replacements for the control\n\nIf given, control_map defines replacements for the controls in obj.generator. This allows, e.g., to replace the controls with those resulting from an optimization.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumControlBase.resetgradvec!-Union{Tuple{GradVector{T}}, Tuple{T}} where T","page":"API","title":"QuantumControlBase.resetgradvec!","text":"Reset the given gradient vector for a new gradient evaluation.\n\nresetgradvec!(Ψ̃::GradVector)\n\nzeroes out Ψ̃.grad_states but leaves Ψ̃.state unaffected.\n\nresetgradvec!(Ψ̃::GradVector, Ψ)\n\nadditionally sets Ψ̃.state to Ψ.\n\n\n\n\n\n","category":"method"},{"location":"api/#Private-2","page":"API","title":"Private","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"QuantumControlBase.AbstractControlObjective\nQuantumControlBase.adjoint\nQuantumControlBase.f_tau\nQuantumControlBase.initobjpropwrk","category":"page"},{"location":"api/#QuantumControlBase.AbstractControlObjective","page":"API","title":"QuantumControlBase.AbstractControlObjective","text":"Base class for a single optimization objective.\n\nAll objectives must have a field initial_state and a field generator, at minimum.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.adjoint","page":"API","title":"Base.adjoint","text":"adjoint(objective)\n\nAdjoint of a control objective. The adjoint objective contains the adjoint of the dynamical generator obj.generator, and adjoints of the obj.initial_state / obj.target_state if these exist and have an adjoint.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumControlBase.f_tau","page":"API","title":"QuantumControlBase.f_tau","text":"Average complex overlap of the target states with forward-propagated states.\n\nf_tau(ϕ, objectives; τ=nothing)\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumControlBase.initobjpropwrk","page":"API","title":"QuantumControlBase.initobjpropwrk","text":"wrk = initobjpropwrk(obj, tlist, method; kwargs...)\n\ninitializes a workspace for the propagation of anAbstractControlObjective.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators","page":"API","title":"QuantumPropagators","text":"","category":"section"},{"location":"api/#Public-3","page":"API","title":"Public","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"specrange\ncheby_coeffs\ncheby_coeffs!\nChebyWrk\ncheby!\nNewtonWrk\nnewton!\nExpPropWrk\nexpprop!\ninit_storage\nmap_observables\nmap_observable\nwrite_to_storage!\nget_from_storage!\ninitpropwrk\npropstep!\npropagate","category":"page"},{"location":"api/#QuantumPropagators.specrange","page":"API","title":"QuantumPropagators.specrange","text":"Calculate the spectral range of a Hamiltonian H on the real axis.\n\nE_min, E_max = specrange(H; method=:auto, kwargs...)\n\ncalculates the approximate lowest and highest eigenvalues of H. Any imaginary part in the eigenvalues is ignored: the routine is intended for (although not strictly limited to) a Hermitian H.\n\nThis delegates to\n\nspecrange(H, method; kwargs...)\n\nfor the different methods.\n\nThe default method=:auto chooses the best method for the given H. This is :diag for small matrices, and :arnoldi otherwise. Keyword arguments not relevant to the underlying implementation will be ignored.\n\n\n\n\n\nE_min, E_max = specrange(H, :arnoldi; state=random_state(H), m_min=20,\n                         m_max=60, prec=1e-3, nom_min=1e-15, enlarge=true)\n\nuses Arnoldi iteration with state as the starting vector. It approximates the eigenvalues of H with between m_min and m_max Ritz values, until the lowest and highest eigenvalue are stable to a releative precision of prec. The norm_min parameter is passed to the underlying arnoldi!.\n\nIf enlarge=true (default) the returned E_min and E_max will be enlarged via a heuristic to slightly over-estimate the spectral radius instead of under-estimating it.\n\n\n\n\n\nE_min, E_max = specrange(H, :diag)\n\nuses exact diagonization via the standard eigenvals function to obtain the smallest and largest eigenvalue. This should only be used for relatively small matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators.cheby_coeffs","page":"API","title":"QuantumPropagators.cheby_coeffs","text":"Calculate Chebychev coefficients.\n\nReturn an array of coefficiencts larger than limit.\n\nArguments\n\nΔ: the spectral radius of the underlying operator\ndt: the time step\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators.cheby_coeffs!","page":"API","title":"QuantumPropagators.cheby_coeffs!","text":"Calculate Chebychev coefficients in-place.\n\nn = cheby_coeffs!(coeffs, Δ, dt, limit=1e-12)\n\noverwrites the first n values in coeffs with new coefficients larger than limit for the given new spectral radius Δ and time step dt. The coeffs array will be resized if necessary, and may length > n on exit.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators.ChebyWrk","page":"API","title":"QuantumPropagators.ChebyWrk","text":"Workspace for the Chebychev propagation routine.\n\n    ChebyWrk(Ψ, Δ, E_min, dt; limit=1e-12)\n\ninitializes the workspace for the propagation of a state similar to Ψ under a Hamiltonian with eigenvalues between E_min and E_min + Δ, and a time step dt. Chebychev coefficients smaller than the given limit are discarded.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumPropagators.cheby!","page":"API","title":"QuantumPropagators.cheby!","text":"Evaluate Ψ = exp(-i H dt) Ψ in-place.\n\ncheby!(Ψ, H, dt, wrk; E_min=nothing, check_normalization=false)\n\nArgs:\n\nΨ: on input, initial vector. Will be overwritten with result.\nH: Hermitian operator\ndt: time step\nwrk: internal workspace\nE_min: minimum eigenvalue of H, to be used instead of the E_min from the  initialization of wrk. The same wrk may be used for different values  E_min, as long as the spectra radius Δ and the time step dt are the  same as those used for the initialization of wrk.\ncheck_normalizataion: perform checks that the H does not exceed the spectral radius for which the the workspace was initialized.\n\nThe routine will not allocate any internal storage. This implementation requires copyto! lmul!, and axpy! to be implemented for Ψ, and the three-argument mul! for Ψ and H.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators.NewtonWrk","page":"API","title":"QuantumPropagators.NewtonWrk","text":"    NewtonWrk(v0, m_max=10)\n\nWorkspace for the Newton-with-restarted-Arnoldi propagation routine.\n\nInitializes the workspace for the propagation of a vector v0, using a maximum Krylov dimension of m_max in each restart iteration. Note that m_max should be smaller than the length of v0.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumPropagators.newton!","page":"API","title":"QuantumPropagators.newton!","text":"newton!(Ψ, H, dt, wrk; func=(z -> exp(-1im*z)), norm_min=1e-14, relerr=1e-12,\n        max_restarts=50)\n\nEvaluate Ψ = func(H*dt) Ψ using a Newton-with-restarted-Arnoldi scheme.\n\nArguments\n\nΨ: The state to propagate, will be overwritten in-place with the propagated state\nH: Operator acting on Ψ. Together with dt, this is the argument to func\ndt: Implicit time step. Together with H, this is the argument to func\nwkr: Work array, initialized with NewtonWrk\nfunc: The function to apply to H dt, taking a single (scalar) complex-valued argument z in place of H dt. The default func is to evaluate the time evoluation operator for the Schrödinger equation\nnorm_min: the minium norm at which to consider a state similar to Ψ as zero\nrelerr: The relative error defining the convergence condition for the restart iteration. Propagation stops when the norm of the accumulated Ψ is stable up to the given relative error\nmax_restart: The maximum number of restart iterations. Exceeding max_restart will throw an AssertionError.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators.ExpPropWrk","page":"API","title":"QuantumPropagators.ExpPropWrk","text":"    ExpPropWrk(v0)\n\nWorkspace for propagation via direct matrix exponentiation.\n\nInitializes the workspace for the propagation of a vector v0\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumPropagators.expprop!","page":"API","title":"QuantumPropagators.expprop!","text":"expprop!(Ψ, H, dt, wrk; func=(H_dt -> exp(-1im * H_dt)))\n\nEvaluate Ψ = func(H*dt) Ψ by directly evaluating U = func(H*dt), i.e. by matrix exponentiation for the default func, and then multiplying U and Ψ in-place with mul!.\n\nThe workspace wrk must be initialized with ExpPropWrk to provide storage for a temporary state.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators.init_storage","page":"API","title":"QuantumPropagators.init_storage","text":"Create a storage array for propagate.\n\nstorage = init_storage(state, tlist)\n\ncreates a storage array suitable for storing a state for each point in tlist.\n\nstorage = init_storage(state, tlist, observables))\n\ncreates a storage array suitable for the data generated by the observables applied to state, see map_observables, for each point in tlist.\n\nstorage = init_storage(data, nt))\n\ncreates a storage arrays suitable for storing data nt times, where nt=length(tlist). By default, this will be a vector of typeof(data) and length nt, or a n × nt Matrix with the same eltype as data if data is a Vector of length n.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators.map_observables","page":"API","title":"QuantumPropagators.map_observables","text":"Obtain \"observable\" data from state.\n\ndata = map_observables(observables, state)\n\ncalculates the data for a tuple of observables applied to state. For a single observable (tuple of length 1), simply return the result of map_observable.\n\nFor multiple observables, return the tuple resulting from applying map_observable for each observable. If the tuple is \"uniform\" (all elements are of the same type, e.g. if each observable calculates the expectation value of a Hermitian operator), it is converted to a Vector. This allows for compact storage in a storage array, see init_storage.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators.map_observable","page":"API","title":"QuantumPropagators.map_observable","text":"Apply a single observable to state.\n\ndata = map_observable(observable, state)\n\nBy default, observable is assumed to be callable, and the above is equivalent to data = observable(state).\n\nIf observable is a matrix and state is a vector evaluate the expectation value of the observable as dot(state, observable, state).\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators.write_to_storage!","page":"API","title":"QuantumPropagators.write_to_storage!","text":"Place data into storage for time slot i.\n\n    write_to_storage!(storage, i, state, observables)\n\nFor a storage array created by init_storage, store the data obtains from map_observables into the storage for time slot i. This delegates to the more general\n\n    write_to_storage!(storage, i, data)\n\nConceptually, this corresponds roughly to storage[i] = data, but storage may have its own idea on how to store data for a specific time slot. For example, with the default init_storage Vector data will be stored in a matrix, and write_to_storage! will in this case write data to the i'th column of the matrix.\n\nFor a given type of storage and data, it is the developer's responsibility that init_storage and write_to_storage! are compatible.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators.get_from_storage!","page":"API","title":"QuantumPropagators.get_from_storage!","text":"Obtain data from storage\n\nget_from_storage!(state, storage, i)\n\nextracts data from the storage for the i'th time slot. Invese of write_to_storage!\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators.initpropwrk","page":"API","title":"QuantumPropagators.initpropwrk","text":"Initialize a workspace for propagation.\n\nwrk = initpropwrk(state, tlist, method=:auto, generator...; kwargs...)\n\nThe resulting wrk can be passed to propagate or propstep!.\n\nArguments\n\nstate: An exemplary state for the propagation (e.g., the initial state)\ntlist: The time grid over which propagate will be called. Must include at least to points in order to determine the propagation time step to prepare. If the propagation will be over a tlist with a variable dt, the full tlist must be passed here.\ngenerator: An exemplary (non-time-dependent) dynamical generator. For full generality (if method=:cheby), the given generator should have a spectral range sufficiently large to encompass the entire propagation. If given multiple times, a spectral envelope enclosing all the generators will be determined automatically. In this case, you should pass the generators with the extremal values of all the controls.\nmethod: The propagation method to use. The default value of :auto attempts to choose the best method available, based on the properties of the given state, tlist, and generator. Alternative values are :cheby and :newton, and :expprop.\nspecrad_method: for method=:cheby, method to use for estimating the  spectral radius, see specrange. Defaults to :auto.\ntolerance: for method=:cheby, a tolerance factor for the estimated spectral radius. That is, Chebychev coefficients will be calculated for a spectral radius increased by the tolerance factor compared to the specral radius estimated for the generator.\n\nAll other kwargs are filtered and passed to the contructor for returned workspace, e.g. limit for method=:cheby or m_max for method=:newton. For method=:cheby, they additionally passed to specrange.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators.propstep!","page":"API","title":"QuantumPropagators.propstep!","text":"Perform a single propagation step in-place (unless for_autodiff=true).\n\npropstep!(state, generator, dt, wrk;for_autodiff, kwargs...)\n\nThe propagation method is determined by wrk, see initpropwrk. The truth value of for_autodiff can make the propagation step not in place (if possible), which is desirable for autodiff. The kwargs are forwarded to the underlying method\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators.propagate","page":"API","title":"QuantumPropagators.propagate","text":"Propagate with the dynamical generator of a control objective.\n\npropagate(obj, tlist; method=:auto, initial_state=obj.initial_state,\n          controls_map=IdDict(), kwargs...)\n\npropagates initial_state under the dynamics described by obj.generator.\n\nThe optional dict control_map may be given to replace the controls in obj.generator (as obtained by getcontrols) with custom functions or vectors, e.g. with the controls resulting from optimization.\n\nAll other kwargs are forwarded to the underlying propagate method for obj.initial_state.\n\n\n\n\n\nPropagate a state over an entire time grid.\n\nstate_out = propagate(\n    state, genfunc, tlist; method=:auto,\n    backwards=false; storage=nothing, observables=(<store state>, ),\n    hook=nothing, showprogress=false, control_parameters=nothing, \n    for_autodiff=false, kwargs...)\n\npropagates state over the time grid in tlist, using piecewise-constant dynamical generators (Hamiltonians or Liouvillians) determined by genfunc, and returns the resulting propagated state. The propagation is performed by calling propstep! for every interval in tlist.\n\nFor the i'th time interval, genfunc(tlist, i) must return the generator for that time interval. Generally, when approximating a time-continuous dynamical generator as piecewise-constant on the time grid, it should be evaluated at the midpoint of the interval. A possible exception is the first and last interval, which may be better evaluated at tlist[1] and tlist[end] to ensure exact boundary conditions like control fields that are exactly zero.\n\nIn addition to the two positional parameters indicating the time interval, genfunc will also receive the state (the input state for the propagation step), backwards, storage, observables, control_parameters, and init as keyword arguments.\n\nThe control_parameters are an optional array of floats with parameters for genfunc. This is required when propagate is used in the context of automatic differentiation (AD). E.g., the Zygote framework can automatically calculate gradients of a function control_parameters -> J_T, where J_T might be be a function of the overlap between a propagated state (returned by propagate) and a target state. Thus, the control_parameters must be explicit in propagate.  Outside of and AD context, control_parameters are not generally required: they can be implicit in genfunc. \n\nThe for_autodiff is an optional bool that controls if the operations are  in-place or not. Not in-place operations are required when propagate is used  in automatic differentiation (AD). For instance, the Zygote framework is not  capable of differentiating in-place operations.\n\nThe remaining keyword arguments may be used for unusual equations of motion beyond the standard Schrödinger or Liouville-von-Neumann equation, e.g. state would enter the genfunc for a Gross–Pitaevskii equation. For standard equations of motion that do not use the additional parameters, it is best to capture the keyword arguments to genfunc with a definition like\n\ngenfunc(tlist, i; kwargs...) = ...\n\nFor valid propagation methods, see initpropwrk.\n\nIn general, there is no requirement that tlist has a constant time step, although some propagation methods (most notably cheby!) only support a uniform time grid.\n\nIf storage is given as an Array, it will be filled with data determined by the observables. The default \"observable\" results in the propagated states at every point in time being stored. The storage array should be created with init_storage. See its documentation for details.\n\nThe storage parameter may also be given as true, and a new storage array will be created internally with init_storage and returned instead of the propagated state:\n\ndata = propagate(\n    state, genfunc, tlist; method=:auto\n    backwards=false; storage=true, observables=observables,\n    hook=nothing, showprogress=false, kwargs...)\n\nIf backwards is true, the input state is assumed to be at time tlist[end], and the propagation progresses backwards in time (with a negative time step dt). If storage is given, it will be filled back-to-front during the backwards propagation.\n\nIf hook is given as a callable, it will be called after each propagation step, as hook(state, generator, tlist, i, wrk, observables) where i is the index of the time interval on tlist covered by the propagation step (0 for the initial state, respectives lastindex(tlist) for the backward propagation).  The hook is called before calculating any observables. Example usage includes writing data to file, or modyfing state, e.g. removing amplitude from the lowest and highest level to mitigate \"truncation error\".\n\nIf showprogress is given as true, a progress bar will be shown for long-running propagationn. In order to customize the progress bar, showprogress may also be a function that receives length(tlist) and returns a ProgressMeter.Progress instance.\n\nThe propagate routine returns the propagated state at tlist[end], respectively tlist[1] if backwards=true, or a storage array with the stored states / observable data if storage=true.\n\n\n\n\n\n","category":"function"},{"location":"api/#Private-3","page":"API","title":"Private","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumPropagators]\nPrivate = true\nPublic = false","category":"page"},{"location":"api/#QuantumPropagators.arnoldi!-Union{Tuple{T}, Tuple{Matrix{ComplexF64}, Array{T, N} where N, Int64, T, Any}, Tuple{Matrix{ComplexF64}, Array{T, N} where N, Int64, T, Any, Float64}} where T","page":"API","title":"QuantumPropagators.arnoldi!","text":"m = arnoldi!(Hess, q, m, Ψ, H, dt=1.0; extended=true, norm_min=1e-15)\n\nCalculate the Hessenberg matrix and Arnoldi vectors of H dt, from Ψ.\n\nFor a given order m, the m×m Hessemberg matrix is calculated and stored in in the pre-allocated Hess. Further  an array of m normalized Arnoldi vectors is stored in in the pre-allocated q, plus one additional unnormalized Arnoldi vector.  The unnormalized m+1st vector could be used to easily extend a given m×m Hessenberg matrix to a (m+1)×(m+1) matrix.\n\nIf the extended Hessenberg matrix is requested (extended=true, default), the m+1st Arnoldi vector is also normalized, and it's norm will be stored in m+1, m entry of the (extended) Hessenberg matrix, which is an (m+1)×(m+1) matrix.\n\nReturn the size m of the calculated Hessenberg matrix. This will usually be the input m, except when the Krylov dimension of H starting from Ψ is less then m. E.g., if Ψ is an eigenstate of H, the returned m will be 1.\n\nSee http://en.wikipedia.org/wiki/Arnoldi_iteration for a description of the algorithm.\n\nArguments\n\nHess::Matrix{ComplexF64}: Pre-allocated storage for the Hessemberg matrix.  Can be uninitialized on input. The matrix must be at least of size m×m, or  (m+1)×(m+1) if extended=true. On output, the m×m sub-matrix of Hess  (with the returned output m) will contain the Hessenberg matrix, and all  other elements of Hess be be set to zero.\nq: Pre-allocated array of states similar to Ψ, as storage for the calculated Arnoldi vectors. These may be un-initialized on input. Must be at least of length m+1\nm: The requested dimensions of the output Hessenberg matrix.\nΨ: The starting vector for the Arnoldi procedure. This can be of any type,  as long as Φ = H * Ψ results in a vector similar to Ψ, there is an inner  products of Φ and Ψ (Ψ⋅Φ is defined), and norm(Ψ) is defined.\nH: The operator (up to dt) for which to calculate the Arnoldi procedure. Can be of any type, as long as H * Ψ is defined.\ndt: The implicit time step; the total operator for which to calculate the Arnoldi procedure is H * dt\nextended: If true (default), calculate the extended Hessenberg matrix, and normalized the final Arnoldi vector\nnorm_min: the minimum value of the norm of Ψ at which Ψ should be  considered the zero vector\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.diagonalize_hessenberg_matrix-Tuple{Any, Any}","page":"API","title":"QuantumPropagators.diagonalize_hessenberg_matrix","text":"diagonalize_hessenberg_matrix(Hess, m; accumulate=false)\n\nDiagonalize the m × m top left submatrix of the given Hessenberg matrix.\n\nIf accumulate is true, return the concatenated eigenvalues for Hess[1:1,1:1] to Hess[1:m,1:m], that is, all sumatrices of size 1 through m.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.extend_arnoldi!","page":"API","title":"QuantumPropagators.extend_arnoldi!","text":"Extend dimension of Hessenberg matrix by one.\n\nextend_arnoldi!(Hess, q, m, H, dt; norm_min=1e-15)\n\nextends the entries in Hess from size (m-1)×(m-1) to size m×m, and the list q of Arnoldi vectors from m to (m+1). It is assumed that the input Hess was created by a call to arnoldi! with extended=false or a previous call to extend_arnoldi!. Note that Hess itself is not resized, so it must be allocated to size m×m or greater on input.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators.extend_leja!-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Any, OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Any}","page":"API","title":"QuantumPropagators.extend_leja!","text":"extend_leja!(leja, n, newpoints, n_use)\n\nGiven an array of n (ordered) Leja points, extract n_use points from newpoints, and append them to the existing Leja points. The array leja should be sufficiently large to hold the new Leja points, which are appended after index n_old. It will be re-allocated if necessary and may have a size of up to 2*(n+n_use).\n\nArguments\n\nleja: Array of leja values. Must contain the \"old\" leja values to be kept  in leja(0:n-1). On output, n_use new leja points will be in  leja(n+:n+n_use-1), for the original value of n.  The leja array must  use zero-based indexing.\nn: On input, number of \"old\" leja points in leja. On output, total number of leja points (i.e. n=n+n_use)\nnewpoints: On input, candidate points for new leja points.  The n_use best values will be chosen and added to leja. On output, the values of new_points are undefined.\nn_use: Number of points that should be added to leja\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.extend_newton_coeffs!-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Int64, OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Any, Int64, Float64}","page":"API","title":"QuantumPropagators.extend_newton_coeffs!","text":"extend_newton_coeffs!(a, n_a, leja, func, n_leja, radius)\n\nExtend the array a of existing Newton coefficients for the expansion of the func from n_a coefficients to n_leja coefficients. Return a new value n_a=n_a+n_leja with the total number of Newton coefficients in the updated a.\n\nArguments\n\na: On input, a zero-based array of length n_a or greater, containing Newton coefficients. On output, array containing a total n_leja coefficients. The array a will be resized if necessary, and may have a length greater than n_leja on output\nn_a:  The number of Newton coefficients in a, on input. Elements of a  beyond the first n_a elements will be overwritten.\nleja: Array of normalized Leja points, containing at least n_leja elements.\nfunc: Function for which to calcluate Newton coeffiecients\nn_leja: The number of elements in leja to use for calculating new coefficients, and the total number of Newton coefficients on output\nradius: Normalization radius for divided differences\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.random_state-Tuple{AbstractMatrix{T} where T}","page":"API","title":"QuantumPropagators.random_state","text":"Random normalized quantum state.\n\n    Ψ = random_state(H)\n\nreturns a random normalized state compatible with the Hamiltonian H. This is intended to provide a starting vector for estimating the spectral radius of H via an Arnoldi method.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.ritzvals","page":"API","title":"QuantumPropagators.ritzvals","text":"Calculate a vector for Ritz values converged to a given precision.\n\nR = ritzvals(G, state, m_min, m_max=2*m_min; prec=1e-5, norm_min=1e-15)\n\ncalculates a complex vector R of at least m_min and at most m_max Ritz values.\n\n\n\n\n\n","category":"function"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"manual/#User-Manual","page":"User Manual","title":"User Manual","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"The User Manual describes the API of the QuantumControl package by outlining the general procedure for defining and solving quantum control problems. See the API for a detailed reference.","category":"page"},{"location":"manual/#Setting-up-control-problems","page":"User Manual","title":"Setting up control problems","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"ControlProblem\nObjective","category":"page"},{"location":"manual/#Controls-and-control-parameters","page":"User Manual","title":"Controls and control parameters","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"The controls that the QuantumControl package optimizes are implicit in the dynamical generator (Hamiltonians, Liouvillians) of the Objectives in the ControlProblem.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"The getcontrols method extracts the controls from the objectives. Each control is typically time-dependent, e.g. a function ϵ(t) or a vector of pulse values on a time grid. The default format for the dynamical generators is that of a \"nested\" tuple, e.g. (Ĥ₀, (Ĥ₁, ϵ₁), (Ĥ₂, ϵ₂)) where Ĥ₀, Ĥ₁ and Ĥ₂ are (sparse) matrices, and ϵ₁ and ϵ₂ are functions of time. The format corresponds to a time-dependent Hamiltonian H₀ + ϵ₁(t) H₁ + ϵ₂(t) H₂.  For custom types describing a Hamiltonian or Liouvillian, the getcontrols method must be defined to extract the controls.","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"For each control, discretize and discretize_on_midpoints discretizes the control to an existing time grid. For controls that are implemented through some custom type, these methods must be defined to enable piecewise-constant time propagation or an optimization that assumes piecewise-constant control (most notably, Krotov's method).","category":"page"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"More generally, get_control_parameters extracts abstract \"control parameters\" from a control. For controls that are simple functions, this is equivalent to discretizing them to a time grid. That is, the control parameters are the amplitude of the control field at each point in time, respectively each interval of the time grid. In general, though, the control parameters could be more abstract, e.g. the coefficients in a spectral decomposition, or parameters in an analytic pulse shape. In the context of optimal control, the parameters returned by get_control_parameters are those that the optimization should tune, assuming a suitable optimization method such as a gradient-free optimization or a generalized GRAPE (such as GROUP/GOAT).","category":"page"},{"location":"manual/#Time-propagation","page":"User Manual","title":"Time propagation","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"propagate","category":"page"},{"location":"manual/#Optimization","page":"User Manual","title":"Optimization","text":"","category":"section"},{"location":"manual/","page":"User Manual","title":"User Manual","text":"optimize_pulses","category":"page"},{"location":"glossary/#Glossary","page":"Glossary","title":"Glossary","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"In the context of the JuliaQuantumControl ecosystem, we apply the following nomenclature.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Generator","page":"Glossary","title":"Generator","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Dynamical generator (Hamiltonian / Liouvillian) for the time evolution of a state, i.e., the right-hand-side of the equation of motion (up to a factor of i) such that Ψ(t+dt) = e^-i H dt Ψ(t) in the infinitesimal limit. We use the symbols G, H, or L, depending on the context (general, Hamiltonian, Liouvillian).","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Examples for supported forms of dynamical generators are the following, from most general to simplest (and most common)","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"H = H₀ + sum_l H_l(ϵ_l(t))    —  general non-separable control terms (G1)\nH = H₀ + sum_l f(ϵ_l(t)) H_l    —  nonlinear separable control terms (G2)\nH = H₀ + sum_l ϵ_l(t) H_l             — linear control terms (G3)","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The above equations are written for Hamiltonians, but Liouvillians would follow the exact same form, see liouvillian with convention=:TDSE.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control","page":"Glossary","title":"Control","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"(aka \"control field\") A function ϵ_l(t) in the Generator, typically corresponding to some kind of physical field (laser amplitude, microwave pulse, etc.). Conceptually a function, but may be specified in terms of Control Parameters.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Term","page":"Glossary","title":"Control Term","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A term in the dynamical generator that depends on one or more controls, e.g. H_l(ϵ_l(t)) or f(ϵ_l(t)) H_l or ϵ_l(t) H_l in Eqs. (G1-G3) of the Generator. Conceptually, the control term is a time-dependent operator.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Drift","page":"Glossary","title":"Drift","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A term in the dynamics generator that does not depend on any controls. Conceptually, a static operator.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Function","page":"Glossary","title":"Control Function","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"In Eq. (G3), the f(ϵ(t)) expressing a possible non-linear physical dependency on the control field. An example is the quadratic coupling of a Stark shift operator to the laser field. Note that in the most common case of a linear control term, there is no strict distinction between \"control\"/\"control field\"/\"control function\".","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Generator","page":"Glossary","title":"Control Generator","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"(aka \"control Hamiltonian/Liouvillian\") —  The operator H_l in Eqs. (G2, G3). This is a static operator which forms the Control Term together with a Control Function. The control generator is not a well-defined concept in the most general case of non-separable controls terms, Eq. (G1)","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Parameters","page":"Glossary","title":"Control Parameters","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Non-time-dependent parameters that a control field depends on. One common parametrization of a control field is as a Pulse, where the control parameters are the amplitude of the field at discrete points of a time grid. Parametrization as a \"pulse\" is implicit in Krotov's method and standard GRAPE.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"More generally, the control parameters could also be spectral coefficients (CRAB) or simple parameters for an analytic pulse shape (e.g., position, width, and amplitude of a Gaussian shape). All optimal control methods find optimized control fields by varying the control parameters.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Pulse","page":"Glossary","title":"Pulse","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"(aka \"control pulse\") A control field discretized to a time grid, usually on the midpoints of the time grid, in a piecewise-constant approximation. Stored as a vector of floating point values. The parametrization of a control field as a \"pulse\" is implicit for Krotov's method and standard GRAPE. One might think of these methods to optimize the control fields directly, but a conceptually cleaner understanding is to think of the discretized \"pulse\" as a vector of control parameters for the time-continuous control field.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Amplitude-Parametrization","page":"Glossary","title":"Amplitude Parametrization","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The use of a function u(t) such that ϵ(t) = ϵ(u(t)) for the purpose of constraining the amplitude of the control field ϵ(t). See e.g. SquareParametrization, where ϵ(t) = u^2(t) to ensure that ϵ(t) is positive. Since Krotov's method inherently has no constraints on the optimized control fields, amplitude parameterization is a method of imposing constraints on the amplitude in this context. This is different from, albeit related to, a Control Function f(ϵ(t)) = ϵ^2(t) in that the amplitude parameterization does not reflect how the control field physically couples to the control Hamiltonian. Note that \"parameterization\" here has nothing to do with the \"parametrization\" in terms of Control Parameters: the amplitude parametrization is a parametrization with a function, whereas the control parameters are values.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Derivative","page":"Glossary","title":"Control Derivative","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The derivative of the dynamical Generator with respect to the control field ϵ(t). In the case of linear controls terms in Eq. (G3), the control derivative is the Control Generator coupling to ϵ(t). In general, however, for non-linear control terms, the control derivatives still depends on the control fields and is thus time dependent. We commonly use the symbol μ for the control derivative (reminiscent of the dipole operator)","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Parameter-Derivative","page":"Glossary","title":"Parameter Derivative","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The derivative of a control with respect to a single control parameter. The derivative of the dynamical Generator with respect to that control parameter is then the product of the Control Derivative and the parameter derivative.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Gradient","page":"Glossary","title":"Gradient","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The derivative of the optimization functional with respect to all Control Parameters, i.e. the vector of all parameter derivatives.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"note: Note\nThe above nomenclature does not consistently extend throughout the quantum control literature: the terms \"control\"/\"control term\"/\"control Hamiltonian\", and \"control\"/\"control field\"/\"control function\"/\"control pulse\"/\"pulse\" are generally somewhat ambiguous. In particular, the distinction between \"control field\" and \"pulse\" (as a parametrization of the control field in terms of amplitudes on a time grid) here is somewhat artifcial (although it is also used in the Krotov Python package). However, the terminology defined in this glossary is consistently applied within the JuliaQuantumControl organization, both in the documentation and in the names of fields and methods.","category":"page"},{"location":"#QuantumControl.jl","page":"Home","title":"QuantumControl.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumControl.jl is Julia framework for quantum optimal control.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"glossary.md\",\n    \"manual.md\",\n    \"howto.md\",\n    \"api.md\",\n]\nDepth = 2","category":"page"}]
}

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Control Methods · QuantumControl.jl</title><meta name="title" content="Control Methods · QuantumControl.jl"/><meta property="og:title" content="Control Methods · QuantumControl.jl"/><meta property="twitter:title" content="Control Methods · QuantumControl.jl"/><meta name="description" content="Documentation for QuantumControl.jl."/><meta property="og:description" content="Documentation for QuantumControl.jl."/><meta property="twitter:description" content="Documentation for QuantumControl.jl."/><meta property="og:url" content="https://juliaquantumcontrol.github.io/QuantumControl.jl/methods/"/><meta property="twitter:url" content="https://juliaquantumcontrol.github.io/QuantumControl.jl/methods/"/><link rel="canonical" href="https://juliaquantumcontrol.github.io/QuantumControl.jl/methods/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/assets/topbar/topbar.css" rel="stylesheet" type="text/css"/><script src="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/assets/topbar/topbar.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumControl.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li><a class="tocitem" href="../manual/">User Manual</a></li><li class="is-active"><a class="tocitem" href>Control Methods</a><ul class="internal"><li><a class="tocitem" href="#Krotov&#39;s-Method"><span>Krotov&#39;s Method</span></a></li><li><a class="tocitem" href="#GRAPE"><span>GRAPE</span></a></li></ul></li><li><a class="tocitem" href="../howto/">Howto</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../api/quantum_control/">QuantumControl</a></li><li><a class="tocitem" href="../api/quantum_control_reference/">Local Submodules</a></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Subpackages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/quantum_propagators/">QuantumPropagators</a></li><li><a class="tocitem" href="../api/quantum_control_base/">QuantumControlBase</a></li></ul></li><li><a class="tocitem" href="../api_externals/">Externals</a></li><li><a class="tocitem" href="../api/quantum_control_index/">Index</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Control Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Control Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/QuantumControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/master/docs/src/methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Control-Methods"><a class="docs-heading-anchor" href="#Control-Methods">Control Methods</a><a id="Control-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Control-Methods" title="Permalink"></a></h1><p>All optimizations in the <code>QuantumControl</code> package are done by calling <code>QuantumControl.optimize</code>, or preferably the high-level wrapper <a href="../api/quantum_control_reference/#QuantumControl.Workflows.@optimize_or_load"><code>@optimize_or_load</code></a>. The actual control methods are implemented in separate packages. The module implementing a particular method should be passed to <code>optimize</code> as the <code>method</code> keyword argument.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.optimize-Tuple{ControlProblem}-methods" href="#QuantumControlBase.optimize-Tuple{ControlProblem}-methods"><code>QuantumControlBase.optimize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Optimize a quantum control problem.</p><pre><code class="language-julia hljs">result = optimize(problem; method, check=true, kwargs...)</code></pre><p>optimizes towards a solution of given <a href="../api/quantum_control_base/#QuantumControlBase.ControlProblem"><code>problem</code></a> with the given <code>method</code>, which should be a <code>Module</code> implementing the method, e.g.,</p><pre><code class="language-julia hljs">using Krotov
result = optimize(problem; method=Krotov)</code></pre><p>Note that <code>method</code> is a mandatory keyword argument.</p><p>If <code>check</code> is true (default), the <code>initial_state</code> and <code>generator</code> of each trajectory is checked with <a href="../api/quantum_propagators/#QuantumPropagators.Interfaces.check_state"><code>check_state</code></a> and <a href="../api/quantum_control_base/#QuantumControlBase.check_generator"><code>check_generator</code></a>. Any other keyword argument temporarily overrides the corresponding keyword argument in <a href="../api/quantum_control_base/#QuantumControlBase.ControlProblem"><code>problem</code></a>. These arguments are available to the optimizer, see each optimization package&#39;s documentation for details.</p><p>To obtain the documentation for which options a particular method uses, run, e.g.,</p><pre><code class="language-julia hljs">? optimize(problem, ::Val{:Krotov})</code></pre><p>where <code>:Krotov</code> is the name of the module implementing the method. The above is also the method signature that a <code>Module</code> wishing to implement a control method must define.</p><p>The returned <code>result</code> object is specific to the optimization method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/293a1479221cb3a43fc8bbdfcc0eab3531bc8537/src/optimize.jl#L6-L41">source</a></section></article><p>The following methods of optimal control are implemented by packages in the <a href="https://github.com/JuliaQuantumControl">JuliaQuantumControl organization</a>:</p><ul><li><a href="#Krotov&#39;s-Method">Krotov&#39;s Method</a></li><li><a href="#GRAPE">GRAPE</a></li></ul><h2 id="Krotov&#39;s-Method"><a class="docs-heading-anchor" href="#Krotov&#39;s-Method">Krotov&#39;s Method</a><a id="Krotov&#39;s-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Krotov&#39;s-Method" title="Permalink"></a></h2><p>See the <a href="https://juliaquantumcontrol.github.io/Krotov.jl/dev/">documentation</a>  of the <a href="https://github.com/JuliaQuantumControl/Krotov.jl"><code>Krotov</code> package</a> for more details.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.optimize-Tuple{ControlProblem, Val{:Krotov}}-methods" href="#QuantumControlBase.optimize-Tuple{ControlProblem, Val{:Krotov}}-methods"><code>QuantumControlBase.optimize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">using Krotov
result = optimize(problem; method=Krotov, kwargs...)</code></pre><p>optimizes the given control <a href="../api/quantum_control_base/#QuantumControlBase.ControlProblem"><code>problem</code></a> using Krotov&#39;s method, returning a <a href="../api_externals/#Krotov.KrotovResult"><code>KrotovResult</code></a>.</p><p>Keyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of <code>problem</code>; any of these can be overriden with explicit keyword arguments to <code>optimize</code>.</p><p><strong>Required problem keyword arguments</strong></p><ul><li><code>J_T</code>: A function <code>J_T(ϕ, trajectories)</code> that evaluates the final time functional from a list <code>ϕ</code> of forward-propagated states and <code>problem.trajectories</code>.</li></ul><p><strong>Recommended problem keyword arguments</strong></p><ul><li><code>lambda_a=1.0</code>: The inverse Krotov step width λ_a for every pulse.</li><li><code>update_shape=(t-&gt;1.0)</code>: A function <code>S(t)</code> for the &quot;update shape&quot; that scales the update for every pulse</li></ul><p>If different controls require different <code>lambda_a</code> or <code>update_shape</code>, a dict <code>pulse_options</code> must be given instead of a global <code>lambda_a</code> and <code>update_shape</code>, see below.</p><p><strong>Optional problem keyword arguments</strong></p><p>The following keyword arguments are supported (with default values):</p><ul><li><p><code>pulse_options</code>: A dictionary that maps every control (as obtained by <a href="../api/quantum_propagators/#QuantumPropagators.Controls.get_controls"><code>get_controls</code></a> from the <code>problem.trajectories</code>) to the following dict:</p><ul><li><code>:lambda_a</code>:  The value for inverse Krotov step width λₐ</li><li><code>:update_shape</code>: A function <code>S(t)</code> for the &quot;update shape&quot; that scales the Krotov pulse update.</li></ul><p>This overrides the global <code>lambda_a</code> and <code>update_shape</code> arguments.</p></li><li><p><code>chi</code>: A function <code>chi!(χ, ϕ, trajectories)</code> what receives a list <code>ϕ</code> of the forward propagated states and must set <span>$|χₖ⟩ = -∂J_T/∂⟨ϕₖ|$</span>. If not given, it will be automatically determined from <code>J_T</code> via <a href="../api/quantum_control_base/#QuantumControlBase.make_chi"><code>make_chi</code></a> with the default parameters.</p></li><li><p><code>sigma=nothing</code>: Function that calculate the second-order contribution. If not given, the first-order Krotov method is used.</p></li><li><p><code>iter_start=0</code>: the initial iteration number</p></li><li><p><code>iter_stop=5000</code>: the maximum iteration number</p></li><li><p><code>prop_method</code>: The propagation method to use for each trajectory, see below.</p></li><li><p><code>update_hook</code>: A function that receives the Krotov workspace, the iteration number, the list of updated pulses and the list of guess pulses as positional arguments. The function may mutate any of its arguments. This may be used e.g. to apply a spectral filter to the updated pulses or to perform similar manipulations.</p></li><li><p><code>info_hook</code>: A function (or tuple of functions) that receives the same arguments as <code>update_hook</code>, in order to write information about the current iteration to the screen or to a file. The default <code>info_hook</code> prints a table with convergence information to the screen. Runs after <code>update_hook</code>. The <code>info_hook</code> function may return a tuple, which is stored in the list of <code>records</code> inside the <a href="../api_externals/#Krotov.KrotovResult"><code>KrotovResult</code></a> object.</p></li><li><p><code>check_convergence</code>: a function to check whether convergence has been reached. Receives a <a href="../api_externals/#Krotov.KrotovResult"><code>KrotovResult</code></a> object <code>result</code>, and should set <code>result.converged</code> to <code>true</code> and <code>result.message</code> to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with <code>∘</code>. The convergence check is performed after any calls to <code>update_hook</code> and <code>info_hook</code>.</p></li><li><p><code>verbose=false</code>: If <code>true</code>, print information during initialization</p></li><li><p><code>rethrow_exceptions</code>: By default, any exception ends the optimization, but still returns a <a href="../api_externals/#Krotov.KrotovResult"><code>KrotovResult</code></a> that captures the message associated with the exception. This is to avoid losing results from a long-running optimization when an exception occurs in a later iteration. If <code>rethrow_exceptions=true</code>, instead of capturing the exception, it will be thrown normally.</p></li></ul><p><strong>Trajectory propagation</strong></p><p>Krotov&#39;s method involves the forward and backward propagation for every <a href="../api/quantum_control_base/#QuantumControlBase.Trajectory"><code>Trajectory</code></a> in the <code>problem</code>. The keyword arguments for each propagation (see <a href="../api/quantum_propagators/#QuantumPropagators.propagate"><code>propagate</code></a>) are determined from any properties of each <a href="../api/quantum_control_base/#QuantumControlBase.Trajectory"><code>Trajectory</code></a> that have a <code>prop_</code> prefix, cf. <a href="../api/quantum_control_base/#QuantumControlBase.init_prop_trajectory"><code>init_prop_trajectory</code></a>.</p><p>In situations where different parameters are required for the forward and backward propagation, instead of the <code>prop_</code> prefix, the <code>fw_prop_</code> and <code>bw_prop_</code> prefix can be used, respectively. These override any setting with the <code>prop_</code> prefix. This applies both to the properties of each <a href="../api/quantum_control_base/#QuantumControlBase.Trajectory"><code>Trajectory</code></a> and the problem keyword arguments.</p><p>Note that the propagation method for each propagation must be specified. In most cases, it is sufficient (and recommended) to pass a global <code>prop_method</code> problem keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/Krotov.jl/blob/2f7c2989177c67b99fe21740b1b5cc6f83788f30/src/optimize.jl#L12-L107">source</a></section></article><h2 id="GRAPE"><a class="docs-heading-anchor" href="#GRAPE">GRAPE</a><a id="GRAPE-1"></a><a class="docs-heading-anchor-permalink" href="#GRAPE" title="Permalink"></a></h2><p>The Gradient Ascent Pulse Engineering (GRAPE) method is implemented in the <a href="https://github.com/JuliaQuantumControl/GRAPE.jl"><code>GRAPE</code> package</a>. See the <a href="https://juliaquantumcontrol.github.io/GRAPE.jl/dev/"><code>GRAPE</code> documentation</a> for details.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControlBase.optimize-Tuple{ControlProblem, Val{:GRAPE}}-methods" href="#QuantumControlBase.optimize-Tuple{ControlProblem, Val{:GRAPE}}-methods"><code>QuantumControlBase.optimize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">using GRAPE
result = optimize(problem; method=GRAPE, kwargs...)</code></pre><p>optimizes the given control <a href="../api/quantum_control_base/#QuantumControlBase.ControlProblem"><code>problem</code></a> via the GRAPE method, by minimizing the functional</p><p class="math-container">\[J(\{ϵ_{nl}\}) = J_T(\{|ϕ_k(T)⟩\}) + λ_a J_a(\{ϵ_{nl}\})\]</p><p>where the final time functional <span>$J_T$</span> depends explicitly on the forward-propagated states and the running cost <span>$J_a$</span> depends explicitly on pulse values <span>$ϵ_{nl}$</span> of the l&#39;th control discretized on the n&#39;th interval of the time grid.</p><p>Returns a <a href="../api_externals/#GRAPE.GrapeResult"><code>GrapeResult</code></a>.</p><p>Keyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of <code>problem</code>; any of these can be overridden with explicit keyword arguments to <code>optimize</code>.</p><p><strong>Required problem keyword arguments</strong></p><ul><li><code>J_T</code>: A function <code>J_T(ϕ, trajectories; τ=τ)</code> that evaluates the final time functional from a vector <code>ϕ</code> of forward-propagated states and <code>problem.trajectories</code>. For all <code>trajectories</code> that define a <code>target_state</code>, the element <code>τₖ</code> of the vector <code>τ</code> will contain the overlap of the state <code>ϕₖ</code> with the <code>target_state</code> of the <code>k</code>&#39;th trajectory, or <code>NaN</code> otherwise.</li></ul><p><strong>Optional problem keyword arguments</strong></p><ul><li><p><code>chi</code>: A function <code>chi!(χ, ϕ, trajectories)</code> what receives a list <code>ϕ</code> of the forward propagated states and must set <span>$|χₖ⟩ = -∂J_T/∂⟨ϕₖ|$</span>. If not given, it will be automatically determined from <code>J_T</code> via <a href="../api/quantum_control_base/#QuantumControlBase.make_chi"><code>make_chi</code></a> with the default parameters.</p></li><li><p><code>J_a</code>: A function <code>J_a(pulsevals, tlist)</code> that evaluates running costs over the pulse values, where <code>pulsevals</code> are the vectorized values <span>$ϵ_{nl}$</span>, where <code>n</code> are in indices of the time intervals and <code>l</code> are the indices over the controls, i.e., <code>[ϵ₁₁, ϵ₂₁, …, ϵ₁₂, ϵ₂₂, …]</code> (the pulse values for each control are contiguous). If not given, the optimization will not include a running cost.</p></li><li><p><code>gradient_method=:gradgen</code>: One of <code>:gradgen</code> (default) or <code>:taylor</code>. With <code>gradient_method=:gradgen</code>, the gradient is calculated using <a href="https://github.com/JuliaQuantumControl/QuantumGradientGenerators.jl">QuantumGradientGenerators</a>. With <code>gradient_method=:taylor</code>, it is evaluated via a Taylor series, see Eq. (20) in Kuprov and Rogers,  J. Chem. Phys. 131, 234108 (2009) [<a href="../references/#KuprovJCP09">17</a>].</p></li><li><p><code>taylor_grad_max_order=100</code>: If given with <code>gradient_method=:taylor</code>, the maximum number of terms in the Taylor series. If <code>taylor_grad_check_convergence=true</code> (default), if the Taylor series does not convergence within the given number of terms, throw an an error. With <code>taylor_grad_check_convergence=true</code>, this is the exact order of the Taylor series.</p></li><li><p><code>taylor_grad_tolerance=1e-16</code>: If given with <code>gradient_method=:taylor</code> and <code>taylor_grad_check_convergence=true</code>, stop the Taylor series when the norm of the term falls below the given tolerance. Ignored if <code>taylor_grad_check_convergence=false</code>.</p></li><li><p><code>taylor_grad_check_convergence=true</code>: If given as <code>true</code> (default), check the convergence after each term in the Taylor series an stop as soon as the norm of the term drops below the given number. If <code>false</code>, stop after exactly <code>taylor_grad_max_order</code> terms.</p></li><li><p><code>lambda_a=1</code>: A weight for the running cost <code>J_a</code>.</p></li><li><p><code>grad_J_a</code>: A function to calculate the gradient of <code>J_a</code>. If not given, it will be automatically determined.</p></li><li><p><code>upper_bound</code>: An upper bound for the value of any optimized control. Time-dependent upper bounds can be specified via <code>pulse_options</code>.</p></li><li><p><code>lower_bound</code>: A lower bound for the value of any optimized control. Time-dependent lower bounds can be specified via <code>pulse_options</code>.</p></li><li><p><code>pulse_options</code>: A dictionary that maps every control (as obtained by <a href="../api/quantum_propagators/#QuantumPropagators.Controls.get_controls"><code>get_controls</code></a> from the <code>problem.trajectories</code>) to a dict with the following possible keys:</p><ul><li><code>:upper_bounds</code>: A vector of upper bound values, one for each intervals of the time grid. Values of <code>Inf</code> indicate an unconstrained upper bound for that time interval, respectively the global <code>upper_bound</code>, if given.</li><li><code>:lower_bounds</code>: A vector of lower bound values. Values of <code>-Inf</code> indicate an unconstrained lower bound for that time interval,</li></ul></li><li><p><code>update_hook</code>: Not implemented</p></li><li><p><code>info_hook</code>: A function (or tuple of functions) that receives the same arguments as <code>update_hook</code>, in order to write information about the current iteration to the screen or to a file. The default <code>info_hook</code> prints a table with convergence information to the screen. Runs after <code>update_hook</code>. The <code>info_hook</code> function may return a tuple, which is stored in the list of <code>records</code> inside the <a href="../api_externals/#GRAPE.GrapeResult"><code>GrapeResult</code></a> object.</p></li><li><p><code>check_convergence</code>: A function to check whether convergence has been reached. Receives a <a href="../api_externals/#GRAPE.GrapeResult"><code>GrapeResult</code></a> object <code>result</code>, and should set <code>result.converged</code> to <code>true</code> and <code>result.message</code> to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with <code>∘</code>. The convergence check is performed after any calls to <code>update_hook</code> and <code>info_hook</code>.</p></li><li><p><code>x_tol</code>: Parameter for Optim.jl</p></li><li><p><code>f_tol</code>: Parameter for Optim.jl</p></li><li><p><code>g_tol</code>: Parameter for Optim.jl</p></li><li><p><code>show_trace</code>: Parameter for Optim.jl</p></li><li><p><code>extended_trace</code>:  Parameter for Optim.jl</p></li><li><p><code>show_every</code>: Parameter for Optim.jl</p></li><li><p><code>allow_f_increases</code>: Parameter for Optim.jl</p></li><li><p><code>optimizer</code>: An optional Optim.jl optimizer (<code>Optim.AbstractOptimizer</code> instance). If not given, an <a href="https://github.com/Gnimuc/LBFGSB.jl">L-BFGS-B</a> optimizer will be used.</p></li><li><p><code>prop_method</code>: The propagation method to use for each trajectory, see below.</p></li><li><p><code>verbose=false</code>: If <code>true</code>, print information during initialization</p></li><li><p><code>rethrow_exceptions</code>: By default, any exception ends the optimization, but still returns a <a href="../api_externals/#GRAPE.GrapeResult"><code>GrapeResult</code></a> that captures the message associated with the exception. This is to avoid losing results from a long-running optimization when an exception occurs in a later iteration. If <code>rethrow_exceptions=true</code>, instead of capturing the exception, it will be thrown normally.</p></li></ul><p><strong>Trajectory propagation</strong></p><p>GRAPE may involve three types of propagation:</p><ul><li>A forward propagation for every <a href="../api/quantum_control_base/#QuantumControlBase.Trajectory"><code>Trajectory</code></a> in the <code>problem</code></li><li>A backward propagation for every trajectory</li><li>A backward propagation of a <a href="https://juliaquantumcontrol.github.io/QuantumGradientGenerators.jl/dev/api/#QuantumGradientGenerators.GradGenerator">gradient generator</a> for every trajectory.</li></ul><p>The keyword arguments for each propagation (see <a href="../api/quantum_propagators/#QuantumPropagators.propagate"><code>propagate</code></a>) are determined from any properties of each <a href="../api/quantum_control_base/#QuantumControlBase.Trajectory"><code>Trajectory</code></a> that have a <code>prop_</code> prefix, cf. <a href="../api/quantum_control_base/#QuantumControlBase.init_prop_trajectory"><code>init_prop_trajectory</code></a>.</p><p>In situations where different parameters are required for the forward and backward propagation, instead of the <code>prop_</code> prefix, the <code>fw_prop_</code> and <code>bw_prop_</code> prefix can be used, respectively. These override any setting with the <code>prop_</code> prefix. Similarly, properties for the backward propagation of the gradient generators can be set with properties that have a <code>grad_prop_</code> prefix. These prefixes apply both to the properties of each <a href="../api/quantum_control_base/#QuantumControlBase.Trajectory"><code>Trajectory</code></a> and the problem keyword arguments.</p><p>Note that the propagation method for each propagation must be specified. In most cases, it is sufficient (and recommended) to pass a global <code>prop_method</code> problem keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/GRAPE.jl/blob/250dac68cd2d38627206875ea025e5c444c79bca/src/optimize.jl#L13-L154">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual/">« User Manual</a><a class="docs-footer-nextpage" href="../howto/">Howto »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/QuantumControl.jl">QuantumControl.jl</a> v0.9.1+dev docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Saturday 6 July 2024 12:23">Saturday 6 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

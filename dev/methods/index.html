<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Control Methods · QuantumControl.jl</title><meta name="title" content="Control Methods · QuantumControl.jl"/><meta property="og:title" content="Control Methods · QuantumControl.jl"/><meta property="twitter:title" content="Control Methods · QuantumControl.jl"/><meta name="description" content="Documentation for QuantumControl.jl."/><meta property="og:description" content="Documentation for QuantumControl.jl."/><meta property="twitter:description" content="Documentation for QuantumControl.jl."/><meta property="og:url" content="https://juliaquantumcontrol.github.io/QuantumControl.jl/methods/"/><meta property="twitter:url" content="https://juliaquantumcontrol.github.io/QuantumControl.jl/methods/"/><link rel="canonical" href="https://juliaquantumcontrol.github.io/QuantumControl.jl/methods/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/assets/topbar/topbar.css" rel="stylesheet" type="text/css"/><script src="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/assets/topbar/topbar.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumControl.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li class="is-active"><a class="tocitem" href>Control Methods</a><ul class="internal"><li><a class="tocitem" href="#Krotov&#39;s-Method"><span>Krotov&#39;s Method</span></a></li><li><a class="tocitem" href="#GRAPE"><span>GRAPE</span></a></li></ul></li><li><a class="tocitem" href="../howto/">Howto</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../api/quantum_control/">QuantumControl</a></li><li><a class="tocitem" href="../api/reference/">Reference</a></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Subpackages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/quantum_propagators/">QuantumPropagators</a></li></ul></li><li><a class="tocitem" href="../api_externals/">Externals</a></li><li><a class="tocitem" href="../api/quantum_control_index/">Index</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Control Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Control Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/QuantumControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/master/docs/src/methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Control-Methods"><a class="docs-heading-anchor" href="#Control-Methods">Control Methods</a><a id="Control-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Control-Methods" title="Permalink"></a></h1><p>All optimizations in the <code>QuantumControl</code> package are done by calling <code>QuantumControl.optimize</code>, or preferably the high-level wrapper <a href="../api/reference/#QuantumControl.Workflows.@optimize_or_load"><code>@optimize_or_load</code></a>. The actual control methods are implemented in separate packages. The module implementing a particular method should be passed to <code>optimize</code> as the <code>method</code> keyword argument.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.optimize-Tuple{ControlProblem}-methods" href="#QuantumControl.optimize-Tuple{ControlProblem}-methods"><code>QuantumControl.optimize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Optimize a quantum control problem.</p><pre><code class="language-julia hljs">result = optimize(
    problem;
    method,  # mandatory keyword argument
    check=true,
    callback=nothing,
    print_iters=true,
    kwargs...
)</code></pre><p>optimizes towards a solution of given <a href="../api/reference/#QuantumControl.ControlProblem"><code>problem</code></a> with the given <code>method</code>, which should be a <code>Module</code> implementing the method, e.g.,</p><pre><code class="language-julia hljs">using Krotov
result = optimize(problem; method=Krotov)</code></pre><p>If <code>check</code> is true (default), the <code>initial_state</code> and <code>generator</code> of each trajectory is checked with <a href="../api/quantum_propagators/#QuantumPropagators.Interfaces.check_state"><code>check_state</code></a> and <a href="../api/reference/#QuantumControl.Interfaces.check_generator"><code>check_generator</code></a>. Any other keyword argument temporarily overrides the corresponding keyword argument in <a href="../api/reference/#QuantumControl.ControlProblem"><code>problem</code></a>. These arguments are available to the optimizer, see each optimization package&#39;s documentation for details.</p><p>The <code>callback</code> can be given as a function to be called after each iteration in order to analyze the progress of the optimization or to modify the state of the optimizer or the current controls. The signature of <code>callback</code> is method-specific, but callbacks should receive a workspace objects as the first parameter as the first argument, the iteration number as the second parameter, and then additional method-specific parameters.</p><p>The <code>callback</code> function may return a tuple of values, and an optimization method should store these values fore each iteration in a <code>records</code> field in their <code>Result</code> object. The <code>callback</code> should be called once with an iteration number of <code>0</code> before the first iteration. The <code>callback</code> can also be given as a tuple of vector of functions, which are automatically combined via <a href="https://juliaquantumcontrol.github.io/Krotov.jl/dev/externals/#QuantumControl.chain_callbacks-Tuple"><code>chain_callbacks</code></a>.</p><p>If <code>print_iters</code> is <code>true</code> (default), an automatic <code>callback</code> is created via the method-specific <a href="https://juliaquantumcontrol.github.io/Krotov.jl/dev/externals/#QuantumControl.make_print_iters-Tuple%7BModule%7D"><code>make_print_iters</code></a> to print the progress of the optimization after each iteration. This automatic callback runs after any manually given <code>callback</code>.</p><p>All remaining keyword argument are method-specific. To obtain the documentation for which options a particular method uses, run, e.g.,</p><pre><code class="language-julia hljs">? optimize(problem, ::Val{:Krotov})</code></pre><p>where <code>:Krotov</code> is the name of the module implementing the method. The above is also the method signature that a <code>Module</code> wishing to implement a control method must define.</p><p>The returned <code>result</code> object is specific to the optimization method, but should be a subtype of <a href="../api/reference/#QuantumControl.AbstractOptimizationResult"><code>QuantumControl.AbstractOptimizationResult</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControl.jl/blob/c9718f323e42b64d7114da82013e96103952ccab/src/optimize.jl#L11-L72">source</a></section></article><p>The following methods of optimal control are implemented by packages in the <a href="https://github.com/JuliaQuantumControl">JuliaQuantumControl organization</a>:</p><ul><li><a href="#Krotov&#39;s-Method">Krotov&#39;s Method</a></li><li><a href="#GRAPE">GRAPE</a></li></ul><h2 id="Krotov&#39;s-Method"><a class="docs-heading-anchor" href="#Krotov&#39;s-Method">Krotov&#39;s Method</a><a id="Krotov&#39;s-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Krotov&#39;s-Method" title="Permalink"></a></h2><p>See the <a href="https://juliaquantumcontrol.github.io/Krotov.jl/dev/">documentation</a>  of the <a href="https://github.com/JuliaQuantumControl/Krotov.jl"><code>Krotov</code> package</a> for more details.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.optimize-Tuple{ControlProblem, Val{:Krotov}}-methods" href="#QuantumControl.optimize-Tuple{ControlProblem, Val{:Krotov}}-methods"><code>QuantumControl.optimize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">using Krotov
result = optimize(problem; method=Krotov, kwargs...)</code></pre><p>optimizes the given control <a href="../api/reference/#QuantumControl.ControlProblem"><code>problem</code></a> using Krotov&#39;s method, by minimizing the functional</p><p class="math-container">\[J(\{ϵ_l(t)\}) =
    J_T(\{|Ψ_k(T)⟩\})
    + ∑_l \int_{0}^{T} \frac{λ_{a,l}}{S_l(t)} [ϵ_l(t) - ϵ_l^{(0)}(t)]^2 \, dt\,,\]</p><p>cf. the <a href="../#Functional">general form of a quantum control functional</a>. The &quot;reference field&quot; <span>$ϵ_l^{(0)}(t)$</span> is the guess control for that particular iteration. The above functional implies a first-order update equation</p><p class="math-container">\[Δϵ_l(t) = \frac{S_l(t)}{λ_{a,l}} \Im ∑_k \left[
\Big\langle
    \chi_k^{(0)}(t)
\Big\vert
    \frac{\partial \hat{H}_k}{\partial ϵ_l(t)}
\Big\vert
    \Psi_k(t)
\Big\rangle
\right]\,,\]</p><p>where <span>$|\chi^{(0)}_k(t)⟩$</span> is the state backward-propagated under <span>$Ĥ_k^{\dagger}(\{ϵ_l^{(0)}(t)\})$</span> with the boundary condition <span>$|\chi_k(T)⟩ = \partial J_T / \partial ⟨Ψ_k^{(0)}(T)|$</span> and <span>$Ĥ_k$</span> is the <code>generator</code> of the <span>$k$</span>&#39;th trajectory.</p><p>Note that the particular control-dependent running cost in the above functional is required to obtain the given Krotov update equation. Other running costs, or state-dependent running costs are not supported in this implementation of Krotov&#39;s method (even though <em>some</em> running costs are mathematically compatible with Krotov&#39;s method).</p><p>Returns a <a href="../api_externals/#Krotov.KrotovResult"><code>KrotovResult</code></a>.</p><p>Keyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of <code>problem</code>; any of these can be overridden with explicit keyword arguments to <code>optimize</code>.</p><p><strong>Required problem keyword arguments</strong></p><ul><li><code>J_T</code>: A function <code>J_T(Ψ, trajectories)</code> that evaluates the final time functional from a list <code>Ψ</code> of forward-propagated states and <code>problem.trajectories</code>. The function <code>J_T</code> may also take a keyword argument <code>tau</code>. If it does, a vector containing the complex overlaps of the target states (<code>target_state</code> property of each trajectory in <code>problem.trajectories</code>) with the propagated states will be passed to <code>J_T</code>.</li></ul><p><strong>Recommended problem keyword arguments</strong></p><ul><li><code>lambda_a=1.0</code>: The inverse Krotov step width λₐ for every pulse.</li><li><code>update_shape=(t-&gt;1.0)</code>: A function <code>S(t)</code> for the &quot;update shape&quot; that scales the update for every pulse.</li></ul><p>If different controls require different <code>lambda_a</code> or <code>update_shape</code>, a dict <code>pulse_options</code> must be given instead of a global <code>lambda_a</code> and <code>update_shape</code>; see below.</p><p><strong>Optional problem keyword arguments</strong></p><p>The following keyword arguments are supported (with default values):</p><ul><li><p><code>pulse_options</code>: A dictionary that maps every control (as obtained by <a href="../api/quantum_propagators/#QuantumPropagators.Controls.get_controls"><code>get_controls</code></a> from the <code>problem.trajectories</code>) to the following dict:</p><ul><li><code>:lambda_a</code>:  The value for inverse Krotov step width λₐ.</li><li><code>:update_shape</code>: A function <code>S(t)</code> for the &quot;update shape&quot; that scales the Krotov pulse update.</li></ul><p>This overrides the global <code>lambda_a</code> and <code>update_shape</code> arguments.</p></li><li><p><code>chi</code>: A function <code>chi(Ψ, trajectories)</code> that receives a list <code>Ψ</code> of the forward propagated states and returns a vector of states <span>$|χₖ⟩ = -∂J_T/∂⟨Ψₖ|$</span>. If not given, it will be automatically determined from <code>J_T</code> via <a href="../api/reference/#QuantumControl.Functionals.make_chi"><code>make_chi</code></a> with the default parameters. Similarly to <code>J_T</code>, if <code>chi</code> accepts a keyword argument <code>tau</code>, it will be passed a vector of complex overlaps.</p></li><li><p><code>sigma=nothing</code>: A function that calculates the second-order contribution. If not given, the first-order Krotov method is used.</p></li><li><p><code>iter_start=0</code>: The initial iteration number.</p></li><li><p><code>iter_stop=5000</code>: The maximum iteration number.</p></li><li><p><code>prop_method</code>: The propagation method to use for each trajectory; see below.</p></li><li><p><code>print_iters=true</code>: Whether to print information after each iteration.</p></li><li><p><code>store_iter_info=Set()</code>: Which fields from <code>print_iters</code> to store in <code>result.records</code>. A subset of <code>Set([&quot;iter.&quot;, &quot;J_T&quot;, &quot;∫gₐ(t)dt&quot;, &quot;J&quot;, &quot;ΔJ_T&quot;, &quot;ΔJ&quot;, &quot;secs&quot;])</code>.</p></li><li><p><code>callback</code>: A function (or tuple of functions) that receives the <a href="../api_externals/#Krotov.KrotovWrk">Krotov workspace</a>, the iteration number, the list of updated pulses, and the list of guess pulses as positional arguments. The function may return a tuple of values which are stored in the <a href="../api_externals/#Krotov.KrotovResult"><code>KrotovResult</code></a> object <code>result.records</code>. The function can also mutate any of its arguments, in particular the updated pulses. This may be used, e.g., to apply a spectral filter to the updated pulses or to perform similar manipulations. Note that <code>print_iters=true</code> (default) adds an automatic callback to print information after each iteration. With <code>store_iter_info</code>, that callback automatically stores a subset of the printed information.</p></li><li><p><code>check_convergence</code>: A function to check whether convergence has been reached. Receives a <a href="../api_externals/#Krotov.KrotovResult"><code>KrotovResult</code></a> object <code>result</code>, and should set <code>result.converged</code> to <code>true</code> and <code>result.message</code> to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with <code>∘</code>. The convergence check is performed after any <code>callback</code>.</p></li><li><p><code>verbose=false</code>: If <code>true</code>, print information during initialization.</p></li><li><p><code>rethrow_exceptions</code>: By default, any exception ends the optimization but still returns a <a href="../api_externals/#Krotov.KrotovResult"><code>KrotovResult</code></a> that captures the message associated with the exception. This is to avoid losing results from a long-running optimization when an exception occurs in a later iteration. If <code>rethrow_exceptions=true</code>, instead of capturing the exception, it will be thrown normally.</p></li></ul><p><strong>Trajectory propagation</strong></p><p>Krotov&#39;s method involves the forward and backward propagation for every <a href="../api/reference/#QuantumControl.Trajectory"><code>Trajectory</code></a> in the <code>problem</code>. The keyword arguments for each propagation (see <a href="../api/quantum_propagators/#QuantumPropagators.propagate"><code>propagate</code></a>) are determined from any properties of each <a href="../api/reference/#QuantumControl.Trajectory"><code>Trajectory</code></a> that have a <code>prop_</code> prefix, cf. <a href="https://juliaquantumcontrol.github.io/Krotov.jl/dev/externals/#QuantumControl.init_prop_trajectory-Tuple%7BTrajectory%2C%20Any%7D"><code>init_prop_trajectory</code></a>.</p><p>In situations where different parameters are required for the forward and backward propagation, instead of the <code>prop_</code> prefix, the <code>fw_prop_</code> and <code>bw_prop_</code> prefixes can be used, respectively. These override any setting with the <code>prop_</code> prefix. This applies both to the properties of each <a href="../api/reference/#QuantumControl.Trajectory"><code>Trajectory</code></a> and the problem keyword arguments.</p><p>Note that the propagation method for each propagation must be specified. In most cases, it is sufficient (and recommended) to pass a global <code>prop_method</code> problem keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/Krotov.jl/blob/98e049a9845c8e5c132e7962c567a7496cd507b7/src/optimize.jl#L16-L154">source</a></section></article><h2 id="GRAPE"><a class="docs-heading-anchor" href="#GRAPE">GRAPE</a><a id="GRAPE-1"></a><a class="docs-heading-anchor-permalink" href="#GRAPE" title="Permalink"></a></h2><p>The Gradient Ascent Pulse Engineering (GRAPE) method is implemented in the <a href="https://github.com/JuliaQuantumControl/GRAPE.jl"><code>GRAPE</code> package</a>. See the <a href="https://juliaquantumcontrol.github.io/GRAPE.jl/dev/"><code>GRAPE</code> documentation</a> for details.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumControl.optimize-Tuple{ControlProblem, Val{:GRAPE}}-methods" href="#QuantumControl.optimize-Tuple{ControlProblem, Val{:GRAPE}}-methods"><code>QuantumControl.optimize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">using GRAPE
result = optimize(problem; method=GRAPE, kwargs...)</code></pre><p>optimizes the given control <a href="../api/reference/#QuantumControl.ControlProblem"><code>problem</code></a> via the GRAPE method, by minimizing the functional</p><p class="math-container">\[J(\{ϵ_{nl}\}) = J_T(\{|ϕ_k(T)⟩\}) + λ_a J_a(\{ϵ_{nl}\})\]</p><p>where the final time functional <span>$J_T$</span> depends explicitly on the forward-propagated states and the running cost <span>$J_a$</span> depends explicitly on pulse values <span>$ϵ_{nl}$</span> of the l&#39;th control discretized on the n&#39;th interval of the time grid.</p><p>Returns a <a href="../api_externals/#GRAPE.GrapeResult"><code>GrapeResult</code></a>.</p><p>Keyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of <code>problem</code>; any of these can be overridden with explicit keyword arguments to <code>optimize</code>.</p><p><strong>Required problem keyword arguments</strong></p><ul><li><code>J_T</code>: A function <code>J_T(Ψ, trajectories)</code> that evaluates the final time functional from a list <code>Ψ</code> of forward-propagated states and <code>problem.trajectories</code>. The function <code>J_T</code> may also take a keyword argument <code>tau</code>. If it does, a vector containing the complex overlaps of the target states (<code>target_state</code> property of each trajectory in <code>problem.trajectories</code>) with the propagated states will be passed to <code>J_T</code>.</li></ul><p><strong>Optional problem keyword arguments</strong></p><ul><li><p><code>chi</code>: A function <code>chi(Ψ, trajectories)</code> that receives a list <code>Ψ</code> of the forward propagated states and returns a vector of states <span>$|χₖ⟩ = -∂J_T/∂⟨Ψₖ|$</span>. If not given, it will be automatically determined from <code>J_T</code> via <a href="../api/reference/#QuantumControl.Functionals.make_chi"><code>QuantumControl.Functionals.make_chi</code></a> with the default parameters. Similarly to <code>J_T</code>, if <code>chi</code> accepts a keyword argument <code>tau</code>, it will be passed a vector of complex overlaps.</p></li><li><p><code>chi_min_norm=1e-100</code>: The minimum allowable norm for any <span>$|χₖ(T)⟩$</span>. Smaller norms would mean that the gradient is zero, and will abort the optimization with an error.</p></li><li><p><code>J_a</code>: A function <code>J_a(pulsevals, tlist)</code> that evaluates running costs over the pulse values, where <code>pulsevals</code> are the vectorized values <span>$ϵ_{nl}$</span>, where <code>n</code> are in indices of the time intervals and <code>l</code> are the indices over the controls, i.e., <code>[ϵ₁₁, ϵ₂₁, …, ϵ₁₂, ϵ₂₂, …]</code> (the pulse values for each control are contiguous). If not given, the optimization will not include a running cost.</p></li><li><p><code>gradient_method=:gradgen</code>: One of <code>:gradgen</code> (default) or <code>:taylor</code>. With <code>gradient_method=:gradgen</code>, the gradient is calculated using <a href="https://github.com/JuliaQuantumControl/QuantumGradientGenerators.jl">QuantumGradientGenerators</a>. With <code>gradient_method=:taylor</code>, it is evaluated via a Taylor series, see Eq. (20) in Kuprov and Rogers,  J. Chem. Phys. 131, 234108 (2009) [<a href="../references/#KuprovJCP09">17</a>].</p></li><li><p><code>taylor_grad_max_order=100</code>: If given with <code>gradient_method=:taylor</code>, the maximum number of terms in the Taylor series. If <code>taylor_grad_check_convergence=true</code> (default), if the Taylor series does not convergence within the given number of terms, throw an an error. With <code>taylor_grad_check_convergence=true</code>, this is the exact order of the Taylor series.</p></li><li><p><code>taylor_grad_tolerance=1e-16</code>: If given with <code>gradient_method=:taylor</code> and <code>taylor_grad_check_convergence=true</code>, stop the Taylor series when the norm of the term falls below the given tolerance. Ignored if <code>taylor_grad_check_convergence=false</code>.</p></li><li><p><code>taylor_grad_check_convergence=true</code>: If given as <code>true</code> (default), check the convergence after each term in the Taylor series an stop as soon as the norm of the term drops below the given number. If <code>false</code>, stop after exactly <code>taylor_grad_max_order</code> terms.</p></li><li><p><code>lambda_a=1</code>: A weight for the running cost <code>J_a</code>.</p></li><li><p><code>grad_J_a</code>: A function to calculate the gradient of <code>J_a</code>. If not given, it will be automatically determined. See <a href="../api/reference/#QuantumControl.Functionals.make_grad_J_a"><code>make_grad_J_a</code></a> for the required interface.</p></li><li><p><code>upper_bound</code>: An upper bound for the value of any optimized control. Time-dependent upper bounds can be specified via <code>pulse_options</code>.</p></li><li><p><code>lower_bound</code>: A lower bound for the value of any optimized control. Time-dependent lower bounds can be specified via <code>pulse_options</code>.</p></li><li><p><code>pulse_options</code>: A dictionary that maps every control (as obtained by <a href="../api/quantum_propagators/#QuantumPropagators.Controls.get_controls"><code>get_controls</code></a> from the <code>problem.trajectories</code>) to a dict with the following possible keys:</p><ul><li><code>:upper_bounds</code>: A vector of upper bound values, one for each intervals of the time grid. Values of <code>Inf</code> indicate an unconstrained upper bound for that time interval, respectively the global <code>upper_bound</code>, if given.</li><li><code>:lower_bounds</code>: A vector of lower bound values. Values of <code>-Inf</code> indicate an unconstrained lower bound for that time interval,</li></ul></li><li><p><code>print_iters=true</code>: Whether to print information after each iteration.</p></li><li><p><code>print_iter_info=[&quot;iter.&quot;, &quot;J_T&quot;, &quot;|∇J|&quot;, &quot;|Δϵ|&quot;, &quot;ΔJ&quot;, &quot;FG(F)&quot;, &quot;secs&quot;]</code>: Which fields to print if <code>print_iters=true</code>. If given, must be a list of header labels (strings), which can be any of the following:</p><ul><li><p><code>&quot;iter.&quot;</code>: The iteration number</p></li><li><p><code>&quot;J_T&quot;</code>: The value of the final-time functional for the dynamics under the optimized pulses</p></li><li><p><code>&quot;J_a&quot;</code>: The value of the pulse-dependent running cost for the optimized pulses</p></li><li><p><code>&quot;λ_a⋅J_a&quot;</code>: The total contribution of <code>J_a</code> to the full functional <code>J</code></p></li><li><p><code>&quot;J&quot;</code>: The value of the optimization functional for the optimized pulses</p></li><li><p><code>&quot;ǁ∇J_Tǁ&quot;</code>: The ℓ²-norm of the <em>current</em> gradient of the final-time functional. Note that this is usually the gradient of the optimize pulse, not the guess pulse.</p></li><li><p><code>&quot;ǁ∇J_aǁ&quot;</code>: The ℓ²-norm of the the <em>current</em> gradient of the pulse-dependent running cost. For comparison with <code>&quot;ǁ∇J_Tǁ&quot;</code>.</p></li><li><p><code>&quot;λ_aǁ∇J_aǁ&quot;</code>: The ℓ²-norm of the the <em>current</em> gradient of the complete pulse-dependent running cost term. For comparison with <code>&quot;ǁ∇J_Tǁ&quot;</code>.</p></li><li><p><code>&quot;ǁ∇Jǁ&quot;</code>: The norm of the guess pulse gradient. Note that the <em>guess</em> pulse gradient is not the same the <em>current</em> gradient.</p></li><li><p><code>&quot;ǁΔϵǁ&quot;</code>:  The ℓ²-norm of the pulse update</p></li><li><p><code>&quot;ǁϵǁ&quot;</code>: The ℓ²-norm of optimized pulse values</p></li><li><p><code>&quot;max|Δϵ|&quot;</code> The maximum value of the pulse update (infinity norm)</p></li><li><p><code>&quot;max|ϵ|&quot;</code>: The maximum value of the pulse values (infinity norm)</p></li><li><p><code>&quot;ǁΔϵǁ/ǁϵǁ&quot;</code>: The ratio of the pulse update tothe optimized pulse values</p></li><li><p><code>&quot;∫Δϵ²dt&quot;</code>: The L²-norm of the pulse update, summed over all pulses. A convergence measure comparable (proportional) to the running cost in Krotov&#39;s method</p></li><li><p><code>&quot;ǁsǁ&quot;</code>: The norm of the search direction. Should be <code>ǁΔϵǁ</code> scaled by the step with <code>α</code>.</p></li><li><p><code>&quot;∠°&quot;</code>: The angle (in degrees) between the negative gradient <code>-∇J</code> and the search direction <code>s</code>.</p></li><li><p><code>&quot;α&quot;</code>: The step width as determined by the line search (<code>Δϵ = α⋅s</code>)</p></li><li><p><code>&quot;ΔJ_T&quot;</code>: The change in the final time functional relative to the previous iteration</p></li><li><p><code>&quot;ΔJ_a&quot;</code>:  The change in the control-dependent running cost relative to the previous iteration</p></li><li><p><code>&quot;λ_a⋅ΔJ_a&quot;</code>: The change in the control-dependent running cost term relative to the previous iteration.</p></li><li><p><code>&quot;ΔJ&quot;</code>:  The change in the total optimization functional relative to the previous iteration.</p></li><li><p><code>&quot;FG(F)&quot;</code>:  The number of functional/gradient evaluation (FG), or pure functional (F) evaluations</p></li><li><p><code>&quot;secs&quot;</code>:  The number of seconds of wallclock time spent on the iteration.</p></li><li><p><code>store_iter_info=[]</code>: Which fields to store in <code>result.records</code>, given as</p></li></ul><p>a list of header labels, see <code>print_iter_info</code>.</p></li><li><p><code>callback</code>: A function (or tuple of functions) that receives the <a href="../api_externals/#GRAPE.GrapeWrk">GRAPE workspace</a> and the iteration number. The function may return a tuple of values which are stored in the <a href="../api_externals/#GRAPE.GrapeResult"><code>GrapeResult</code></a> object <code>result.records</code>. The function can also mutate the workspace, in particular the updated <code>pulsevals</code>. This may be used, e.g., to apply a spectral filter to the updated pulses or to perform similar manipulations. Note that <code>print_iters=true</code> (default) adds an automatic callback to print information after each iteration. With <code>store_iter_info</code>, that callback automatically stores a subset of the available information.</p></li><li><p><code>check_convergence</code>: A function to check whether convergence has been reached. Receives a <a href="../api_externals/#GRAPE.GrapeResult"><code>GrapeResult</code></a> object <code>result</code>, and should set <code>result.converged</code> to <code>true</code> and <code>result.message</code> to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with <code>∘</code>. The convergence check is performed after any <code>callback</code>.</p></li><li><p><code>x_tol</code>: Parameter for Optim.jl</p></li><li><p><code>f_tol</code>: Parameter for Optim.jl</p></li><li><p><code>g_tol</code>: Parameter for Optim.jl</p></li><li><p><code>show_trace</code>: Parameter for Optim.jl</p></li><li><p><code>extended_trace</code>:  Parameter for Optim.jl</p></li><li><p><code>show_every</code>: Parameter for Optim.jl</p></li><li><p><code>allow_f_increases</code>: Parameter for Optim.jl</p></li><li><p><code>optimizer</code>: An optional Optim.jl optimizer (<code>Optim.AbstractOptimizer</code> instance). If not given, an <a href="https://github.com/Gnimuc/LBFGSB.jl">L-BFGS-B</a> optimizer will be used.</p></li><li><p><code>prop_method</code>: The propagation method to use for each trajectory, see below.</p></li><li><p><code>verbose=false</code>: If <code>true</code>, print information during initialization</p></li><li><p><code>rethrow_exceptions</code>: By default, any exception ends the optimization, but still returns a <a href="../api_externals/#GRAPE.GrapeResult"><code>GrapeResult</code></a> that captures the message associated with the exception. This is to avoid losing results from a long-running optimization when an exception occurs in a later iteration. If <code>rethrow_exceptions=true</code>, instead of capturing the exception, it will be thrown normally.</p></li></ul><p><strong>Trajectory propagation</strong></p><p>GRAPE may involve three types of propagation:</p><ul><li>A forward propagation for every <a href="../api/reference/#QuantumControl.Trajectory"><code>Trajectory</code></a> in the <code>problem</code></li><li>A backward propagation for every trajectory</li><li>A backward propagation of a <a href="https://juliaquantumcontrol.github.io/QuantumGradientGenerators.jl/dev/api/#QuantumGradientGenerators.GradGenerator">gradient generator</a> for every trajectory.</li></ul><p>The keyword arguments for each propagation (see <a href="../api/quantum_propagators/#QuantumPropagators.propagate"><code>propagate</code></a>) are determined from any properties of each <a href="../api/reference/#QuantumControl.Trajectory"><code>Trajectory</code></a> that have a <code>prop_</code> prefix, cf. <a href="https://juliaquantumcontrol.github.io/Krotov.jl/dev/externals/#QuantumControl.init_prop_trajectory-Tuple%7BTrajectory%2C%20Any%7D"><code>init_prop_trajectory</code></a>.</p><p>In situations where different parameters are required for the forward and backward propagation, instead of the <code>prop_</code> prefix, the <code>fw_prop_</code> and <code>bw_prop_</code> prefix can be used, respectively. These override any setting with the <code>prop_</code> prefix. Similarly, properties for the backward propagation of the gradient generators can be set with properties that have a <code>grad_prop_</code> prefix. These prefixes apply both to the properties of each <a href="../api/reference/#QuantumControl.Trajectory"><code>Trajectory</code></a> and the problem keyword arguments.</p><p>Note that the propagation method for each propagation must be specified. In most cases, it is sufficient (and recommended) to pass a global <code>prop_method</code> problem keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/GRAPE.jl/blob/09973b88a9d941fc26d66fda40a502d163b82f83/src/optimize.jl#L15-L212">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview/">« Overview</a><a class="docs-footer-nextpage" href="../howto/">Howto »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/QuantumControl.jl">QuantumControl.jl</a> v0.11.1+dev docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Saturday 17 May 2025 03:36">Saturday 17 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

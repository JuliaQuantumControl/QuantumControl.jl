<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · QuantumControl.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://QuantumControl-jl.github.io/QuantumControl.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>QuantumControl.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Control-problems"><span>Control problems</span></a></li><li><a class="tocitem" href="#Discretization"><span>Discretization</span></a></li><li><a class="tocitem" href="#Time-dependencies"><span>Time dependencies</span></a></li><li><a class="tocitem" href="#Control-shapes"><span>Control shapes</span></a></li><li><a class="tocitem" href="#Propagation"><span>Propagation</span></a></li><li><a class="tocitem" href="#Storage"><span>Storage</span></a></li><li><a class="tocitem" href="#Optimization"><span>Optimization</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="QuantumControl"><a class="docs-heading-anchor" href="#QuantumControl">QuantumControl</a><a id="QuantumControl-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControl" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/quantumcontrol-jl/QuantumControl.jl">QuantumControl</a>.</p><h2 id="Control-problems"><a class="docs-heading-anchor" href="#Control-problems">Control problems</a><a id="Control-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Control-problems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.ControlProblem" href="#QuantumControlBase.ControlProblem"><code>QuantumControlBase.ControlProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A full control problem with multiple objectives.</p><pre><code class="language-julia hljs">ControlProblem(
   objectives=&lt;list of objectives&gt;,
   pulse_options=&lt;dict of controls to pulse options&gt;,
   tlist=&lt;time grid&gt;,
   kwargs...
)</code></pre><p>Note that the control problem can only be instantiated via keyword arguments.</p><p>The <code>objectives</code> are a list of <a href="#QuantumControlBase.Objective"><code>Objective</code></a> instances, each defining an initial state, a dynamical generator for the evolution of the state, and (optionally) a target for the evolution.</p><p>The <code>pulse_options</code> are a dictionary (<code>IdDict</code>) mapping controls that occur in the <code>objectives</code> to properties specific to the control method.</p><p>The <code>tlist</code> is the time grid on which the time evolution of the initial states of each objective should be propagated.</p><p>The remaining <code>kwargs</code> are keyword arguments that are passed directl to the optimal control method. These typically include e.g. the optimization functional.</p><p>The control problem is solved by finding a set of controls that simultaneously fulfill all objectives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/42ef8e574c2488e7546f33cdd77cc00b4884f074/src/controlproblem.jl#L3-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Objective" href="#QuantumControlBase.Objective"><code>QuantumControlBase.Objective</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A single optimization objective.</p><pre><code class="language-julia hljs">Objective(
    initial_state=&lt;intial state&gt;,
    generator=&lt;dynamical generator&gt;,
    [target=&lt;optional target state or specification&gt;]
)

Note that the objective can only be instantiated via keyword arguments.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/42ef8e574c2488e7546f33cdd77cc00b4884f074/src/controlproblem.jl#L46-L58">source</a></section></article><h2 id="Discretization"><a class="docs-heading-anchor" href="#Discretization">Discretization</a><a id="Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.discretize" href="#QuantumControlBase.discretize"><code>QuantumControlBase.discretize</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Evaluate <code>control</code> at every point of <code>tlist</code>.</p><pre><code class="language-julia hljs">values = discretize(control, tlist; via_midpoints=true)</code></pre><p>discretizes the given <code>control</code> to a Vector of values defined on the points of <code>tlist</code>.</p><p>If <code>control</code> is a function, it will will first be evaluated at the midpoint of <code>tlist</code>, see <a href="#QuantumControlBase.discretize_on_midpoints"><code>discretize_on_midpoints</code></a>, and then the values on the midpoints are converted to values on <code>tlist</code>. This discretization is more stable than directly evaluationg the control function at the values of <code>tlist</code>, and ensures that repeated round-trips between <a href="#QuantumControlBase.discretize"><code>discretize</code></a> and <a href="#QuantumControlBase.discretize_on_midpoints"><code>discretize_on_midpoints</code></a> can be done safely, see the note in the documentation of <a href="#QuantumControlBase.discretize_on_midpoints"><code>discretize_on_midpoints</code></a>.</p><p>The latter can still be achieved by passing <code>via_midpoints=false</code>. While such a direct discretization is suitable e.g. for plotting, but it is unsuitable for round-trips between <a href="#QuantumControlBase.discretize"><code>discretize</code></a> and <a href="#QuantumControlBase.discretize_on_midpoints"><code>discretize_on_midpoints</code></a>  (constant controls on <code>tlist</code> may result in a zig-zag on the intervals of <code>tlist</code>).</p><p>If <code>control</code> is a vector, it will be returned un-modified if it is of the same length as <code>tlist</code>. Otherwise, <code>control</code> must have one less value than <code>tlist</code>, and is assumed to be defined on the midpoins of <code>tlist</code>. In that case, <a href="#QuantumControlBase.discretize"><code>discretize</code></a> acts as the inverse of <a href="#QuantumControlBase.discretize_on_midpoints"><code>discretize_on_midpoints</code></a>. See <a href="#QuantumControlBase.discretize_on_midpoints"><code>discretize_on_midpoints</code></a> for how control values on <code>tlist</code> and control values on the intervals of <code>tlist</code> are related.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/42ef8e574c2488e7546f33cdd77cc00b4884f074/src/controls.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.discretize_on_midpoints" href="#QuantumControlBase.discretize_on_midpoints"><code>QuantumControlBase.discretize_on_midpoints</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Evaluate <code>control</code> at the midpoints of <code>tlist</code>.</p><pre><code class="nohighlight hljs">values = discretize_on_midpoints(control, tlist)</code></pre><p>discretizes the given <code>control</code> to a Vector of values on the midpoints of <code>tlist</code>. Hence, the resulting <code>values</code> will contain one less value than <code>tlist</code>.</p><p>If <code>control</code> is a vector of values defined on <code>tlist</code> (i.e., of the same length as <code>tlist</code>), it will be converted to a vector of values on the intervals of <code>tlist</code>. The value for the first and last &quot;midpoint&quot; will remain the original values at the beginning and end of <code>tlist</code>, in order to ensure exact bounary conditions. For all other midpoints, the value for that midpoint will be calculated by &quot;un-averaging&quot;.</p><p>For example, for a <code>control</code> and <code>tlist</code> of length 5, consider the following diagram:</p><pre><code class="nohighlight hljs">tlist index:       1   2   3   4   5
tlist:             ⋅   ⋅   ⋅   ⋅   ⋅   input values cᵢ (i ∈ 1..5)
                   |̂/ ̄ ̄ ̂\ / ̂\ / ̂ ̄ ̄\|̂
midpoints:         x     x   x     x   output values pᵢ (i ∈ 1..4)
midpoints index:   1     2   3     4</code></pre><p>We will have <span>$p₁=c₁$</span> for the first value, <span>$p₄=c₅$</span> for the last value. For all other points, the control values <span>$cᵢ = \frac{p_{i-1} + p_{i}}{2}$</span> are the average of the values on the midpoints. This implies the &quot;un-averaging&quot; for the midpoint values <span>$pᵢ = 2 c_{i} - p_{i-1}$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>An arbitrary input <code>control</code> array may not be compatible with the above averaging formula. In this case, the conversion will be &quot;lossy&quot; (<a href="#QuantumControlBase.discretize"><code>discretize</code></a> will not recover the original <code>control</code> array; the difference should be considered a &quot;discretization error&quot;). However, any <em>further</em> round-trip conversions between points and intervals are bijective and preserve the boundary conditions. In this case, the <a href="#QuantumControlBase.discretize_on_midpoints"><code>discretize_on_midpoints</code></a> and <a href="#QuantumControlBase.discretize"><code>discretize</code></a> methods are each other&#39;s inverse. This also implies that for an optimal control procedure, it is safe to modify <em>midpoint</em> values. Modifying the the values on the time grid directly on the other hand may accumulate discretization errors.</p></div></div><p>If <code>control</code> is a vector of one less length than <code>tlist</code>, it will be returned unchanged, under the assumption that the input is already properly discretized.</p><p>If <code>control</code> is a function, the function will be directly evaluated at the midpoints marked as <code>x</code> in the above diagram..</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/42ef8e574c2488e7546f33cdd77cc00b4884f074/src/controls.jl#L61-L113">source</a></section></article><h2 id="Time-dependencies"><a class="docs-heading-anchor" href="#Time-dependencies">Time dependencies</a><a id="Time-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Time-dependencies" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.setcontrolvals" href="#QuantumControlBase.setcontrolvals"><code>QuantumControlBase.setcontrolvals</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct <code>G</code> by plugging values into a general generator.</p><pre><code class="language-julia hljs">G = setcontrolvals(generator, vals_dict)
setcontrolvals!(G, generator, vals_dict)</code></pre><p>evaluates the <em>specific</em> dynamical generator <code>G</code> by plugging in values into the general <code>generator</code> according to <code>vals_dict</code>.</p><p>The <code>vals_dict</code> is a dictionary (<code>IdDict</code>) mapping controls as returned by <code>getcontrols(generator)</code> to values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/42ef8e574c2488e7546f33cdd77cc00b4884f074/src/controls.jl#L207-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.setcontrolvals!" href="#QuantumControlBase.setcontrolvals!"><code>QuantumControlBase.setcontrolvals!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>In-place version of <a href="#QuantumControlBase.setcontrolvals"><code>setcontrolvals</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/42ef8e574c2488e7546f33cdd77cc00b4884f074/src/controls.jl#L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.getcontrols" href="#QuantumControlBase.getcontrols"><code>QuantumControlBase.getcontrols</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Extract a Tuple of controls.</p><pre><code class="language-julia hljs">controls = getcontrols(generator)</code></pre><p>extracts the controls from a single dynamical generator.</p><pre><code class="language-julia hljs">controls = getcontrols(objectives)</code></pre><p>extracts the controls from a list of objectives (i.e., from each objective&#39;s <code>generator</code>)</p><p>In either case, controls that occur multiple times, either in a single generator, or throughout the different objectives, will occur only once in the result.</p><p>By default, assumes that any <code>generator</code> is a nested Tuple, e.g. <code>(H0, (H1, ϵ1), (H2, ϵ2), ...)</code> and extracts (ϵ1, ϵ2)</p><p>Each control must be a valid argument for <code>discretize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/42ef8e574c2488e7546f33cdd77cc00b4884f074/src/controls.jl#L145-L169">source</a></section></article><h2 id="Control-shapes"><a class="docs-heading-anchor" href="#Control-shapes">Control shapes</a><a id="Control-shapes-1"></a><a class="docs-heading-anchor-permalink" href="#Control-shapes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.flattop" href="#QuantumControlBase.flattop"><code>QuantumControlBase.flattop</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Flat shape (one) with a switch-on/switch-off from zero.</p><pre><code class="language-julia hljs">flattop(t; t₀, T, t_rise, t_fall=t_rise, func=:blackman)</code></pre><p>evaluates a shape function that starts at 0 at <span>$t=t₀$</span>, and ramps to to 1 during the <code>t_rise</code> interval. The function then remains at value 1, before ramping down to 0 again during the interval <code>t_fall</code> before <code>T</code>. For <span>$t &lt; t₀$</span> and <span>$t &gt; T$</span>, the shape is zero.</p><p>The default switch-on/-off shape is half of a Blackman window (see <a href="#QuantumControlBase.blackman"><code>blackman</code></a>).</p><p>For <code>func=:sinsq</code>, the switch-on/-off shape is a sine-squared curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/42ef8e574c2488e7546f33cdd77cc00b4884f074/src/shapes.jl#L4-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.box" href="#QuantumControlBase.box"><code>QuantumControlBase.box</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Box shape (Theta-function).</p><pre><code class="language-julia hljs">box(t, t₀, T)</code></pre><p>evaluates the Heaviside (Theta-) function <span>$\Theta(t) = 1$</span> for <span>$t_0 \le t \le T$</span>; and <span>$\Theta(t) = 0$</span> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/42ef8e574c2488e7546f33cdd77cc00b4884f074/src/shapes.jl#L61-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.blackman" href="#QuantumControlBase.blackman"><code>QuantumControlBase.blackman</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Blackman window shape.</p><pre><code class="language-julia hljs">blackman(t, t₀, T; a=0.16)</code></pre><p>calculates</p><p class="math-container">\[B(t; t_0, T) =
    \frac{1}{2}\left(
        1 - a - \cos\left(2π \frac{t - t_0}{T - t_0}\right)
        + a \cos\left(4π \frac{t - t_0}{T - t_0}\right)
    \right)\,,\]</p><p>for a scalar <code>t</code>, with <span>$a$</span> = 0.16.</p><p>See <a href="http://en.wikipedia.org/wiki/Window_function#Blackman_windows">http://en.wikipedia.org/wiki/Window_function#Blackman_windows</a></p><p>A Blackman shape looks nearly identical to a Gaussian with a 6-sigma interval between <code>t₀</code> and <code>T</code>.  Unlike the Gaussian, however, it will go exactly to zero at the edges. Thus, Blackman pulses are often preferable to Gaussians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/42ef8e574c2488e7546f33cdd77cc00b4884f074/src/shapes.jl#L73-L98">source</a></section></article><h2 id="Propagation"><a class="docs-heading-anchor" href="#Propagation">Propagation</a><a id="Propagation-1"></a><a class="docs-heading-anchor-permalink" href="#Propagation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.propagate" href="#QuantumPropagators.propagate"><code>QuantumPropagators.propagate</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Propagate a state over an entire time grid.</p><pre><code class="language-julia hljs">propagate(state, genfunc, tlist;
          backwards=false; wrk=nothing, method=:auto, storage=nothing,
          observables=(&lt;store state&gt;, ), hook=nothing)</code></pre><p>propagates <code>state</code> over the time grid in <code>tlist</code>, using piecewise-constant dynamical generators (Hamiltonians or Liouvillians) determined by <code>genfunc</code>, and returns the resulting propagated state. The propagation is performed by calling <a href="#QuantumPropagators.propstep!"><code>propstep!</code></a> for every interval in <code>tlist</code>.</p><p>For the i&#39;th time interval, <code>genfunc(tlist, i)</code> must return the generator for that time interval. Generally, when approximating a time-continuous dynamical generator as piecewise-constant on the time grid, it should be evaluated at the <em>midpoint</em> of the interval. A possible exception is the first and last interval, which may be better evaluated at <code>tlist[1]</code> and <code>tlist[end]</code> to ensure exact boundary conditions like control fields that are exactly zero.</p><p>In addition to the two positional parameters indicating the time interval, <code>genfunc</code> will also receive the <code>state</code> (the input state for the propagation step), <code>backwards</code>, <code>storage</code>, <code>observables</code>, and <code>init</code> as keyword arguments. These additional parameters may be used for unusual equations of motion beyond the standard Schrödinger or Liouville-von-Neumann equation, e.g. <code>state</code> would enter the <code>genfunc</code> for a Gross–Pitaevskii equation. For standard equations of motion that do not use the additional parameters, it is best to capture the keyword arguments to <code>genfunc</code> with a definition like</p><pre><code class="language-julia hljs">genfunc(tlist, i; kwargs...) = ...</code></pre><p>The propagation method is determined by <code>wrk</code>, see <a href="#QuantumPropagators.initpropwrk"><code>initpropwrk</code></a> and <a href="@ref">`propstep!</a>: If <code>wrk</code> is not given, it will be created internally for the given <code>method</code> with <a href="#QuantumPropagators.initpropwrk"><code>initpropwrk</code></a>; for the default <code>method=:auto</code>, <a href="#QuantumPropagators.initpropwrk"><code>initpropwrk</code></a> will attempt to choose the most appropriate method for the given parameters, using the generator returned by <code>genfunc</code> with <code>i=1</code> and the keyword argument <code>init=true</code>.</p><p>In general, there is no requirement that <code>tlist</code> has a constant time step, although some propagation methods (most notably <a href="#QuantumPropagators.cheby!"><code>cheby!</code></a>) only support a uniform time grid.</p><p>If <code>storage</code> is given as an Array, it will be filled with data determined by the <code>observables</code>. The default &quot;observable&quot; results in the propagated states at every point in time being stored. The <code>storage</code> array should be created with <a href="#QuantumPropagators.init_storage"><code>init_storage</code></a>. See its documentation for details.</p><p>The <code>storage</code> parameter may also be given as <code>true</code>, and a new storage array will be created internally with <a href="#QuantumPropagators.init_storage"><code>init_storage</code></a> and returned instead of the propagated state.</p><p>If <code>backwards</code> is <code>true</code>, the input state is assumed to be at time <code>tlist[end]</code>, and the propagation progresses backwards in time (with a negative time step <code>dt</code>). If <code>storage</code> is given, it will be filled back-to-front during the backwards propagation.</p><p>If <code>hook</code> is given as a callable, it will be called after each propagation step, as <code>hook(state, generator, tlist, i, wrk, observables)</code> where <code>i</code> is the index of the time interval on <code>tlist</code> covered by the propagation step (0 for the initial state, respectives <code>lastindex(tlist)</code> for the backward propagation).  The <code>hook</code> is called before calculating any observables. Example usage includes writing data to file, or modyfing <code>state</code>, e.g. removing amplitude from the lowest and highest level to mitigate &quot;truncation error&quot;.</p><p>The <code>propagate</code> routine returns the propagated state at <code>tlist[end]</code>, respectively <code>tlist[1]</code> if <code>backwards=true</code>, or a storage array with the stored states / observable data if <code>storage=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/313a2d85eb8f29def807cbb3d03f85fffacc28f3/src/propagate.jl#L88-L159">source</a></section><section><div><p>Propagate the initial state of a control objective.</p><pre><code class="language-julia hljs">propagate(obj, tlist; controls_map=IdDict(), kwargs...)</code></pre><p>propagates <code>obj.initial_state</code> under the dynamics described by <code>obj.generator</code>.</p><p>The optional dict <code>control_map</code> may be given to replace the controls in <code>obj.generator</code> (as obtained by <a href="#QuantumControlBase.getcontrols"><code>getcontrols</code></a>) with custom functions or vectors, e.g. with the controls resulting from optimization.</p><p>All <code>kwargs</code> are forwarded to <code>QuantumPropagators.propagate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/42ef8e574c2488e7546f33cdd77cc00b4884f074/src/propagate.jl#L6-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.initpropwrk" href="#QuantumPropagators.initpropwrk"><code>QuantumPropagators.initpropwrk</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Initialize a workspace for propagation.</p><pre><code class="language-julia hljs">wrk = initpropwrk(state, tlist, generator...; method=:auto, kwargs...)</code></pre><p>The resulting <code>wrk</code> can be passed to <a href="#QuantumPropagators.propagate"><code>propagate</code></a> or <a href="#QuantumPropagators.propstep!"><code>propstep!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: An exemplary state for the propagation (e.g., the initial state)</li><li><code>tlist</code>: The time grid over which <a href="#QuantumPropagators.propagate"><code>propagate</code></a> will be called. Must include at least to points in order to determine the propagation time step to prepare. If the propagation will be over a <code>tlist</code> with a variable <code>dt</code>, the full <code>tlist</code> must be passed here.</li><li><code>generator</code>: An exemplary (non-time-dependent) dynamical generator. For full generality (if <code>method=:cheby</code>), the given <code>generator</code> should have a spectral range sufficiently large to encompass the entire propagation. If given multiple times, a spectral envelope enclosing all the generators will be determined automatically. In this case, you should pass the generators with the extremal values of all the controls.</li><li><code>method</code>: The propagation method to use. The default value of <code>:auto</code> attempts to choose the best method available, based on the properties of the given <code>state</code>, <code>tlist</code>, and <code>generator</code>. Alternative values are <code>:cheby</code> and <code>:newton</code>, and <code>:expprop</code>.</li></ul><p>All other <code>kwargs</code> are filtered and passed to the contructor for returned workspace, e.g. <code>limit</code> for <code>method=:cheby</code> or <code>m_max</code> for <code>method=:newton</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/313a2d85eb8f29def807cbb3d03f85fffacc28f3/src/propagate.jl#L1-L31">source</a></section><section><div><pre><code class="language-julia hljs">wrk = initpropwrk(obj, tlist; method=:auto, kwargs...)</code></pre><p>initializes a workspace for the propagation of a control <a href="#QuantumControlBase.Objective"><code>Objective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/42ef8e574c2488e7546f33cdd77cc00b4884f074/src/propagate.jl#L53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.propstep!" href="#QuantumPropagators.propstep!"><code>QuantumPropagators.propstep!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Perform a single propagation step in-place.</p><pre><code class="language-julia hljs">propstep!(state, generator, dt, wrk;, kwargs...)</code></pre><p>The propagation method is determined by <code>wrk</code>, see <a href="#QuantumPropagators.initpropwrk"><code>initpropwrk</code></a>. The <code>kwargs</code> are forwarded to the underlying method</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/313a2d85eb8f29def807cbb3d03f85fffacc28f3/src/propagate.jl#L58-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.ChebyWrk" href="#QuantumPropagators.ChebyWrk"><code>QuantumPropagators.ChebyWrk</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Workspace for the Chebychev propagation routine.</p><pre><code class="language-julia hljs">    ChebyWrk(Ψ, Δ, E_min, dt; limit=1e-12)</code></pre><p>initializes the workspace for the propagation of a state similar to Ψ under a Hamiltonian with eigenvalues between <code>E_min</code> and <code>E_min + Δ</code>, and a time step dt. Chebychev coefficients smaller than the given <code>limit</code> are discarded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/313a2d85eb8f29def807cbb3d03f85fffacc28f3/src/cheby.jl#L58-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.cheby_coeffs!" href="#QuantumPropagators.cheby_coeffs!"><code>QuantumPropagators.cheby_coeffs!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculate Chebychev coefficients in-place.</p><p>Writes the coefficients into <code>coeffs</code>. Returns the number <code>n</code> of coefficients required for convergence, or the size of <code>coeffs</code>, whichever is less.</p><ul><li><code>coeffs</code>: An array to hold the Chebychev cofficients. On output, the elements  1 through <code>n</code> will hold the calculated coefficients, while the remaining  elements will be unchanged</li><li><code>dt</code>: the time step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/313a2d85eb8f29def807cbb3d03f85fffacc28f3/src/cheby.jl#L33-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.cheby_coeffs" href="#QuantumPropagators.cheby_coeffs"><code>QuantumPropagators.cheby_coeffs</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculate Chebychev coefficients.</p><p>Return an array of coefficiencts larger than <code>limit</code>.</p><p>Args:</p><ul><li><code>Δ</code>: the spectral radius of the underlying operator</li><li><code>dt</code>: the time step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/313a2d85eb8f29def807cbb3d03f85fffacc28f3/src/cheby.jl#L7-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.NewtonWrk" href="#QuantumPropagators.NewtonWrk"><code>QuantumPropagators.NewtonWrk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">    NewtonWrk(v0, m_max=10)</code></pre><p>Workspace for the Newton-with-restarted-Arnoldi propagation routine.</p><p>Initializes the workspace for the propagation of a vector <code>v0</code>, using a maximum Krylov dimension of <code>m_max</code> in each restart iteration. Note that <code>m_max</code> should be smaller than the length of <code>v0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/313a2d85eb8f29def807cbb3d03f85fffacc28f3/src/newton.jl#L7-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.ExpPropWrk" href="#QuantumPropagators.ExpPropWrk"><code>QuantumPropagators.ExpPropWrk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">    ExpPropWrk(v0)</code></pre><p>Workspace for propagation via direct matrix exponentiation.</p><p>Initializes the workspace for the propagation of a vector <code>v0</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/313a2d85eb8f29def807cbb3d03f85fffacc28f3/src/expprop.jl#L6-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.cheby!" href="#QuantumPropagators.cheby!"><code>QuantumPropagators.cheby!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Evaluate <code>Ψ = exp(-i H dt) Ψ</code> in-place.</p><p>Args:</p><ul><li><code>Ψ</code>: on input, initial vector. Will be overwritten with result.</li><li><code>H</code>: Hermitian operator</li><li><code>dt</code>: time step</li><li><code>E_min</code>: minimum eigenvalue of H, to be used instead of the <code>E_min</code> from the  initialization of <code>wrk</code>. The same <code>wrk</code> may be used for different values  <code>E_min</code>, as long as the spectra radius <code>Δ</code> and the time step <code>dt</code> are the  same as those used for the initialization of <code>wrk</code>.</li></ul><p>The routine will not allocate any internal storage. This implementation requires <code>copyto!</code> <code>lmul!</code>, and <code>axpy!</code> to be implemented for <code>Ψ</code>, and the three-argument <code>mul!</code> for <code>Ψ</code> and <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/313a2d85eb8f29def807cbb3d03f85fffacc28f3/src/cheby.jl#L89-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.newton!" href="#QuantumPropagators.newton!"><code>QuantumPropagators.newton!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newton!(Ψ, H, dt, wrk, func=(z -&gt; exp(-1im*z)); norm_min=1e-14, relerr=1e-12,
        max_restarts=50)</code></pre><p>Evaluate <code>Ψ = func(H*dt) Ψ</code> using a Newton-with-restarted-Arnoldi scheme.</p><p><strong>Arguments</strong></p><ul><li><code>Ψ</code>: The state to propagate, will be overwritten in-place with the propagated state</li><li><code>H</code>: Operator acting on <code>Ψ</code>. Together with <code>dt</code>, this is the argument to <code>func</code></li><li><code>dt</code>: Implicit time step. Together with <code>H</code>, this is the argument to <code>func</code></li><li><code>wkr</code>: Work array, initialized with <a href="#QuantumPropagators.NewtonWrk"><code>NewtonWrk</code></a></li><li><code>func</code>: The function to apply to <code>H dt</code>, taking a single (scalar) complex-valued argument <code>z</code> in place of <code>H dt</code>. The default <code>func</code> is to evaluate the time evoluation operator for the Schrödinger equation</li><li><code>norm_min</code>: the minium norm at which to consider a state similar to <code>Ψ</code> as zero</li><li><code>relerr</code>: The relative error defining the convergence condition for the restart iteration. Propagation stops when the norm of the accumulated <code>Ψ</code> is stable up to the given relative error</li><li><code>max_restart</code>: The maximum number of restart iterations. Exceeding <code>max_restart</code> will throw an <code>AssertionError</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/313a2d85eb8f29def807cbb3d03f85fffacc28f3/src/newton.jl#L316-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.expprop!" href="#QuantumPropagators.expprop!"><code>QuantumPropagators.expprop!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expprop!(Ψ, H, dt, wrk, func=(z -&gt; exp(-1im*z)))</code></pre><p>Evaluate <code>Ψ = func(H*dt) Ψ</code> by directly evaluating <code>U = func(H*dt)</code>, i.e. by matrix exponentiation for the default <code>func</code>, and then multiplying <code>U</code> and <code>Ψ</code> in-place with <code>mul!</code>.</p><p>The workspace <code>wrk</code> must be initialized with <a href="#QuantumPropagators.ExpPropWrk"><code>ExpPropWrk</code></a> to provide storage for a temporary state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/313a2d85eb8f29def807cbb3d03f85fffacc28f3/src/expprop.jl#L23-L33">source</a></section></article><h2 id="Storage"><a class="docs-heading-anchor" href="#Storage">Storage</a><a id="Storage-1"></a><a class="docs-heading-anchor-permalink" href="#Storage" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.init_storage" href="#QuantumPropagators.init_storage"><code>QuantumPropagators.init_storage</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Create a <code>storage</code> array for <a href="#QuantumPropagators.propagate"><code>propagate</code></a>.</p><pre><code class="language-julia hljs">storage = init_storage(state, tlist)</code></pre><p>creates a storage array suitable for storing a <code>state</code> for each point in <code>tlist</code>.</p><pre><code class="language-julia hljs">storage = init_storage(state, tlist, observables))</code></pre><p>creates a storage array suitable for the data generated by the <code>observables</code> applied to <code>state</code>, see <a href="#QuantumPropagators.map_observables"><code>map_observables</code></a>, for each point in <code>tlist</code>.</p><pre><code class="language-julia hljs">storage = init_storage(data, nt))</code></pre><p>creates a storage arrays suitable for storing <code>data</code> nt times, where <code>nt=length(tlist)</code>. By default, this will be a vector of <code>typeof(data)</code> and length <code>nt</code>, or a <code>n × nt</code> Matrix with the same <code>eltype</code> as <code>data</code> if <code>data</code> is a Vector of length <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/313a2d85eb8f29def807cbb3d03f85fffacc28f3/src/storage.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.write_to_storage!" href="#QuantumPropagators.write_to_storage!"><code>QuantumPropagators.write_to_storage!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Place data into <code>storage</code> for time slot <code>i</code>.</p><pre><code class="language-julia hljs">    write_to_storage!(storage, i, state, observables)</code></pre><p>For a <code>storage</code> array created by <a href="#QuantumPropagators.init_storage"><code>init_storage</code></a>, store the data obtains from <a href="#QuantumPropagators.map_observables"><code>map_observables</code></a> into the <code>storage</code> for time slot <code>i</code>. This delegates to the more general</p><pre><code class="language-julia hljs">    write_to_storage!(storage, i, data)</code></pre><p>Conceptually, this corresponds roughly to <code>storage[i] = data</code>, but <code>storage</code> may have its own idea on how to store data for a specific time slot. For example, with the default <a href="#QuantumPropagators.init_storage"><code>init_storage</code></a> Vector data will be stored in a matrix, and <code>write_to_storage!</code> will in this case write data to the i&#39;th column of the matrix.</p><p>For a given type of <code>storage</code> and <code>data</code>, it is the developer&#39;s responsibility that <code>init_storage</code> and <code>write_to_storage!</code> are compatible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/313a2d85eb8f29def807cbb3d03f85fffacc28f3/src/storage.jl#L95-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.get_from_storage!" href="#QuantumPropagators.get_from_storage!"><code>QuantumPropagators.get_from_storage!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Obtain data from storage</p><pre><code class="language-julia hljs">get_from_storage!(state, storage, i)</code></pre><p>extracts data from the <code>storage</code> for the i&#39;th time slot. Invese of <a href="#QuantumPropagators.write_to_storage!"><code>write_to_storage!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/313a2d85eb8f29def807cbb3d03f85fffacc28f3/src/storage.jl#L132-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.map_observable" href="#QuantumPropagators.map_observable"><code>QuantumPropagators.map_observable</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Apply a single <code>observable</code> to <code>state</code>.</p><pre><code class="language-julia hljs">data = map_observable(observable, state)</code></pre><p>By default, <code>observable</code> is assumed to be callable, and the above is equivalent to <code>data = observable(state)</code>.</p><p>If <code>observable</code> is a matrix and <code>state</code> is a vector evaluate the expectation value of the observable as <code>dot(state, observable, state)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/313a2d85eb8f29def807cbb3d03f85fffacc28f3/src/storage.jl#L73-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.map_observables" href="#QuantumPropagators.map_observables"><code>QuantumPropagators.map_observables</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Obtain &quot;observable&quot; data from <code>state</code>.</p><pre><code class="language-julia hljs">data = map_observables(observables, state)</code></pre><p>calculates the data for a tuple of <code>observables</code> applied to <code>state</code>. For a single observable (tuple of length 1), simply return the result of <a href="#QuantumPropagators.map_observable"><code>map_observable</code></a>.</p><p>For multiple observables, return the tuple resulting from applying <a href="#QuantumPropagators.map_observable"><code>map_observable</code></a> for each observable. If the tuple is &quot;uniform&quot; (all elements are of the same type, e.g. if each observable calculates the expectation value of a Hermitian operator), it is converted to a Vector. This allows for compact storage in a storage array, see <a href="#QuantumPropagators.init_storage"><code>init_storage</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/313a2d85eb8f29def807cbb3d03f85fffacc28f3/src/storage.jl#L42-L58">source</a></section></article><h2 id="Optimization"><a class="docs-heading-anchor" href="#Optimization">Optimization</a><a id="Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Krotov.optimize_pulses" href="#Krotov.optimize_pulses"><code>Krotov.optimize_pulses</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Use Krotov&#39;s method to optimize the given optimization problem.</p><pre><code class="language-julia hljs">result = optimize_pulses(problem)</code></pre><p>optimizes the control <code>problem</code>, see <a href="#QuantumControlBase.ControlProblem"><code>QuantumControlBase.ControlProblem</code></a>.</p><p>Parameters are taken from the keyword arguments used in the instantiation of <code>problem</code>.</p><p><strong>Required problem keyword arguments</strong></p><p>The optimization functional is given implicitly via the mandatory <code>problem</code> keyword argument <code>chi</code>.</p><p><strong>Optional problem keyword arguments</strong></p><p>The following <code>problem</code> keyword arguments are supported (with default values):</p><ul><li><code>sigma=nothing</code>: Function that calculate the second-order contribution. If  not given, the first-order Krotov method is used.</li><li><code>iter_start=0</code>: the initial iteration number</li><li><code>iter_stop=5000</code>: the maximum iteration number</li><li><code>check_convergence</code>: a function to check whether convergence has been reached. Receives a <a href="@ref"><code>KrotovResult</code></a> object <code>result</code>, and should set <code>result.converged</code> to <code>true</code> and <code>result.message</code> to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with <code>∘</code>.</li><li><code>prop_method=:auto</code>: The propagation method to use</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControl.jl/blob/1e6923529fb0ff416b6a5fe2e3d76ec56c35a489/src/optimize.jl#L175-L208">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#QuantumControlBase.ControlProblem"><code>QuantumControlBase.ControlProblem</code></a></li><li><a href="#QuantumControlBase.Objective"><code>QuantumControlBase.Objective</code></a></li><li><a href="#QuantumPropagators.ChebyWrk"><code>QuantumPropagators.ChebyWrk</code></a></li><li><a href="#QuantumPropagators.ExpPropWrk"><code>QuantumPropagators.ExpPropWrk</code></a></li><li><a href="#QuantumPropagators.NewtonWrk"><code>QuantumPropagators.NewtonWrk</code></a></li><li><a href="#Krotov.optimize_pulses"><code>Krotov.optimize_pulses</code></a></li><li><a href="#QuantumControlBase.blackman"><code>QuantumControlBase.blackman</code></a></li><li><a href="#QuantumControlBase.box"><code>QuantumControlBase.box</code></a></li><li><a href="#QuantumControlBase.discretize"><code>QuantumControlBase.discretize</code></a></li><li><a href="#QuantumControlBase.discretize_on_midpoints"><code>QuantumControlBase.discretize_on_midpoints</code></a></li><li><a href="#QuantumControlBase.flattop"><code>QuantumControlBase.flattop</code></a></li><li><a href="#QuantumControlBase.getcontrols"><code>QuantumControlBase.getcontrols</code></a></li><li><a href="#QuantumControlBase.setcontrolvals"><code>QuantumControlBase.setcontrolvals</code></a></li><li><a href="#QuantumControlBase.setcontrolvals!"><code>QuantumControlBase.setcontrolvals!</code></a></li><li><a href="#QuantumPropagators.cheby!"><code>QuantumPropagators.cheby!</code></a></li><li><a href="#QuantumPropagators.cheby_coeffs"><code>QuantumPropagators.cheby_coeffs</code></a></li><li><a href="#QuantumPropagators.cheby_coeffs!"><code>QuantumPropagators.cheby_coeffs!</code></a></li><li><a href="#QuantumPropagators.expprop!"><code>QuantumPropagators.expprop!</code></a></li><li><a href="#QuantumPropagators.get_from_storage!"><code>QuantumPropagators.get_from_storage!</code></a></li><li><a href="#QuantumPropagators.init_storage"><code>QuantumPropagators.init_storage</code></a></li><li><a href="#QuantumPropagators.initpropwrk"><code>QuantumPropagators.initpropwrk</code></a></li><li><a href="#QuantumPropagators.map_observable"><code>QuantumPropagators.map_observable</code></a></li><li><a href="#QuantumPropagators.map_observables"><code>QuantumPropagators.map_observables</code></a></li><li><a href="#QuantumPropagators.newton!"><code>QuantumPropagators.newton!</code></a></li><li><a href="#QuantumPropagators.propagate"><code>QuantumPropagators.propagate</code></a></li><li><a href="#QuantumPropagators.propstep!"><code>QuantumPropagators.propstep!</code></a></li><li><a href="#QuantumPropagators.write_to_storage!"><code>QuantumPropagators.write_to_storage!</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Friday 27 August 2021 05:05">Friday 27 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

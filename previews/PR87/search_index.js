var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"P. Brumer and M. Shapiro. Principles and Applications of the Quantum Control of Molecular Processes (Wiley Interscience, 2003).\n\n\n\nC. Brif, R. Chakrabarti and H. Rabitz. Control of quantum phenomena: past, present and future. New J. Phys. 12, 075008 (2010).\n\n\n\nM. Shapiro and P. Brumer. Quantum Control of Molecular Processes. Second Edition, * * (Wiley and Sons, 2012).\n\n\n\nC. P. Koch. Controlling open quantum systems: tools, achievements, and limitations. J. Phys.: Condens. Matter 28, 213001 (2016).\n\n\n\nI. R. Sola, B. Y. Chang, S. A. Malinovskaya and V. S. Malinovsky. Quantum Control in Multilevel Systems. In: Advances In Atomic, Molecular, and Optical Physics, Vol. 67, edited by E. Arimondo, L. F. DiMauro and S. F. Yelin (Academic Press, 2018); Chapter 3, pp. 151–256.\n\n\n\nO. V. Morzhin and A. N. Pechen. Krotov method for optimal control of closed quantum systems. Russ. Math. Surv. 74, 851 (2019).\n\n\n\nF. K. Wilhelm, S. Kirchhoff, S. Machnes, N. Wittler and D. Sugny. An introduction into optimal control for quantum technologies, arXiv:2003.10132 (2020).\n\n\n\nC. P. Koch, U. Boscain, T. Calarco, G. Dirr, S. Filipp, S. J. Glaser, R. Kosloff, S. Montangero, T. Schulte-Herbrüggen, D. Sugny and F. K. Wilhelm. Quantum optimal control in quantum technologies. Strategic report on current status, visions and goals for research in Europe. EPJ Quantum Technol. 9, 19 (2022).\n\n\n\nV. F. Krotov. Global Methods in Optimal Control (Dekker, New York, NY, USA, 1996).\n\n\n\nJ. Somlói, V. A. Kazakov and D. J. Tannor. Controlled dissociation of I_2 via optical transitions between the X and B electronic states. Chem. Phys. 172, 85 (1993).\n\n\n\nA. Bartana, R. Kosloff and D. J. Tannor. Laser cooling of internal degrees of freedom. II. J. Chem. Phys. 106, 1435 (1997).\n\n\n\nJ. P. Palao and R. Kosloff. Optimal control theory for unitary transformations. Phys. Rev. A 68, 062308 (2003).\n\n\n\nD. M. Reich, M. Ndong and C. P. Koch. Monotonically convergent optimization in quantum control using Krotov's method. J. Chem. Phys. 136, 104103 (2012).\n\n\n\nM. H. Goerz, D. Basilewitsch, F. Gago-Encinas, M. G. Krauss, K. P. Horn, D. M. Reich and C. P. Koch. Krotov: A Python implementation of Krotov's method for quantum optimal control. SciPost Phys. 7, 080 (2019).\n\n\n\nN. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbrüggen and S. J. Glaser. Optimal control of coupled spin dynamics: design of NMR pulse sequences by gradient ascent algorithms. J. Magnet. Res. 172, 296 (2005).\n\n\n\nP. de Fouquières, S. G. Schirmer, S. J. Glaser and I. Kuprov. Second order gradient ascent pulse engineering. J. Magnet. Res. 212, 412 (2011).\n\n\n\nI. Kuprov and C. T. Rodgers. Derivatives of spin dynamics simulations. J. Chem. Phys. 131, 234108 (2009).\n\n\n\nM. H. Goerz, D. M. Reich and C. P. Koch. Optimal control theory for a unitary operation under dissipative evolution. New J. Phys. 16, 055012 (2014).\n\n\n\nM. H. Goerz, S. C. Carrasco and V. S. Malinovsky. Quantum Optimal Control via Semi-Automatic Differentiation. Quantum 6, 871 (2022).\n\n\n\nS. Machnes, E. Assémat, D. Tannor and F. K. Wilhelm. Tunable, Flexible, and Efficient Optimization of Control Pulses for Practical Qubits. Phys. Rev. Lett. 120, 150401 (2018).\n\n\n\nT. Caneva, T. Calarco and S. Montangero. Chopped random-basis quantum optimization. Phys. Rev. A 84, 022326 (2011).\n\n\n\n","category":"page"},{"location":"api_externals/#Krotov.KrotovResult","page":"Externals","title":"Krotov.KrotovResult","text":"Result object returned by optimize_krotov.\n\nAttributes\n\nThe attributes of a KrotovResult object include\n\niter:  The number of the current iteration\nJ_T: The value of the final-time functional in the current iteration\nJ_T_prev: The value of the final-time functional in the previous iteration\ntlist: The time grid on which the control are discretized.\nguess_controls: A vector of the original control fields (each field discretized to the points of tlist)\noptimized_controls: A vector of the optimized control fields. Calculated only at the end of the optimization, not after each iteration.\ntau_vals: For any trajectory that defines a target_state, the complex overlap of that target state with the propagated state. For any trajectory for which the target_state is nothing, the value is zero.\nrecords: A vector of tuples with values returned by a callback routine passed to optimize\nconverged: A boolean flag on whether the optimization is converged. This may be set to true by a check_convergence function.\nmessage: A message string to explain the reason for convergence. This may be set by a check_convergence function.\n\nAll of the above attributes may be referenced in a check_convergence function passed to optimize(problem; method=Krotov)\n\n\n\n\n\n","category":"type"},{"location":"api_externals/#Krotov.KrotovWrk","page":"Externals","title":"Krotov.KrotovWrk","text":"Krotov workspace.\n\nThe workspace is for internal use. However, it is also accessible in a callback function. The callback may use or modify some of the following attributes:\n\ntrajectories: a copy of the trajectories defining the control problem\nadjoint_trajectories: The trajectories with the adjoint generator\nkwargs: The keyword arguments from the ControlProblem or the call to optimize.\ncontrols: A tuple of the original controls (probably functions)\nga_a_int: The current value of gₐ(t)dt for each control\nupdate_shapes: The update shapes S(t) for each pulse, discretized on the intervals of the time grid.\nlambda_vals: The current value of λₐ for each control\nresult: The current result object\nfw_storage: The storage of states for the forward propagation\nfw_propagators: The propagators used for the forward propagation\nbw_propagators: The propagators used for the backward propagation\nuse_threads: Flag indicating whether the propagations are performed in parallel.\n\n\n\n\n\n","category":"type"},{"location":"api_externals/#Krotov.optimize_krotov-Tuple{Any}","page":"Externals","title":"Krotov.optimize_krotov","text":"See optimize(problem; method=Krotov, kwargs...).\n\n\n\n\n\n","category":"method"},{"location":"api_externals/#QuantumControl.optimize-Tuple{Any, Val{:Krotov}}","page":"Externals","title":"QuantumControl.optimize","text":"using Krotov\nresult = optimize(problem; method=Krotov, kwargs...)\n\noptimizes the given control problem using Krotov's method, by minimizing the functional\n\nJ(ϵ_l(t)) =\n    J_T(Ψ_k(T))\n    + _l int_0^T fracλ_alS_l(t) ϵ_l(t) - ϵ_l^(0)(t)^2  dt\n\ncf. the general form of a quantum control functional. The \"reference field\" ϵ_l^(0)(t) is the guess control for that particular iteration. The above functional implies a first-order update equation\n\nΔϵ_l(t) = fracS_l(t)λ_al Im _k left\nBiglangle\n    chi_k^(0)(t)\nBigvert\n    fracpartial hatH_kpartial ϵ_l(t)\nBigvert\n    Psi_k(t)\nBigrangle\nright\n\nwhere chi^(0)_k(t) is the state backward-propagated under H_k^dagger(ϵ_l^(0)(t)) with the boundary condition chi_k(T) = partial J_T  partial Ψ_k^(0)(T) and H_k is the generator of the k'th trajectory.\n\nNote that the particular control-dependent running cost in the above functional is required to obtain the given Krotov update equation. Other running costs, or state-dependent running costs are not supported in this implementation of Krotov's method (even though some running costs are mathematically compatible with Krotov's method).\n\nReturns a KrotovResult.\n\nKeyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of problem; any of these can be overridden with explicit keyword arguments to optimize.\n\nRequired problem keyword arguments\n\nJ_T: A function J_T(Ψ, trajectories) that evaluates the final time functional from a list Ψ of forward-propagated states and problem.trajectories. The function J_T may also take a keyword argument tau. If it does, a vector containing the complex overlaps of the target states (target_state property of each trajectory in problem.trajectories) with the propagated states will be passed to J_T.\n\nRecommended problem keyword arguments\n\nlambda_a=1.0: The inverse Krotov step width λₐ for every pulse.\nupdate_shape=(t->1.0): A function S(t) for the \"update shape\" that scales the update for every pulse.\n\nIf different controls require different lambda_a or update_shape, a dict pulse_options must be given instead of a global lambda_a and update_shape; see below.\n\nOptional problem keyword arguments\n\nThe following keyword arguments are supported (with default values):\n\npulse_options: A dictionary that maps every control (as obtained by get_controls from the problem.trajectories) to the following dict:\n:lambda_a:  The value for inverse Krotov step width λₐ.\n:update_shape: A function S(t) for the \"update shape\" that scales the Krotov pulse update.\nThis overrides the global lambda_a and update_shape arguments.\nchi: A function chi(Ψ, trajectories) that receives a list Ψ of the forward propagated states and returns a vector of states χₖ = -J_TΨₖ. If not given, it will be automatically determined from J_T via make_chi with the default parameters. Similarly to J_T, if chi accepts a keyword argument tau, it will be passed a vector of complex overlaps.\nsigma=nothing: A function that calculates the second-order contribution. If not given, the first-order Krotov method is used.\niter_start=0: The initial iteration number.\niter_stop=5000: The maximum iteration number.\nprop_method: The propagation method to use for each trajectory; see below.\nprint_iters=true: Whether to print information after each iteration.\nstore_iter_info=Set(): Which fields from print_iters to store in result.records. A subset of Set([\"iter.\", \"J_T\", \"∫gₐ(t)dt\", \"J\", \"ΔJ_T\", \"ΔJ\", \"secs\"]).\ncallback: A function (or tuple of functions) that receives the Krotov workspace, the iteration number, the list of updated pulses, and the list of guess pulses as positional arguments. The function may return a tuple of values which are stored in the KrotovResult object result.records. The function can also mutate any of its arguments, in particular the updated pulses. This may be used, e.g., to apply a spectral filter to the updated pulses or to perform similar manipulations. Note that print_iters=true (default) adds an automatic callback to print information after each iteration. With store_iter_info, that callback automatically stores a subset of the printed information.\ncheck_convergence: A function to check whether convergence has been reached. Receives a KrotovResult object result, and should set result.converged to true and result.message to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with ∘. The convergence check is performed after any callback.\nverbose=false: If true, print information during initialization.\nrethrow_exceptions: By default, any exception ends the optimization but still returns a KrotovResult that captures the message associated with the exception. This is to avoid losing results from a long-running optimization when an exception occurs in a later iteration. If rethrow_exceptions=true, instead of capturing the exception, it will be thrown normally.\n\nTrajectory propagation\n\nKrotov's method involves the forward and backward propagation for every Trajectory in the problem. The keyword arguments for each propagation (see propagate) are determined from any properties of each Trajectory that have a prop_ prefix, cf. init_prop_trajectory.\n\nIn situations where different parameters are required for the forward and backward propagation, instead of the prop_ prefix, the fw_prop_ and bw_prop_ prefixes can be used, respectively. These override any setting with the prop_ prefix. This applies both to the properties of each Trajectory and the problem keyword arguments.\n\nNote that the propagation method for each propagation must be specified. In most cases, it is sufficient (and recommended) to pass a global prop_method problem keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"api_externals/#GRAPE.GrapeResult","page":"Externals","title":"GRAPE.GrapeResult","text":"Result object returned by optimize_grape.\n\nAttributes\n\nThe attributes of a GrapeResult object include\n\niter:  The number of the current iteration\nJ_T: The value of the final-time functional in the current iteration\nJ_T_prev: The value of the final-time functional in the previous iteration\nJ_a: The value of the running cost J_a in the current iteration (excluding λ_a)\nJ_a_prev: The value of J_a in the previous iteration\ntlist: The time grid on which the control are discetized.\nguess_controls: A vector of the original control fields (each field discretized to the points of tlist)\noptimized_controls: A vector of the optimized control fields in the current iterations\nrecords: A vector of tuples with values returned by a callback routine passed to optimize\nconverged: A boolean flag on whether the optimization is converged. This may be set to true by a check_convergence function.\nmessage: A message string to explain the reason for convergence. This may be set by a check_convergence function.\n\nAll of the above attributes may be referenced in a check_convergence function passed to optimize(problem; method=GRAPE)\n\n\n\n\n\n","category":"type"},{"location":"api_externals/#GRAPE.GrapeWrk","page":"Externals","title":"GRAPE.GrapeWrk","text":"GRAPE Workspace.\n\nThe workspace is for internal use. However, it is also accessible in a callback function. The callback may use or modify some of the following attributes:\n\ntrajectories: a copy of the trajectories defining the control problem\nadjoint_trajectories: The trajectories with the adjoint generator\nkwargs: The keyword arguments from the ControlProblem or the call to optimize.\ncontrols: A tuple of the original controls (probably functions)\npulsevals_guess: The combined vector of pulse values that are the guess in the current iteration. Initially, the vector is the concatenation of discretizing controls to the midpoints of the time grid.\npulsevals: The combined vector of updated pulse values in the current iteration. All the initialized propagators inside the workspace alias pulsevals such that mutating pulsevals is directly reflected in the next propagation step.\ngradient: The total gradient for the guess in the current iteration\ngrad_J_T: The current  gradient for the final-time part of the functional. This is from the last evaluation of the gradient, which may be for the optimized pulse (depending on the internal of the optimizer)\ngrad_J_a: The current  gradient for the running cost part of the functional.\nJ_parts: The two-component vector J_T J_a\nresult: The current result object\nupper_bounds: Upper bound for every pulsevals; +Inf indicates no bound.\nlower_bounds: Lower bound for every pulsevals; -Inf indicates no bound.\nfg_count: A two-element vector containing the number of evaluations of the combined gradient and functional first, and the evaluations of only the functional second.\noptimizer: The backend optimizer object\noptimizer_state: The internal state object of the optimizer (nothing if the optimizer has no internal state)\nresult: The current result object\ntau_grads: The gradients ∂τₖ/ϵₗ(tₙ)\nfw_storage: The storage of states for the forward propagation, as a vector of storage contains (one for each trajectory)\nfw_propagators: The propagators used for the forward propagation\nbw_grad_propagators: The propagators used for the backward propagation of QuantumGradientGenerators.GradVector states (gradient_method=:gradgen only)\nbw_propagators: The propagators used for the backward propagation (gradient_method=:taylor only)\nuse_threads: Flag indicating whether the propagations are performed in parallel.\n\nIn addition, the following methods provide safer (non-mutating) access to information in the workspace\n\nstep_width\nsearch_direction\nnorm_search\ngradient\npulse_update\n\n\n\n\n\n","category":"type"},{"location":"api_externals/#GRAPE.evaluate_functional-Tuple{Any, Any, Any}","page":"Externals","title":"GRAPE.evaluate_functional","text":"Evaluate the optimization functional in problem for the given pulsevals.\n\nJ = evaluate_functional(pulsevals, problem, wrk; storage=nothing, count_call=true)\n\nevaluates the functional defined in problem, for the given pulse values, using wrk.fw_propagators, where wrk is the GRAPE workspace initialized from problem. The pulsevals is a vector of Float64 values corresponding to a concatenation of all the controls in problem, discretized to the midpoints of the time grid, cf. GrapeWrk.\n\nAs a side effect, the evaluation sets the following information in wrk:\n\nwrk.pulsevals: On output, the values of the given pulsevals. Note that pulsevals may alias wrk.pulsevals, so there is no assumption made on wrk.pulsevals other than that mutating wrk.pulsevals directly affects the propagators in wrk.\nwrk.result.f_calls: Will be incremented by one (only if count_call=true)\nwrk.fg_count[2]: Will be incremented by one (only if count_call=true)\nwrk.result.tau_vals: For any trajectory that defines a target_state, the overlap of the propagated state with that target state.\nwrk.J_parts: The parts (J_T, λₐJ_a) of the functional\n\nIf storage is given, as a vector of storage containers suitable for propagate (one for each trajectory), the forward-propagated states     will be stored there.\n\nReturns J as sum(wrk.J_parts).\n\n\n\n\n\n","category":"method"},{"location":"api_externals/#GRAPE.evaluate_gradient!-NTuple{4, Any}","page":"Externals","title":"GRAPE.evaluate_gradient!","text":"Evaluate the gradient Jϵₙₗ into G, together with the functional J.\n\nJ = evaluate_gradient!(G, pulsevals, problem, wrk)\n\nevaluates and returns the optimization functional defined in problem for the given pulse values, cf. evaluate_functional, and write the derivative of the optimization functional with respect to the pulse values into the existing array G.\n\nThe evaluation of the functional uses uses wrk.fw_propagators. The evaluation of the gradient happens either via a backward propagation of an extended \"gradient vector\" using wrk.bw_grad_propagators if problem was initialized with gradient_method=:gradgen. Alternatively, if problem was initialized with gradient_method=:taylor, the backward propagation if for a regular state, using wrk.bw_propagators, and a Taylor expansion is used for the gradient of the time evolution operator in a single time step.\n\nAs a side, effect, evaluating the gradient and functional sets the following information in wrk:\n\nwrk.pulsevals: On output, the values of the given pulsevals, see evaluate_functional.\nwrk.result.fg_calls: Will be incremented by one\nwrk.fg_count[1]: Will be incremented by one\nwrk.result.tau_vals: For any trajectory that defines a target_state, the overlap of the propagated state with that target state.\nwrk.J_parts: The parts (J_T, λₐJ_a) of the functional\nwrk.fw_storage: For each trajectory, the forward-propagated states at each point on the time grid.\nwrk.chi_states: The normalized states χ(T) that we used as the boundary condition for the backward propagation.\nwrk.chi_states_norm: The original norm of the states χ(T), as calculated by -JΨₖ\nwrk.grad_J_T: The vector ``∂JT/∂ϵ{nl}, i.e., the gradient only for the final-time part of the functional\nwrk.grad_J_a: The vector J_aϵ_nl, i.e., the gradient only for the pulse-dependent running cost.\n\nThe gradients are wrk.grad_J_T and wrk.grad_J_a (weighted by λ_a) into are combined into the output G.\n\nReturns the value of the functional.\n\n\n\n\n\n","category":"method"},{"location":"api_externals/#GRAPE.gradient-Tuple{Any}","page":"Externals","title":"GRAPE.gradient","text":"The gradient in the current iteration.\n\ng = gradient(wrk; which=:initial)\n\nreturns the gradient associated with the guess pulse of the current iteration. Up to quasi-Newton corrections, the negative gradient determines the search_direction for the pulse_update.\n\ng = gradient(wrk; which=:final)\n\nreturns the gradient associated with the optimized pulse of the current iteration.\n\n\n\n\n\n","category":"method"},{"location":"api_externals/#GRAPE.make_grape_print_iters-Tuple{}","page":"Externals","title":"GRAPE.make_grape_print_iters","text":"Print optimization progress as a table.\n\nThis functions serves as the default info_hook for an optimization with GRAPE.\n\n\n\n\n\n","category":"method"},{"location":"api_externals/#GRAPE.norm_search-Tuple{Any}","page":"Externals","title":"GRAPE.norm_search","text":"The norm of the search direction vector in the current iteration.\n\nnorm_search(wrk)\n\nreturns norm(search_direction(wrk)).\n\n\n\n\n\n","category":"method"},{"location":"api_externals/#GRAPE.optimize_grape-Tuple{Any}","page":"Externals","title":"GRAPE.optimize_grape","text":"See optimize(problem; method=GRAPE, kwargs...).\n\n\n\n\n\n","category":"method"},{"location":"api_externals/#GRAPE.pulse_update-Tuple{Any}","page":"Externals","title":"GRAPE.pulse_update","text":"The vector of pulse update values for the current iteration.\n\nΔu = pulse_update(wrk)\n\nreturns a vector containing the different between the optimized pulse values and the guess pulse values of the current iteration. This should be proportional to search_direction with the proportionality factor step_width.\n\n\n\n\n\n","category":"method"},{"location":"api_externals/#GRAPE.search_direction-Tuple{Any}","page":"Externals","title":"GRAPE.search_direction","text":"The search direction used in the current iteration.\n\ns = search_direction(wrk)\n\nreturns the vector describing the search direction used in the current iteration. This should be proportional to pulse_update with the proportionality factor step_width.\n\n\n\n\n\n","category":"method"},{"location":"api_externals/#GRAPE.step_width-Tuple{Any}","page":"Externals","title":"GRAPE.step_width","text":"The step width used in the current iteration.\n\nα = step_width(wrk)\n\nreturns the scalar α so that pulse_update(wrk) = α * search_direction(wrk), see pulse_update and search_direction for the iteration described by the current GrapeWrk (for the state of wrk as available in the callback of the current iteration.\n\n\n\n\n\n","category":"method"},{"location":"api_externals/#GRAPE.vec_angle-Union{Tuple{P}, Tuple{T}, Tuple{N}, Tuple{P, P}} where {N, T, P<:Union{AbstractVector{T}, NTuple{N, T}}}","page":"Externals","title":"GRAPE.vec_angle","text":"The angle between two vectors.\n\nϕ = vec_angle(v1, v2; unit=:rad)\n\nreturns the angle between two vectors in radians (or degrees, with unit=:degree).\n\n\n\n\n\n","category":"method"},{"location":"api_externals/#QuantumControl.optimize-Tuple{Any, Val{:GRAPE}}","page":"Externals","title":"QuantumControl.optimize","text":"using GRAPE\nresult = optimize(problem; method=GRAPE, kwargs...)\n\noptimizes the given control problem via the GRAPE method, by minimizing the functional\n\nJ(ϵ_nl) = J_T(ϕ_k(T)) + λ_a J_a(ϵ_nl)\n\nwhere the final time functional J_T depends explicitly on the forward-propagated states and the running cost J_a depends explicitly on pulse values ϵ_nl of the l'th control discretized on the n'th interval of the time grid.\n\nReturns a GrapeResult.\n\nKeyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of problem; any of these can be overridden with explicit keyword arguments to optimize.\n\nRequired problem keyword arguments\n\nJ_T: A function J_T(Ψ, trajectories) that evaluates the final time functional from a list Ψ of forward-propagated states and problem.trajectories. The function J_T may also take a keyword argument tau. If it does, a vector containing the complex overlaps of the target states (target_state property of each trajectory in problem.trajectories) with the propagated states will be passed to J_T.\n\nOptional problem keyword arguments\n\nchi: A function chi(Ψ, trajectories) that receives a list Ψ of the forward propagated states and returns a vector of states χₖ = -J_TΨₖ. If not given, it will be automatically determined from J_T via QuantumControl.Functionals.make_chi with the default parameters. Similarly to J_T, if chi accepts a keyword argument tau, it will be passed a vector of complex overlaps.\nchi_min_norm=1e-100: The minimum allowable norm for any χₖ(T). Smaller norms would mean that the gradient is zero, and will abort the optimization with an error.\nJ_a: A function J_a(pulsevals, tlist) that evaluates running costs over the pulse values, where pulsevals are the vectorized values ϵ_nl, where n are in indices of the time intervals and l are the indices over the controls, i.e., [ϵ₁₁, ϵ₂₁, …, ϵ₁₂, ϵ₂₂, …] (the pulse values for each control are contiguous). If not given, the optimization will not include a running cost.\ngradient_method=:gradgen: One of :gradgen (default) or :taylor. With gradient_method=:gradgen, the gradient is calculated using QuantumGradientGenerators. With gradient_method=:taylor, it is evaluated via a Taylor series, see Eq. (20) in Kuprov and Rogers,  J. Chem. Phys. 131, 234108 (2009) [17].\ntaylor_grad_max_order=100: If given with gradient_method=:taylor, the maximum number of terms in the Taylor series. If taylor_grad_check_convergence=true (default), if the Taylor series does not convergence within the given number of terms, throw an an error. With taylor_grad_check_convergence=true, this is the exact order of the Taylor series.\ntaylor_grad_tolerance=1e-16: If given with gradient_method=:taylor and taylor_grad_check_convergence=true, stop the Taylor series when the norm of the term falls below the given tolerance. Ignored if taylor_grad_check_convergence=false.\ntaylor_grad_check_convergence=true: If given as true (default), check the convergence after each term in the Taylor series an stop as soon as the norm of the term drops below the given number. If false, stop after exactly taylor_grad_max_order terms.\nlambda_a=1: A weight for the running cost J_a.\ngrad_J_a: A function to calculate the gradient of J_a. If not given, it will be automatically determined. See make_grad_J_a for the required interface.\nupper_bound: An upper bound for the value of any optimized control. Time-dependent upper bounds can be specified via pulse_options.\nlower_bound: A lower bound for the value of any optimized control. Time-dependent lower bounds can be specified via pulse_options.\npulse_options: A dictionary that maps every control (as obtained by get_controls from the problem.trajectories) to a dict with the following possible keys:\n:upper_bounds: A vector of upper bound values, one for each intervals of the time grid. Values of Inf indicate an unconstrained upper bound for that time interval, respectively the global upper_bound, if given.\n:lower_bounds: A vector of lower bound values. Values of -Inf indicate an unconstrained lower bound for that time interval,\nprint_iters=true: Whether to print information after each iteration.\nprint_iter_info=[\"iter.\", \"J_T\", \"|∇J|\", \"|Δϵ|\", \"ΔJ\", \"FG(F)\", \"secs\"]: Which fields to print if print_iters=true. If given, must be a list of header labels (strings), which can be any of the following:\n\"iter.\": The iteration number\n\"J_T\": The value of the final-time functional for the dynamics under the optimized pulses\n\"J_a\": The value of the pulse-dependent running cost for the optimized pulses\n\"λ_a⋅J_a\": The total contribution of J_a to the full functional J\n\"J\": The value of the optimization functional for the optimized pulses\n\"ǁ∇J_Tǁ\": The ℓ²-norm of the current gradient of the final-time functional. Note that this is usually the gradient of the optimize pulse, not the guess pulse.\n\"ǁ∇J_aǁ\": The ℓ²-norm of the the current gradient of the pulse-dependent running cost. For comparison with \"ǁ∇J_Tǁ\".\n\"λ_aǁ∇J_aǁ\": The ℓ²-norm of the the current gradient of the complete pulse-dependent running cost term. For comparison with \"ǁ∇J_Tǁ\".\n\"ǁ∇Jǁ\": The norm of the guess pulse gradient. Note that the guess pulse gradient is not the same the current gradient.\n\"ǁΔϵǁ\":  The ℓ²-norm of the pulse update\n\"ǁϵǁ\": The ℓ²-norm of optimized pulse values\n\"max|Δϵ|\" The maximum value of the pulse update (infinity norm)\n\"max|ϵ|\": The maximum value of the pulse values (infinity norm)\n\"ǁΔϵǁ/ǁϵǁ\": The ratio of the pulse update tothe optimized pulse values\n\"∫Δϵ²dt\": The L²-norm of the pulse update, summed over all pulses. A convergence measure comparable (proportional) to the running cost in Krotov's method\n\"ǁsǁ\": The norm of the search direction. Should be ǁΔϵǁ scaled by the step with α.\n\"∠°\": The angle (in degrees) between the negative gradient -∇J and the search direction s.\n\"α\": The step width as determined by the line search (Δϵ = α⋅s)\n\"ΔJ_T\": The change in the final time functional relative to the previous iteration\n\"ΔJ_a\":  The change in the control-dependent running cost relative to the previous iteration\n\"λ_a⋅ΔJ_a\": The change in the control-dependent running cost term relative to the previous iteration.\n\"ΔJ\":  The change in the total optimization functional relative to the previous iteration.\n\"FG(F)\":  The number of functional/gradient evaluation (FG), or pure functional (F) evaluations\n\"secs\":  The number of seconds of wallclock time spent on the iteration.\nstore_iter_info=[]: Which fields to store in result.records, given as\na list of header labels, see print_iter_info.\ncallback: A function (or tuple of functions) that receives the GRAPE workspace and the iteration number. The function may return a tuple of values which are stored in the GrapeResult object result.records. The function can also mutate the workspace, in particular the updated pulsevals. This may be used, e.g., to apply a spectral filter to the updated pulses or to perform similar manipulations. Note that print_iters=true (default) adds an automatic callback to print information after each iteration. With store_iter_info, that callback automatically stores a subset of the available information.\ncheck_convergence: A function to check whether convergence has been reached. Receives a GrapeResult object result, and should set result.converged to true and result.message to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with ∘. The convergence check is performed after any callback.\nx_tol: Parameter for Optim.jl\nf_tol: Parameter for Optim.jl\ng_tol: Parameter for Optim.jl\nshow_trace: Parameter for Optim.jl\nextended_trace:  Parameter for Optim.jl\nshow_every: Parameter for Optim.jl\nallow_f_increases: Parameter for Optim.jl\noptimizer: An optional Optim.jl optimizer (Optim.AbstractOptimizer instance). If not given, an L-BFGS-B optimizer will be used.\nprop_method: The propagation method to use for each trajectory, see below.\nverbose=false: If true, print information during initialization\nrethrow_exceptions: By default, any exception ends the optimization, but still returns a GrapeResult that captures the message associated with the exception. This is to avoid losing results from a long-running optimization when an exception occurs in a later iteration. If rethrow_exceptions=true, instead of capturing the exception, it will be thrown normally.\n\nTrajectory propagation\n\nGRAPE may involve three types of propagation:\n\nA forward propagation for every Trajectory in the problem\nA backward propagation for every trajectory\nA backward propagation of a gradient generator for every trajectory.\n\nThe keyword arguments for each propagation (see propagate) are determined from any properties of each Trajectory that have a prop_ prefix, cf. init_prop_trajectory.\n\nIn situations where different parameters are required for the forward and backward propagation, instead of the prop_ prefix, the fw_prop_ and bw_prop_ prefix can be used, respectively. These override any setting with the prop_ prefix. Similarly, properties for the backward propagation of the gradient generators can be set with properties that have a grad_prop_ prefix. These prefixes apply both to the properties of each Trajectory and the problem keyword arguments.\n\nNote that the propagation method for each propagation must be specified. In most cases, it is sufficient (and recommended) to pass a global prop_method problem keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"howto/#howto","page":"How-to Guides","title":"How-to Guides","text":"","category":"section"},{"location":"howto/","page":"How-to Guides","title":"How-to Guides","text":"Contents","category":"page"},{"location":"howto/","page":"How-to Guides","title":"How-to Guides","text":"Pages=[\n \"howto.md\"\n]\nDepth = 2:2","category":"page"},{"location":"howto/","page":"How-to Guides","title":"How-to Guides","text":"Also see the following how-to guides from the QuantumPropagators documentation:","category":"page"},{"location":"howto/","page":"How-to Guides","title":"How-to Guides","text":"using Markdown\nusing DocInventories\n\ninventory = Inventory(\"https://juliaquantumcontrol.github.io/QuantumPropagators.jl/stable/objects.inv\")\n\nhowtos = [item for item in inventory if item.role == \"label\" && startswith(item.uri, \"howto\") && item.name != \"Howtos\"]\n\nlines = [\"* [$(DocInventories.dispname(item))]($(DocInventories.uri(inventory, DocInventories.spec(item))))\" for item in howtos]\n\nMarkdown.parse(join(lines, \"\\n\"))","category":"page"},{"location":"howto/#How-to-deal-with-long-running-calculations","page":"How-to Guides","title":"How to deal with long-running calculations","text":"","category":"section"},{"location":"howto/","page":"How-to Guides","title":"How-to Guides","text":"For any calculation that runs for more than a couple of minutes, use the QuantumControl.run_or_load function. A particular case of a long-running calculation is a call to QuantumControl.optimize for a system of non-trivial size. For optimizations in particular, there is QuantumControl.@optimize_or_load that uses run_or_load around optimize, and stores the optimization result together with the (truncated) output from the optimization.","category":"page"},{"location":"howto/","page":"How-to Guides","title":"How-to Guides","text":"As an alternative to QuantumControl.run_or_load, you might also consider the use of the DrWatson package, which provides DrWatson.produce_or_load. It has a slightly more opinionated approach to saving and uses automatic file names based on parameters in a config data structure. In contrast, QuantumControl.run_or_load gives more control over the filename and does not force you to organize parameters in a config.","category":"page"},{"location":"api/quantum_propagators/#QuantumPropagatorsPackage","page":"QuantumPropagators","title":"QuantumPropagators Package","text":"","category":"section"},{"location":"api/quantum_propagators/#Package-Index","page":"QuantumPropagators","title":"Package Index","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"gdeftgttexttgt gdeftroperatornametr gdefReoperatornameRe gdefImoperatornameIm","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Pages   = [\"quantum_propagators.md\"]","category":"page"},{"location":"api/quantum_propagators/#QuantumPropagatorsAPI","page":"QuantumPropagators","title":"QuantumPropagators","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Public Symbols:","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Propagation\ninit_prop\nprop_step!\npropagate\npropagate_sequence\nreinit_prop!","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Private Symbols:","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"ExpPropagator\ndisable_timings\ncheby_get_spectral_envelope\nset_t!\nPiecewisePropagator\nChebyPropagator\nAbstractPropagator\nPWCPropagator\node_function\nset_state!\nenable_timings\nNewtonPropagator\ntimings_enabled","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Submodules:","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"QuantumPropagators.Amplitudes\nQuantumPropagators.Arnoldi\nQuantumPropagators.Cheby\nQuantumPropagators.Controls\nQuantumPropagators.ExpProp\nQuantumPropagators.Generators\nQuantumPropagators.Interfaces\nQuantumPropagators.Newton\nQuantumPropagators.Shapes\nQuantumPropagators.SpectralRange\nQuantumPropagators.Storage","category":"page"},{"location":"api/quantum_propagators/#Reference","page":"QuantumPropagators","title":"Reference","text":"","category":"section"},{"location":"api/quantum_propagators/#QuantumPropagators.Propagation","page":"QuantumPropagators","title":"QuantumPropagators.Propagation","text":"Wrapper around the parameters of a call to propagate.\n\nPropagation(\n    generator, tlist;\n    pre_propagation=nothing, post_propagation=nothing,\n    kwargs...\n)\n\nPropagation(\n    propagator;\n    pre_propagation=nothing, post_propagation=nothing,\n    kwargs...\n)\n\nis a wrapper around the arguments for propagate / init_prop, for use within propagate_sequence.\n\nThe positional and keyword arguments are those accepted by the above propagation routines, excluding the initial state. A Propagation may in addition include the pre_propagation and post_propagation keyword arguments recognized by propagate_sequence.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.init_prop","page":"QuantumPropagators","title":"QuantumPropagators.init_prop","text":"Initialize a Propagator.\n\npropagator = init_prop(\n    state, generator, tlist;\n    method,  # mandatory keyword argument\n    backward=false,\n    inplace=QuantumPropagators.Interfaces.supports_inplace(state),\n    piecewise=nothing,\n    pwc=nothing,\n    kwargs...\n)\n\ninitializes a propagator for the time propagation of the given state over a time grid tlist under the time-dependent generator (Hamiltonian/Liouvillian) generator.\n\nArguments\n\nstate: The \"initial\" state for the propagation. For backward=false, this state is taken to be at initial time (tlist[begin]); and for backward=true, at the final time (tlist[end])\ngenerator: The time-dependent generator of the dynamics\ntlist: The time grid over which which the propagation is defined. This may or may not be equidistant.\n\nMandatory keyword arguments\n\nmethod: The propagation method to use. May be given as a name (Symbol), but the recommended usage is to pass a module implementing the propagation method, e.g., using QuantumPropagators: Cheby; method = Cheby. Passing a module ensures that the code implementing the method is correctly loaded. This is particularly important for propagators using third-party backends, like with method=OrdinaryDiffEq.\n\nOptional keyword arguments\n\nbackward: If true, initialize the propagator for a backward propagation. The resulting propagator.t will be tlist[end], and subsequent calls to prop_step! will move backward on tlist.\ninplace: If true, the state property of the resulting propagator will be changed in-place by any call to prop_step!. If false, each call to prop_step! changes the reference for propagator.state, and the propagation will not use any in-place operations. Not all propagation methods may support both in-place and not-in-place propagation. In-place propagation is generally more efficient for larger Hilbert space dimensions, but may not be compatible, e.g., with automatic differentiation.\npiecewise: If given as a boolean, true enforces that the resulting propagator is a PiecewisePropagator, and false enforces that it not a PiecewisePropagator. For the default piecewise=nothing, whatever type of propagation is the default for the given method will be used. Throw an error if the given method does not support the required type of propagation.\npwc: Like piecewise, but for the stronger PWCPropagator.\n\nAll other kwargs are method-dependent and are ignored for methods that do not support them.\n\nThe type of the returned propagator is a sub-type of AbstractPropagator, respectively a sub-type of PiecewisePropagator if piecewise=true or a sub-type of PWCPropagator if pwc=true.\n\nInternals\n\nInternally, the (mandatory) keyword method is converted into a fourth positional argument. This allows propagation methods to define their own implementation of init_prop via multiple dispatch. However, when calling init_prop in high-level code, method must always be given as a keyword argument.\n\nSee also\n\nreinit_prop! — Re-initialize a propagator\npropagate — Higher-level propagation interface\n`check_propagator — a function to verify the interface described above.\n\n\n\n\n\nusing QuantumPropagators: Cheby\n\ncheby_propagator = init_prop(\n    state,\n    generator,\n    tlist;\n    method=Cheby,\n    inplace=QuantumPropagators.Interfaces.supports_inplace(state),\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    control_ranges=nothing,\n    specrange_method=:auto,\n    specrange_buffer=0.01,\n    cheby_coeffs_limit=1e-12,\n    check_normalization=false,\n    specrange_kwargs...\n)\n\ninitializes a ChebyPropagator.\n\nMethod-specific keyword arguments\n\ncontrol_ranges: a dict the maps the controls in generator (see get_controls) to a tuple of min/max values. The Chebychev coefficients will be calculated based on a spectral envelope that assumes that each control can take arbitrary values within the min/max range. If not given, the ranges are determined automatically. Specifying manual control ranges can be useful when the the control amplitudes (parameters) may change during the propagation, e.g. in a sequential-update control scheme.\nspecrange_method: Method to pass to the specrange function\nspecrange_buffer: An additional factor by which to enlarge the estimated  spectral range returned by specrange, in order to ensure that Chebychev coefficients are based on an overestimation of the spectral range.\ncheby_coeffs_limit: The maximum magnitude of Chebychev coefficients that should be treated as non-zero\ncheck_normalization: Check whether the Hamiltonian has been properly normalized, i.e., that the spectral range of generator has not been underestimated. This slowes down the propagation, but is advisable for novel generators.\nuniform_dt_tolerance=1e-12: How much the intervals of tlist are allowed to vary while still being considered constant.\nspecrange_kwargs: All further keyword arguments are passed to the specrange function. Most notably, with the default specrange_method=:auto (or specrange_method=:manual), passing E_min and E_max allows to manually specify the spectral range of generator.\n\n\n\n\n\nusing QuantumPropagators: Newton\n\nnewton_propagator = init_prop(\n    state,\n    generator,\n    tlist;\n    method=Newton,\n    inplace=QuantumPropagators.Interfaces.supports_inplace(state),\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    m_max=10,\n    func=(z -> exp(-1im * z)),\n    norm_min=1e-14,\n    relerr=1e-12,\n    max_restarts=50,\n    _...\n)\n\ninitializes a NewtonPropagator.\n\nMethod-specific keyword arguments\n\nm_max: maximum Krylov dimension, cf. NewtonWrk\nfunc, norm_min, relerr, max_restarts: parameter to pass to newton!\n\n\n\n\n\nusing QuantumPropagators: ExpProp\n\nexp_propagator = init_prop(\n    state,\n    generator,\n    tlist;\n    method=ExpProp,\n    inplace=QuantumPropagators.Interfaces.supports_inplace(state),\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    func=(H_dt -> exp(-1im * H_dt))\n    convert_state=_exp_prop_convert_state(state),\n    convert_operator=_exp_prop_convert_operator(generator),\n    _...\n)\n\ninitializes an ExpPropagator.\n\nMethod-specific keyword arguments\n\nfunc: The function to evaluate. The argument H_dt is obtained by constructing an operator H from generator via the evaluate function and the multiplied with the time step dt for the current time interval. The propagation then simply multiplies the return value of func with the current state\nconvert_state:  Type to which to temporarily convert states before multiplying the return value of func.\nconvert_operator: Type to which to convert the operator H before multiplying it with dt and plugging the result into func\n\nThe convert_state and convert_operator parameters are useful for when the generator and or state are unusual data structures for which the relevant methods to calculate func are not defined. Often, it is easier to temporarily convert them to standard complex matrices and vectors than to implement the missing methods.\n\n\n\n\n\nusing OrdinaryDiffEq  # or: `using DifferentialEquations`\n\node_propagator = init_prop(\n    state,\n    generator,\n    tlist;\n    method=OrdinaryDiffEq,  # or: `method=DifferentialEquations`\n    inplace=QuantumPropagators.Interfaces.supports_inplace(state),\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    piecewise=false,\n    pwc=false,\n    alg=OrdinaryDiffEq.Tsit5(),\n    solver_options...\n)\n\ninitializes a propagator that uses an ODE solver from the OrdinaryDiffEq.jl package as a backend.\n\nBy default, the resulting propagator is for time-continuous controls that can be evaluated with evaluate(control, t) for any t in the range of tlist[begin] to tlist[end]. The controls may be parametrized, see get_parameters. Any parameters will be available in the parameters attribute of the resulting ode_propagator, as a dictionary mapping controls to a vector of parameter values. Mutating ode_propagator.parameters[control] will be reflected in any subsequent call to prop_step!.\n\nIf pwc=true (or, equivalently piecewise=true), all controls will be discretized with discretize_on_midpoints and the propagation will be for piecewise constant dynamics. The resulting ode_propagator will be an instance of PWCPropagator, with the corresponding semantics. In particular, the ode_propatator.parameters will be a mapping of controls to discretized pulse values, not the analytical parameters obtained with get_parameters(control) as in the default case.\n\nInternally, the generator will be wrapped with QuantumPropagators.ode_function. The resulting function f will be called internally as f(ϕ, Ψ, vals_dict, t) or f(Ψ, vals_dict, t) depending on the inplace keyword argument.\n\nMethod-specific keyword arguments\n\npwc: Whether to propagate for piecewise-constant controls or, with the default pwc=false, for time-continuous controls.\npiecewise: Currently equivalent to pwc, but future version may change  this to allow for other piecewise (e.g., piecewise-linear) controls.\nparameters: If given, a mapping of controls to parameter values (pwc=false) or pulse values on the intervals of the time grid (pwc=true). By default, the parameters are determined automatically using get_parameters, respectively discretize_on_midpoints if pwc=true. If they are given manually, they must follow the exact same semantics. In particular, for pwc=false, any parameters must alias the parameters in the controls, such that mutating parameters is automatically reflected in evaluate. The parameters will be available as an attribute of the ode_propagator.\nalg: The algorithm to use for the ODE Solver, see the list of solvers in the DifferentialEquations manual. The default Tsit5() method is the recommended choice for non-stiff problems.\nsolver_options: All other keyword arguments are passed to the ODE solver, see the list of Solve Keyword Arguments in the DifferentialEquations manual. Note that the options for \"Default Algorithm Hinting\" do not apply, since alg must be specified manually. Also, the \"Output Control\" is managed by the ode_propagator, so these options should not be used.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.prop_step!","page":"QuantumPropagators","title":"QuantumPropagators.prop_step!","text":"Advance the propagator by a single time step.\n\nstate = prop_step!(propagator)\n\nreturns the state obtained from propagating to the next point on the time grid from propagator.t, respectively the previous point if propagator.backward is true.\n\nWhen the propagation would lead out of the time grid, prop_step! leaves propagator unchanged and returns nothing. Thus, a return value of nothing may be used to signal that a propagation has completed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.propagate","page":"QuantumPropagators","title":"QuantumPropagators.propagate","text":"Propagate a state over an entire time grid.\n\nstate = propagate(\n    state,\n    generator,\n    tlist;\n    method,  # mandatory keyword argument\n    check=true,\n    backward=false,\n    inplace=QuantumPropagators.Interfaces.supports_inplace(state),\n    verbose=false,\n    piecewise=nothing,\n    pwc=nothing,\n    storage=nothing,\n    observables=<store state>,\n    callback=nothing,\n    show_progress=false,\n    init_prop_kwargs...)\n\npropagates state of the entire time grid and returns the propagated states, or a storage array of data collected during the propagation. This high-level routine performs the following three steps:\n\nIf check=true (default), check that state, generator, and tlist are  consistent with the required interface.\nInitialize a propagator via init_prop:\ninit_prop(state, generator, tlist; method, inplace, init_prop_kwargs...)\nCall and return the result of\npropagate(propagator; storage, observables, show_progress, callback)\n\nArguments\n\nstate: The \"initial\" state for the propagation. For backward=false, this state is taken to be at initial time (tlist[begin]); and for backward=true, at the final time (tlist[end])\ngenerator: The time-dependent generator of the dynamics\ntlist: The time grid over which which the propagation is defined. This may or may not be equidistant.\n\nMandatory keyword arguments\n\nmethod: The propagation method to use. May be given as a name (Symbol), but the recommended usage is to pass a module implementing the propagation method, cf. init_prop.\n\nOptional keyword arguments\n\ncheck: if true, check that state, generator, and tlist pass check_state, check_generator and check_tlist, respectively.\nbackward: If true, propagate backward in time\ninplace: If true, propagate using in-place operations. If false, avoid in-place operations. Not all propagation methods support both in-place and not-in-place propagation. Note that inplace=true requires that QuantumPropagators.Interfaces.supports_inplace for state is true.\npiecewise: If given as a boolean, ensure that the internal propagator is an instance of PiecewisePropagator, cf. init_prop.\npwc: If given a boolean, do a piecewise constant propagation where the generator in each interval is constant (the internal propagator is a PWCPropagator, cf. init_prop)\nstorage: Flag whether to store and return the propagated states / observables, or pre-allocated storage array. See Notes below.\nobservables: Converters for data to be stored in storage. See Notes below.\ncallback: Function to call after each propagation step. See Notes below.\nshow_progress: Whether to show a progress bar. See Notes below.\n\nAll remaining keyword arguments are passed to init_prop to initialize the Propagator that is used internally to drive the optimization. Unknown keyword arguments will be ignored.\n\nNotes\n\nIn general, there is no requirement that tlist has a constant time step, although some propagation methods (most notably Cheby) only support a uniform time grid.\n\nIf storage is given as a container pre-allocated via init_storage, it will be filled with data determined by the observables. Specifically, after each propagation step,\n\ndata = map_observables(observables, tlist, i, state)\nwrite_to_storage!(storage, i, data)\n\nis executed, where state is defined at time tlist[i]. See map_observables and write_to_storage! for details. The default values for observables results simply in the propagated states at every point in time being stored.\n\nThe storage parameter may also be given as true, and a new storage array will be created internally with init_storage and returned instead of the propagated state:\n\ndata = propagate(\n    state, generator, tlist; method,\n    backward=false; storage=true, observables=observables,\n    callback=nothing, show_progress=false, init_prop_kwargs...)\n\nIf backward is true, the input state is assumed to be at time tlist[end], and the propagation progresses backward in time (with a negative time step dt). If storage is given, it will be filled back-to-front during the backward propagation.\n\nIf callback is given as a callable, it will be called after each propagation step, as callback(propagator, observables) where propagator is Propagator object driving the propagation. The callback is called before calculating any observables, or storing the propagated state in storage. Example usage includes writing data to file, or modifying state via set_state!, e.g., removing amplitude from the lowest and highest level to mitigate \"truncation error\".\n\nIf show_progress is given as true, a progress bar will be shown for long-running propagation. In order to customize the progress bar, show_progress may also be a function that receives length(tlist) and returns a ProgressMeter.Progress instance.\n\nIf in_place=false is given, the propagation avoids in-place operations. This is slower than inplace=true, but is often required in the context of automatic differentiation (AD), e.g., with Zygote. That is, use in_place=false if propagate is called inside a function to be passed to Zygote.gradient, Zygote.pullback, or a similar function. In an AD context, storage and show_progress should not be used.\n\nThe propagate routine returns the propagated state at tlist[end], respectively tlist[1] if backward=true, or a storage array with the stored states / observable data if storage=true.\n\n\n\n\n\nstate = propagate(\n    state,\n    propagator;\n    storage=nothing,\n    observables=<store state>,\n    show_progress=false,\n    callback=nothing,\n    reinit_prop_kwargs...\n)\n\nre-initializes the given propagator with state (see reinit_prop!) and then calls the lower-level propagate(propagator; ...).\n\n\n\n\n\nstate = propagate(\n    propagator;\n    storage=nothing,\n    observables=<store state>,\n    show_progress=false,\n    callback=nothing,\n)\n\npropagates a freshly initialized propagator (immediately after init_prop). Used in the higher-level propagate(state, generator, tlist; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.propagate_sequence","page":"QuantumPropagators","title":"QuantumPropagators.propagate_sequence","text":"Propagate a state through a sequence of generators.\n\nstates = propagate_sequence(\n    state,\n    propagations;\n    storage=nothing,\n    pre_propagation=nothing,\n    post_propagation=nothing,\n    kwargs...\n)\n\ntakes an initial state and performs a sequence of propagate calls using the parameters in propagations. The initial state for each step in the sequence is the state resulting from the previous step. Optionally, before and after each step, a pre_propagation and post_propagation function may modify the state instantaneously, e.g., to perform a frame transformation. Return the vector of states at the end of each step (after any post_propagation, before any next pre_propagation of the next step).\n\nArguments\n\nstate: The initial state\npropagations: A vector of Propagation instances, one per step in the sequence, each containing the arguments for the call to propagate for that step. The Propagation contains the generator and time grid for each step as positional parameters, or alternatively a pre-initialized Propagator, and any keyword arguments for propagate that are specific to that step. Note that propagate keyword arguments that are common to all steps can be given directly to propagate_sequence.\nstorage: If storage=true, return a vector of storage objects as returned by propagate(…, storage=true) for each propagation step, instead of the state after each step. To use a pre-initialized storage, each Propagation in propagations should have a storage keyword argument instead.\npre_propagation: If not nothing, must be a function that receives the same arguments as propagate and returns a state. Called immediately before the propagate of each step, and the state returned by pre_propagation will become the initial state for the subsequent call to propagate. Generally, pre_propagation would be different in each step of the sequence, and should be given as a keyword argument in a particular Propagation.\npost_propagation: If not nothing, a function that receives the same arguments as propagate and returns a state, see pre_propagation. The returned state becomes the initial state for the next step in the sequence (and may be further processed by the following pre_propagation). Like pre_propagation, this will generally be set as a keyword argument for a particular Propagation, not as a global keyword argument to propagate_sequence.\n\nAll other keyword arguments are forwarded to propagate. Thus, keyword arguments that are common to all steps in the sequence should be given as keyword arguments to propagate_sequence directly.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.reinit_prop!","page":"QuantumPropagators","title":"QuantumPropagators.reinit_prop!","text":"Re-initialize a propagator.\n\nreinit_prop!(propagator, state; kwargs...)\n\nresets the propagator to state at the beginning of the time grid, respectively the end of the time grid if propagator.backward is true.\n\nAt a minimum, this is equivalent to a call to set_state! follow by a call to set_t!, but some propagators may have additional requirements on re-initialization, such as refreshing expansion coefficients for ChebyPropagator. In this case, the kwargs may be additional keyword arguments specific to the concrete type of propagator.\n\n\n\n\n\nreinit_prop!(\n    propagator::ChebyPropagator,\n    state;\n    transform_control_ranges=((c, ϵ_min, ϵ_max, check) => (ϵ_min, ϵ_max)),\n    kwargs...\n)\n\nre-initializes an existing ChebyPropagator. This may or may not involve recalculating the Chebychev coefficients based on the current control amplitudes in propagator.parameters.\n\nMethod-specific keyword arguments\n\ntransform_control_ranges: a function (c, ϵ_min, ϵ_max, check) => (ϵ_min′, ϵ_max′). For each control c, the function is called with check=true and ϵ_min (ϵ_max) the current minimum (maximum) values for the control from propagator.parameters). The Chebychev coefficients will be recalculated if the existing coefficients were obtained assuming a range for c outside the returned ϵ_min′, ϵ_max′.\nIf the coefficients do need to be recalculated, transform_control_ranges is called a second time with check=false, and the returned (ϵ_min′, ϵ_max′) are used for estimating the new spectral range.\nFor example,\nfunction transform_control_ranges(c, ϵ_min, ϵ_max, check)\n    if check\n        return (min(ϵ_min, 2 * ϵ_min), max(ϵ_max, 2 * ϵ_max))\n    else\n        return (min(ϵ_min, 5 * ϵ_min), max(ϵ_max, 5 * ϵ_max))\n    end\nend\nwill re-calculate the Chebychev coefficients only if the current amplitudes differ by more than a factor of two from the ranges that were used when initializing the propagator (control_ranges parameter in init_prop, which would have had to overestimate the actual amplitudes by at least a factor of two).  When re-calculating, the control_ranges will overestimate the amplitudes by a factor of five. With this transform_control_ranges, the propagation will be stable as long as the amplitudes do not change dynamically by more than a factor of 2.5 from their original range, while also not re-calculating coefficients unnecessarily in each pass because of modest changes in the amplitudes.\nThe transform_control_ranges argument is only relevant in the context of optimal control, where the same propagator will be used for many iterations with changing control field amplitudes.\n\nAll other keyword arguments are ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.ExpPropagator","page":"QuantumPropagators","title":"QuantumPropagators.ExpPropagator","text":"Propagator for propagation via direct exponentiation (method=QuantumPropagators.ExpProp)\n\nThis is a PWCPropagator.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.disable_timings","page":"QuantumPropagators","title":"QuantumPropagators.disable_timings","text":"Disable the collection of TimerOutputs data.\n\nQuantumPropagators.disable_timings()\n\ndisables the collection of timing data previously enabled with enable_timings. This triggers recompilation to completely remove profiling from the code. That is, there is zero cost when the collection of timing data is disabled.\n\nReturns QuantumPropagators.timings_enabled(), i.e., false if successful.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.cheby_get_spectral_envelope","page":"QuantumPropagators","title":"QuantumPropagators.cheby_get_spectral_envelope","text":"Determine the spectral envelope of a generator.\n\nE_min, E_max = cheby_get_spectral_envelope(\n    generator, tlist, control_ranges, method; kwargs...\n)\n\nestimates a lower bound E_min the lowest eigenvalue of the generator for any values of the controls specified by control_ranges, and an upper bound E_max for the highest eigenvalue.\n\nThis is done by constructing operators from the extremal values for the controls as specified in control_ranges and taking the smallest/largest return values from specrange for those operators.\n\nArguments\n\ngenerator: dynamical generator, e.g. a time-dependent\ntlist: The time grid for the propagation\ncontrol_ranges: a dict that maps controls that occur in generator (cf. get_controls to a tuple of minimum and maximum amplitude for that control\nmethod: method name to pass to  specrange\nkwargs: Any remaining keyword arguments are passed to specrange\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.set_t!","page":"QuantumPropagators","title":"QuantumPropagators.set_t!","text":"Set the current time for the propagation.\n\nset_t!(propagator, t)\n\nSets propagator.t to the given value of t, where t must be an element of propagator.tlist.\n\nSee also\n\nset_state! — set propagator.state\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.PiecewisePropagator","page":"QuantumPropagators","title":"QuantumPropagators.PiecewisePropagator","text":"AbstractPropagator sub-type for piecewise propagators.\n\nA piecewise propagator is determined by a single parameter per control and time grid interval. Consequently, the propagator.parameters are a dictionary mapping the controls found in the generator via get_controls to a vector of values defined on the intervals of the time grid, see discretize_on_midpoints. This does not necessarily imply that these values are the piecewise-constant amplitudes for the intervals. A general piecewise propagator might use interpolation to obtain actual amplitudes within any given time interval.\n\nWhen the amplitudes are piecewise-constant, the propagator should be a concrete instantiation of a PWCPropagator.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.ChebyPropagator","page":"QuantumPropagators","title":"QuantumPropagators.ChebyPropagator","text":"Propagator for Chebychev propagation (method=QuantumPropagators.Cheby).\n\nThis is a PWCPropagator.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.AbstractPropagator","page":"QuantumPropagators","title":"QuantumPropagators.AbstractPropagator","text":"Abstract base type for all Propagator objects.\n\nAll Propagator objects must be instantiated via init_prop and implement the following interface.\n\nProperties\n\nstate (read-only): The current quantum state in the propagation\ntlist (read-only): The time grid for the propagation\nt (read-only): The time at which state is defined. An element of tlist.\nparameters: parameters that determine the dynamics. The structure of the parameters depends on the concrete Propagator type (i.e., the propagation method). Mutating the parameters affects subsequent propagation steps.\nbackward: Boolean flag to indicate whether the propagation moves forward or backward in time\ninplace: Boolean flag to indicate whether propagator.state is modified in-place or is recreated by every call of prop_step! or set_state!. With inplace=false, the propagator should generally avoid in-place operations, such as calls to QuantumPropagators.Controls.evaluate!.\n\nConcrete Propagator types may have additional properties or fields, but these should be considered private.\n\nMethods\n\nreinit_prop! — reset the propagator to a new initial state at the beginning of the time grid (or the end, for backward propagation)\nprop_step! – advance the propagator by one step forward (or backward) on the time grid.\nset_state! — safely mutate the current quantum state of the propagation. Note that directly mutating the state property is not safe. However, Ψ = propagator.state; foo_mutate!(Ψ), set_state!(propagator, Ψ) for some mutating function foo_mutate! is guaranteed to be safe and efficient for both in-place and not-in-place propagators.\nset_t! — safely mutate the current time (propagator.t), snapping to the values of tlist.\n\nSee also\n\nPiecewisePropagator — specialization of AbstractPropagator for piecewise propagation methods.\nPWCPropagator — specialization of PiecewisePropagator for piecewise-constant propagation methods.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.PWCPropagator","page":"QuantumPropagators","title":"QuantumPropagators.PWCPropagator","text":"PiecewisePropagator sub-type for piecewise-constant propagators.\n\nLike the more general PiecewisePropagator, this is characterized by propagator.parameters mapping the controls in the generator to a vector of amplitude value on the midpoints of the time grid intervals.\n\nThe propagation will use these values as constant within each interval.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.ode_function","page":"QuantumPropagators","title":"QuantumPropagators.ode_function","text":"Wrap around a Generator, for use as an ODE function.\n\nf = ode_function(generator, tlist; c=-1im)\n\ncreates a function suitable to be passed to ODEProblem.\n\ngdefop1hat1\ngdefket1vert1rangle\n\nWith generator corresponding to opH(t), this implicitly encodes the ODE\n\nfracpartialpartial t ketPsi(t) = c opH(t) ketPsi(t)\n\nfor the state ketPsi(t). With the default c = -i, this corresponds to the Schrödinger equation, or the Liouville equation with convention=:LvN.\n\nThe resulting f works both in-place and not-in-place, as\n\nf(ϕ, Ψ, vals_dict, t)   # in-place `f(du, u, p, t)`\nϕ = f(Ψ, vals_dict, t)  # not-in-place `f(u, p, t)`\n\nCalling f as above is functionally equivalent to calling evaluate to obtain an operator H from the original time-dependent generator, and then applying H to the current quantum state Ψ:\n\nH = evaluate(f.generator, t; vals_dict=vals_dict)\nϕ = c * H * Ψ\n\nwhere vals_dict may be a dictionary mapping controls to values (set as the parameters p of the underlying ODE solver).\n\nIf QuantumPropagators.enable_timings() has been called, profiling data is collected in f.timing_data.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.set_state!","page":"QuantumPropagators","title":"QuantumPropagators.set_state!","text":"Set the current state of the propagator.\n\nset_state!(propagator, state)\n\nsets the propagator.state property and returns propagator.state. In order to mutate the current state after a call to prop_step!, the following pattern is recommended:\n\nΨ = propagator.state\nfoo_mutate!(Ψ)\nset_state!(propagator, Ψ)\n\nwhere foo_mutate! is some function that mutates Ψ.  This is guaranteed to work efficiently both for in-place and not-in-place propagators, without incurring unnecessary copies.\n\nwarning: Warning\nfoo_mutate!(propagator.state)by itself is not a safe operation. Always follow it byset_state!(propagator, propagator.state)\n\nSee also\n\nset_t! — set propagator.t.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.enable_timings","page":"QuantumPropagators","title":"QuantumPropagators.enable_timings","text":"Enable the collection of TimerOutputs data.\n\nQuantumPropagators.enable_timings()\n\nenables certain portions of the package to collect TimerOutputs internally. This aids in profiling and benchmarking propagation methods.\n\nSpecifically, after enable_timings(), for any ChebyPropagator or NewtonPropagator, timing data will become available in propagator.wrk.timing_data (as a TimerOutput instance). This data is reset when the propagator is re-instantiated with init_prop or re-initialized with reinit_prop!. This makes the data local to any call of propagate.\n\nNote that enable_timings() triggers recompilation, so propagate should be called at least twice to avoid compilation overhead in the timing data. There is still a small overhead for collecting the timing data.\n\nThe collection of timing data can be disabled again with disable_timings.\n\nReturns QuantumPropagators.timings_enabled(), i.e., true if successful.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.NewtonPropagator","page":"QuantumPropagators","title":"QuantumPropagators.NewtonPropagator","text":"Propagator for Newton propagation (method=QuantumPropagators.Newton).\n\nThis is a PWCPropagator.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.timings_enabled","page":"QuantumPropagators","title":"QuantumPropagators.timings_enabled","text":"Check whether the collection of TimerOutputs data is active.\n\nQuantumPropagators.timings_enabled()\n\nreturns true if QuantumPropagators.enable_timings() was called, and false otherwise or after QuantumPropagators.disable_timings().\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagatorsAmplitudesAPI","page":"QuantumPropagators","title":"QuantumPropagators.Amplitudes","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Public:","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"LockedAmplitude\nShapedAmplitude","category":"page"},{"location":"api/quantum_propagators/#Reference-2","page":"QuantumPropagators","title":"Reference","text":"","category":"section"},{"location":"api/quantum_propagators/#QuantumPropagators.Amplitudes.LockedAmplitude","page":"QuantumPropagators","title":"QuantumPropagators.Amplitudes.LockedAmplitude","text":"A time-dependent amplitude that is not a control.\n\nampl = LockedAmplitude(shape)\n\nwraps around shape, which must be either a vector of values defined on the midpoints of a time grid or a callable shape(t).\n\nampl = LockedAmplitude(shape, tlist)\n\ndiscretizes shape to the midpoints of tlist.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.Amplitudes.ShapedAmplitude","page":"QuantumPropagators","title":"QuantumPropagators.Amplitudes.ShapedAmplitude","text":"Product of a fixed shape and a control.\n\nampl = ShapedAmplitude(control; shape=shape)\n\nproduces an amplitude a(t) = S(t) ϵ(t), where S(t) corresponds to shape and ϵ(t) corresponds to control. Both control and shape should be either a vector of values defined on the midpoints of a time grid or a callable control(t), respectively shape(t). In the latter case, ampl will also be callable.\n\nampl = ShapedAmplitude(control, tlist; shape=shape)\n\ndiscretizes control and shape to the midpoints of tlist.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagatorsArnoldiAPI","page":"QuantumPropagators","title":"QuantumPropagators.Arnoldi","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Private:","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"arnoldi!\nextend_arnoldi!\ndiagonalize_hessenberg_matrix","category":"page"},{"location":"api/quantum_propagators/#Reference-3","page":"QuantumPropagators","title":"Reference","text":"","category":"section"},{"location":"api/quantum_propagators/#QuantumPropagators.Arnoldi.arnoldi!","page":"QuantumPropagators","title":"QuantumPropagators.Arnoldi.arnoldi!","text":"m = arnoldi!(Hess, q, m, Ψ, H, dt=1.0; extended=true, norm_min=1e-15)\n\nCalculate the Hessenberg matrix and Arnoldi vectors of H dt, from Ψ.\n\nFor a given order m, the m×m Hessenberg matrix is calculated and stored in in the pre-allocated Hess. Further  an array of m normalized Arnoldi vectors is stored in in the pre-allocated q, plus one additional unnormalized Arnoldi vector.  The unnormalized m+1st vector could be used to easily extend a given m×m Hessenberg matrix to a (m+1)×(m+1) matrix.\n\nIf the extended Hessenberg matrix is requested (extended=true, default), the m+1st Arnoldi vector is also normalized, and it's norm will be stored in m+1, m entry of the (extended) Hessenberg matrix, which is an (m+1)×(m+1) matrix.\n\nReturn the size m of the calculated Hessenberg matrix. This will usually be the input m, except when the Krylov dimension of H starting from Ψ is less then m. E.g., if Ψ is an eigenstate of H, the returned m will be 1.\n\nSee https://en.wikipedia.org/wiki/Arnoldi_iteration for a description of the algorithm.\n\nArguments\n\nHess::Matrix{ComplexF64}: Pre-allocated storage for the Hessenberg matrix.  Can be uninitialized on input. The matrix must be at least of size m×m, or  (m+1)×(m+1) if extended=true. On output, the m×m sub-matrix of Hess  (with the returned output m) will contain the Hessenberg matrix, and all  other elements of Hess be be set to zero.\nq: Pre-allocated array of states similar to Ψ, as storage for the calculated Arnoldi vectors. These may be uninitialized on input. Must be at least of length m+1\nm: The requested dimensions of the output Hessenberg matrix.\nΨ: The starting vector for the Arnoldi procedure. This can be of any type,  as long as Φ = H * Ψ results in a vector similar to Ψ, there is an inner  products of Φ and Ψ (Ψ⋅Φ is defined), and norm(Ψ) is defined.\nH: The operator (up to dt) for which to calculate the Arnoldi procedure. Can be of any type, as long as H * Ψ is defined.\ndt: The implicit time step; the total operator for which to calculate the Arnoldi procedure is H * dt\nextended: If true (default), calculate the extended Hessenberg matrix, and normalized the final Arnoldi vector\nnorm_min: the minimum value of the norm of Ψ at which Ψ should be  considered the zero vector\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Arnoldi.extend_arnoldi!","page":"QuantumPropagators","title":"QuantumPropagators.Arnoldi.extend_arnoldi!","text":"Extend dimension of Hessenberg matrix by one.\n\nextend_arnoldi!(Hess, q, m, H, dt; norm_min=1e-15)\n\nextends the entries in Hess from size (m-1)×(m-1) to size m×m, and the list q of Arnoldi vectors from m to (m+1). It is assumed that the input Hess was created by a call to arnoldi! with extended=false or a previous call to extend_arnoldi!. Note that Hess itself is not resized, so it must be allocated to size m×m or greater on input.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Arnoldi.diagonalize_hessenberg_matrix","page":"QuantumPropagators","title":"QuantumPropagators.Arnoldi.diagonalize_hessenberg_matrix","text":"diagonalize_hessenberg_matrix(Hess, m; accumulate=false)\n\nDiagonalize the m × m top left sub-matrix of the given Hessenberg matrix.\n\nIf accumulate is true, return the concatenated eigenvalues for Hess[1:1,1:1] to Hess[1:m,1:m], that is, all sub-matrices of size 1 through m.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagatorsChebyAPI","page":"QuantumPropagators","title":"QuantumPropagators.Cheby","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Public:","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"ChebyWrk\ncheby\ncheby!\ncheby_coeffs\ncheby_coeffs!","category":"page"},{"location":"api/quantum_propagators/#Reference-4","page":"QuantumPropagators","title":"Reference","text":"","category":"section"},{"location":"api/quantum_propagators/#QuantumPropagators.Cheby.ChebyWrk","page":"QuantumPropagators","title":"QuantumPropagators.Cheby.ChebyWrk","text":"Workspace for the Chebychev propagation routine.\n\nChebyWrk(Ψ, Δ, E_min, dt; limit=1e-12)\n\ninitializes the workspace for the propagation of a state similar to Ψ under a Hamiltonian with eigenvalues between E_min and E_min + Δ, and a time step dt. Chebychev coefficients smaller than the given limit are discarded.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.Cheby.cheby","page":"QuantumPropagators","title":"QuantumPropagators.Cheby.cheby","text":"Evaluate Ψ = exp(-𝕚 * H * dt) Ψ.\n\nΨ_out = cheby(Ψ, H, dt, wrk; E_min=nothing, check_normalization=false)\n\nacts like cheby! but does not modify Ψ in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Cheby.cheby!","page":"QuantumPropagators","title":"QuantumPropagators.Cheby.cheby!","text":"Evaluate Ψ = exp(-𝕚 * H * dt) Ψ in-place.\n\ncheby!(Ψ, H, dt, wrk; E_min=nothing, check_normalization=false)\n\nArguments\n\nΨ: on input, initial vector. Will be overwritten with result.\nH: Hermitian operator\ndt: time step\nwrk: internal workspace\nE_min: minimum eigenvalue of H, to be used instead of the E_min from the  initialization of wrk. The same wrk may be used for different values  E_min, as long as the spectra radius Δ and the time step dt are the  same as those used for the initialization of wrk.\ncheck_normalizataion: perform checks that the H does not exceed the spectral radius for which the workspace was initialized.\n\nThe routine will not allocate any internal storage. This implementation requires copyto! lmul!, and axpy! to be implemented for Ψ, and the three-argument mul! for Ψ and H.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Cheby.cheby_coeffs","page":"QuantumPropagators","title":"QuantumPropagators.Cheby.cheby_coeffs","text":"Calculate Chebychev coefficients.\n\na::Vector{Float64} = cheby_coeffs(Δ, dt; limit=1e-12)\n\nreturn an array of coefficients larger than limit.\n\nArguments\n\nΔ: the spectral radius of the underlying operator\ndt: the time step\n\nSee also cheby_coeffs! for an in-place version.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Cheby.cheby_coeffs!","page":"QuantumPropagators","title":"QuantumPropagators.Cheby.cheby_coeffs!","text":"Calculate Chebychev coefficients in-place.\n\nn::Int = cheby_coeffs!(coeffs, Δ, dt, limit=1e-12)\n\noverwrites the first n values in coeffs with new coefficients larger than limit for the given new spectral radius Δ and time step dt. The coeffs array will be resized if necessary, and may have a length > n on exit.\n\nSee also cheby_coeffs for an non-in-place version.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagatorsControlsAPI","page":"QuantumPropagators","title":"QuantumPropagators.Controls","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Public:","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"ParameterizedFunction\ndiscretize\ndiscretize_on_midpoints\nevaluate\nevaluate!\nget_controls\nget_parameters\nget_tlist_midpoints\nsubstitute\nt_mid","category":"page"},{"location":"api/quantum_propagators/#Reference-5","page":"QuantumPropagators","title":"Reference","text":"","category":"section"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.ParameterizedFunction","page":"QuantumPropagators","title":"QuantumPropagators.Controls.ParameterizedFunction","text":"Abstract type for function-like objects with parameters.\n\nA struct that is an implementation of a ParameterizedFunction:\n\nmust have a parameters field that is an AbstractVector of floats (e.g., a ComponentArrays.ComponentVector)\nmust be callable with a single float argument t,\nmay define getters and setters for referencing the values in parameters with convenient names.\n\nThe parameters field of any ParameterizedFunction can be accessed via get_parameters.\n\nSee How to define a parameterized control for an example. You may use the QuantumPropagators.Interfaces.check_parameterized_function to check the implementation of a ParameterizedFunction subtype.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.discretize","page":"QuantumPropagators","title":"QuantumPropagators.Controls.discretize","text":"Evaluate control at every point of tlist.\n\nvalues = discretize(control, tlist; via_midpoints=true)\n\ndiscretizes the given control to a Vector of values defined on the points of tlist.\n\nIf control is a function, it is first evaluated at the midpoint of tlist, see discretize_on_midpoints, and then the values on the midpoints are converted to values on tlist. This discretization is more stable than directly evaluating the control function at the values of tlist, and ensures that repeated round-trips between discretize and discretize_on_midpoints can be done safely, see the note in the documentation of discretize_on_midpoints.\n\nThe latter can still be achieved by passing via_midpoints=false. While such a direct discretization is suitable e.g. for plotting, but it is unsuitable for round-trips between discretize and discretize_on_midpoints  (constant controls on tlist may result in a zig-zag on the intervals of tlist).\n\nIf control is a vector, a copy of control will be returned if it is of the same length as tlist. Otherwise, control must have one less value than tlist, and is assumed to be defined on the midpoints of tlist. In that case, discretize acts as the inverse of discretize_on_midpoints. See discretize_on_midpoints for how control values on tlist and control values on the intervals of tlist are related.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.discretize_on_midpoints","page":"QuantumPropagators","title":"QuantumPropagators.Controls.discretize_on_midpoints","text":"Evaluate control at the midpoints of tlist.\n\nvalues = discretize_on_midpoints(control, tlist)\n\ndiscretizes the given control to a Vector of values on the midpoints of tlist. Hence, the resulting values will contain one less value than tlist.\n\nIf control is a vector of values defined on tlist (i.e., of the same length as tlist), it will be converted to a vector of values on the intervals of tlist. The value for the first and last \"midpoint\" will remain the original values at the beginning and end of tlist, in order to ensure exact boundary conditions. For all other midpoints, the value for that midpoint will be calculated by \"un-averaging\".\n\nFor example, for a control and tlist of length 5, consider the following diagram:\n\ntlist index:       1   2   3   4   5\ntlist:             ⋅   ⋅   ⋅   ⋅   ⋅   input values cᵢ (i ∈ 1..5)\n                   |̂/ ̄ ̄ ̂\\ / ̂\\ / ̂ ̄ ̄\\|̂\nmidpoints:         x     x   x     x   output values pᵢ (i ∈ 1..4)\nmidpoints index:   1     2   3     4\n\nWe will have p₁=c₁ for the first value, p₄=c₅ for the last value. For all other points, the control values cᵢ = fracp_i-1 + p_i2 are the average of the values on the midpoints. This implies the \"un-averaging\" for the midpoint values pᵢ = 2 c_i - p_i-1.\n\nnote: Note\nAn arbitrary input control array may not be compatible with the above averaging formula. In this case, the conversion will be \"lossy\" (discretize will not recover the original control array; the difference should be considered a \"discretization error\"). However, any further round-trip conversions between points and intervals are bijective and preserve the boundary conditions. In this case, the discretize_on_midpoints and discretize methods are each other's inverse. This also implies that for an optimal control procedure, it is safe to modify midpoint values. Modifying the the values on the time grid directly on the other hand may accumulate discretization errors.\n\nIf control is a vector of one less length than tlist, a copy of control will be returned, under the assumption that the input is already properly discretized.\n\nIf control is a function, the function will be directly evaluated at the midpoints marked as x in the above diagram..\n\nSee also\n\nget_tlist_midpoints – get all the midpoints on which the control will be discretized.\nt_mid – get a particular midpoint.\ndiscretize – discretize directly on tlist instead of on the midpoints\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.evaluate","page":"QuantumPropagators","title":"QuantumPropagators.Controls.evaluate","text":"Evaluate all controls.\n\nIn general, evaluate(object, args...; vals_dict=IdDict()) evaluates the object for a specific point in time indicated by the positional args. Any control in object is evaluated at the specified point in time. Alternatively, the vals_dict maps a controls to value (\"plug in this value for the given control\")\n\nFor example,\n\nop = evaluate(generator, t)\n\nevaluates generator at time t. This requires that any control in generator is a callable that takes t as a single argument.\n\nop = evaluate(generator, tlist, n)\n\nevaluates generator for the n'th interval of tlist. This uses the definitions for the midpoints in discretize_on_midpoints. The controls in generator may be vectors (see discretize, discretize_on_midpoints) or callables of t.\n\nop = evaluate(generator, t; vals_dict)\nop = evaluate(generator, tlist, n; vals_dict)\n\nresolves any explicit time dependencies in generator at the specified point in time, but uses the value in the given vals_dict for any control in vals_dict.\n\na = evaluate(ampl, tlist, n; vals_dict=IdDict())\na = evaluate(ampl, t; vals_dict=IdDict())\n\nevaluates a control amplitude to a scalar by evaluating any explicit time dependency, and by replacing each control with the corresponding value in vals_dict.\n\nCalling evaluate for an object with no implicit or explicit time dependence should return the object unchanged.\n\nFor generators without any explicit time dependence,\n\nop = evaluate(generator; vals_dict)\n\ncan be used. The vals_dict in this case must contain values for all controls in generator.\n\nSee also:\n\nevaluate! — update an existing operator with a re-evaluation of a\n\ngenerator at a different point in time.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.evaluate!","page":"QuantumPropagators","title":"QuantumPropagators.Controls.evaluate!","text":"Update an existing evaluation of a generator.\n\nevaluate!(op, generator, args..; vals_dict=IdDict())\n\nperforms an in-place update on an op the was obtained from a previous call to evaluate with the same generator, but for a different point in time and/or different values in vals_dict.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.get_controls","page":"QuantumPropagators","title":"QuantumPropagators.Controls.get_controls","text":"Extract a Tuple of controls.\n\ncontrols = get_controls(generator)\n\nextracts the controls from a single dynamical generator.\n\nFor example, if generator = hamiltonian(H0, (H1, ϵ1), (H2, ϵ2)), extracts (ϵ1, ϵ2).\n\n\n\n\n\nget_controls(operator)\n\nfor a static operator (matrix) returns an empty tuple.\n\n\n\n\n\ncontrols = get_controls(trajectories)\n\nextracts the controls from a list of trajectories (i.e., from each trajectory's generator). Controls that occur multiple times in the different trajectories will occur only once in the result.\n\n\n\n\n\ncontrols = get_controls(problem)\n\nextracts the controls from problem.trajectories.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.get_parameters","page":"QuantumPropagators","title":"QuantumPropagators.Controls.get_parameters","text":"Obtain analytic parameters of the given control.\n\nparameters = get_parameters(control)\n\nobtains parameters as an AbstractVector{Float64} containing any tunable analytic parameters associated with the control. The specific type of parameters depends on how control is defined, but a ComponentArrays.ComponentVector should be a common array type.\n\nMutating the resulting vector must directly affect the control in any subsequent call to evaluate. That is, the values in parameters must alias values inside the control.\n\nNote that the control must be an object specifically designed to have analytic parameters. Typically, it should be implemented as a subtype of ParameterizedFunction. For a simple function ϵ(t) or a vector of pulse values, which are the default types of controls discussed in the documentation of hamiltonian, the get_parameters function will return an empty vector.\n\nMore generally,\n\nparameters = get_parameters(object)\n\ncollects and combines all unique parameter arrays from the controls inside the object. The object may be a Generator, Trajectory, ControlProblem, or any other object for which get_controls(object) is defined. If there are multiple controls with different parameter arrays, these are combined in a RecursiveArrayTools.ArrayPartition. This requires the RecursiveArrayTools package to be loaded. Again, mutating parameters directly affects the underlying controls.\n\nThe parameters may be used as part of the parameters attribute of a propagator for time-continuous dynamics, like a general ODE solver, or in an optimization that tunes analytic control parameters, e.g., with a Nelder-Mead method. Examples might include the widths, peak amplitudes, and times of a superposition of Gaussians [20], cf. the example of a ParameterizedFunction, or the amplitudes associated with spectral components in a random truncated basis [21].\n\nThe parameters are not intended for optimization methods such as GRAPE or Krotov that fundamentally use a piecewise-constant control ansatz. In the context of such methods, the \"control parameters\" are always the amplitudes of the control at the mid-points of the time grid, as obtained by discretize_on_midpoints, and get_parameters is ignored.\n\n\n\n\n\nparameters = get_parameters(trajectories)\n\ncollects and combines get parameter arrays from all the generators in trajectories. Note that this allows any custom generator type to define a custom get_parameters method to override the default of obtaining the parameters recursively from the controls inside the generator.\n\n\n\n\n\nparameters = get_parameters(problem)\n\nextracts the parameters from problem.trajectories.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.get_tlist_midpoints","page":"QuantumPropagators","title":"QuantumPropagators.Controls.get_tlist_midpoints","text":"Shift time grid values to the interval midpoints\n\ntlist_midpoints = get_tlist_midpoints(\n    tlist; preserve_start=true, preserve_end=true\n)\n\ntakes a vector tlist of length n and returns a Vector{Float64} of length n-1 containing the midpoint values of each interval. The intervals in tlist are not required to be uniform.\n\nBy default, the first and last point of tlist is preserved, see discretize_on_midpoints. This behavior can be disabled by passing preserve_start and preserve_end as false in order to use the midpoints of the first and last interval, respectively.\n\nSee also\n\nt_mid – get a particular midpoint.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.substitute","page":"QuantumPropagators","title":"QuantumPropagators.Controls.substitute","text":"Substitute inside the given object.\n\nobject = substitute(object, replacements)\n\nreturns a modified object with the replacements defined in the given replacements dictionary. Things that can be replaced include operators, controls, and amplitudes. For example,\n\ngenerator = substitute(generator::Generator, replacements)\noperator = substitute(operator::Operator, replacements)\namplitude = substitute(amplitude, controls_replacements)\n\nNote that substitute cannot be used to replace dynamic quantities, e.g. controls, with static value. Use evaluate instead for that purpose.\n\n\n\n\n\ntrajectory = substitute(trajectory::Trajectory, replacements)\ntrajectories = substitute(trajectories::Vector{<:Trajectory}, replacements)\n\nrecursively substitutes the initial_state, generator, and target_state.\n\n\n\n\n\nproblem = substitute(problem::ControlProblem, replacements)\n\nsubstitutes in problem.trajectories\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Controls.t_mid","page":"QuantumPropagators","title":"QuantumPropagators.Controls.t_mid","text":"Midpoint of n'th interval of tlist.\n\nt = t_mid(tlist, n)\n\nreturns the t that is the midpoint between points tlist[n+1] and tlist[n], but snapping to the beginning/end to follow the convention explained in discretize_on_midpoints (to preserve exact boundary conditions at the edges of the time grid.)\n\nSee also\n\nget_tlist_midpoints – get all the midpoints in one go.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagatorsExpPropAPI","page":"QuantumPropagators","title":"QuantumPropagators.ExpProp","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Public:","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"ExpPropWrk\nexpprop!","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Private:","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"expprop","category":"page"},{"location":"api/quantum_propagators/#Reference-6","page":"QuantumPropagators","title":"Reference","text":"","category":"section"},{"location":"api/quantum_propagators/#QuantumPropagators.ExpProp.ExpPropWrk","page":"QuantumPropagators","title":"QuantumPropagators.ExpProp.ExpPropWrk","text":"ExpPropWrk(v0)\n\nWorkspace for propagation via direct matrix exponentiation.\n\nInitializes the workspace for the propagation of a vector v0\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.ExpProp.expprop!","page":"QuantumPropagators","title":"QuantumPropagators.ExpProp.expprop!","text":"expprop!(Ψ, H, dt, wrk; func=(H_dt -> exp(-1im * H_dt)), _...)\n\nEvaluate Ψ = func(H*dt) Ψ by directly evaluating U = func(H*dt), i.e. by matrix exponentiation for the default func, and then multiplying U and Ψ in-place with mul!.\n\nThe workspace wrk must be initialized with ExpPropWrk to provide storage for a temporary state.\n\nKeyword arguments besides func are ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.ExpProp.expprop","page":"QuantumPropagators","title":"QuantumPropagators.ExpProp.expprop","text":"Ψ_out = expprop(Ψ, H, dt, wrk; func=(H_dt -> exp(-1im * H_dt)), _...)\n\nevaluates Ψ_out = func(H*dt) Ψ as in expprop!, but not acting in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagatorsGeneratorsAPI","page":"QuantumPropagators","title":"QuantumPropagators.Generators","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Public:","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Generator\nOperator\nScaledOperator\nhamiltonian\nliouvillian","category":"page"},{"location":"api/quantum_propagators/#Reference-7","page":"QuantumPropagators","title":"Reference","text":"","category":"section"},{"location":"api/quantum_propagators/#QuantumPropagators.Generators.Generator","page":"QuantumPropagators","title":"QuantumPropagators.Generators.Generator","text":"A time-dependent generator.\n\nGenerator(ops::Vector{OT}, amplitudes::Vector{AT})\n\nproduces an object of type Generator{OT,AT} that represents\n\nH(t)= H_0 + sum_l a_l(ϵ_l(t) t)  H_l\n\nwhere H_l are the ops and a_l(t) are the amplitudes. H(t) and H_l may represent operators in Hilbert space or super-operators in Liouville space. If the number of amplitudes is less than the number of ops, the first ops are considered as drift terms (H_0, respectively subsequent terms with a_l  1). At least one time-dependent amplitude is required. Each amplitude may depend on one or more control functions ϵ_l(t), although most typically a_l(t)  ϵ_l(t), that is, the amplitudes are simply a vector of the controls. See hamiltonian for details.\n\nA Generator object should generally not be instantiated directly, but via hamiltonian or liouvillian.\n\nThe list of ops and amplitudes are properties of the Generator. They should not be mutated.\n\nSee also\n\nOperator for static generators, which may be obtained from a Generator via evaluate.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.Generators.Operator","page":"QuantumPropagators","title":"QuantumPropagators.Generators.Operator","text":"A static operator in Hilbert or Liouville space.\n\nOperator(ops::Vector{OT}, coeffs::Vector{CT})\n\nproduces an object of type Operator{OT,CT} that encapsulates the \"lazy\" sum\n\nH = sum_l c_l H_l\n\nwhere H_l are the ops and c_l are the coeffs, which each must be a constant Number. If the number of coefficients is less than the number of operators, the first ops are considered to have c_l = 1.\n\nAn Operator object would generally not be instantiated directly, but be obtained from a Generator via evaluate.\n\nThe H_l in the sum are considered immutable. This implies that an Operator can be updated in-place with evaluate! by only changing the coeffs.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.Generators.ScaledOperator","page":"QuantumPropagators","title":"QuantumPropagators.Generators.ScaledOperator","text":"A static operator with a scalar pre-factor.\n\nop = ScaledOperator(α, Ĥ)\n\nrepresents the \"lazy\" product α H where H is an operator (typically an Operator instance) and α is a scalar.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.Generators.hamiltonian","page":"QuantumPropagators","title":"QuantumPropagators.Generators.hamiltonian","text":"Initialize a (usually time-dependent) Hamiltonian.\n\nThe most common usage is, e.g.,\n\nusing QuantumPropagators\n\nH₀ = ComplexF64[0 0; 0 1];\nH₁ = ComplexF64[0 1; 1 0];\nϵ₁(t) = 1.0;\n\nhamiltonian(H₀, (H₀, ϵ₁))\n\n# output\n\nGenerator with 2 ops and 1 amplitudes\n ops::Vector{Matrix{ComplexF64}}:\n  ComplexF64[0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 1.0 + 0.0im]\n  ComplexF64[0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 1.0 + 0.0im]\n amplitudes::Vector{typeof(ϵ₁)}:\n  ϵ₁\n\nIn general,\n\nH = hamiltonian(terms...; check=true)\n\nconstructs a Hamiltonian based on the given terms. Each term must be an operator or a tuple (op, ampl) of an operator and a control amplitude. Single operators are considered \"drift\" terms.\n\nIn most cases, each control amplitude will simply be a control function or vector of pulse values. In general, ampl can be an arbitrary object that depends on one or more controls, which must be obtainable via get_controls(ampl). See QuantumPropagators.Interfaces.check_amplitude for the required interface.\n\nThe hamiltonian function will generally return a Generator instance. However, if none of the given terms are time-dependent, it may return a static operator (e.g., an AbstractMatrix or Operator):\n\nhamiltonian(H₀)\n# output\n2×2 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im\n\nhamiltonian(H₀, (H₁, 2.0))\n# output\nOperator with 2 ops and 1 coeffs\n ops::Vector{Matrix{ComplexF64}}:\n  ComplexF64[0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 1.0 + 0.0im]\n  ComplexF64[0.0 + 0.0im 1.0 + 0.0im; 1.0 + 0.0im 0.0 + 0.0im]\n coeffs: [2.0]\n\nThe hamiltonian function may generate warnings if the terms are of an unexpected type or structure.  These can be suppressed with check=false.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Generators.liouvillian","page":"QuantumPropagators","title":"QuantumPropagators.Generators.liouvillian","text":"Construct a Liouvillian Generator.\n\nℒ = liouvillian(Ĥ, c_ops=(); convention=:LvN, check=true)\n\ncalculates the sparse Liouvillian super-operator ℒ from the Hamiltonian Ĥ and a list c_ops of Lindblad operators.\n\nWith convention=:LvN, applying the resulting ℒ to a vectorized density matrix ρ⃗ calculates fracddt vecrho(t) = ℒ vecrho(t) equivalent to the Liouville-von-Neumann equation for the density matrix ρ,\n\nfracddt ρ(t)\n= -i H ρ(t) + sum_kleft(\n    A_k ρ A_k^dagger\n    - frac12 A_k^dagger A_k ρ\n    - frac12 ρ A_k^dagger A_k\n  right)\n\nwhere the Lindblad operators A_k are the elements of c_ops.\n\nThe Hamiltonian H will generally be time-dependent. For example, it may be a Generator as returned by hamiltonian. For example, for a Hamiltonian with the terms (Ĥ₀, (Ĥ₁, ϵ₁), (Ĥ₂, ϵ₂)), where Ĥ₀, Ĥ₁, Ĥ₂ are matrices, and ϵ₁ and ϵ₂ are functions of time, the resulting ℒ will be a Generator corresponding to terms (ℒ₀, (ℒ₁, ϵ₁), (ℒ₂, ϵ₂)), where the initial terms is the superoperator ℒ₀ for the static component of the Liouvillian, i.e., the commutator with the drift Hamiltonian Ĥ₀, plus the dissipator (sum over k), as a sparse matrix. Time-dependent Lindblad operators are not currently supported. The remaining elements are tuples (ℒ₁, ϵ₁) and (ℒ₂, ϵ₂) corresponding to the commutators with the two control Hamiltonians, where ℒ₁ and ℒ₂ again are sparse matrices.\n\nIf H is not time-dependent, the resulting ℒ will likewise be a static operator. Passing H=nothing with non-empty c_ops initializes a pure dissipator.\n\nWith convention=:TDSE, the Liouvillian will be constructed for the equation of motion i hbar fracddt vecrho(t) = ℒ vecrho(t) to match exactly the form of the time-dependent Schrödinger equation. While this notation is not standard in the literature of open quantum systems, it has the benefit that the resulting ℒ can be used in a numerical propagator for a (non-Hermitian) Schrödinger equation without any change. Thus, for numerical applications, convention=:TDSE is generally preferred. The returned ℒ between the two conventions differs only by a factor of i, since we generally assume hbar=1.\n\nThe convention keyword argument is mandatory, to force a conscious choice.\n\nSee Goerz et. al. \"Optimal control theory for a unitary operation under dissipative evolution\", arXiv 1312.0111v2, Appendix B.2 for the explicit construction of the Liouvillian superoperator as a sparse matrix.\n\nPassing check=false, suppresses warnings and errors about unexpected types or the structure of the arguments, cf. hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagatorsInterfacesAPI","page":"QuantumPropagators","title":"QuantumPropagators.Interfaces","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Public:","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"check_amplitude\ncheck_control\ncheck_generator\ncheck_operator\ncheck_parameterized\ncheck_parameterized_function\ncheck_propagator\ncheck_state\ncheck_tlist\nsupports_inplace","category":"page"},{"location":"api/quantum_propagators/#Reference-8","page":"QuantumPropagators","title":"Reference","text":"","category":"section"},{"location":"api/quantum_propagators/#QuantumPropagators.Interfaces.check_amplitude","page":"QuantumPropagators","title":"QuantumPropagators.Interfaces.check_amplitude","text":"Check amplitude appearing in Generator.\n\n@test check_amplitude(ampl; tlist, quiet=false)\n\nverifies that the given ampl is a valid element in the list of amplitudes of a Generator object. Specifically:\n\nget_controls(ampl) must be defined and return a tuple\nall controls in ampl must pass check_control\nsubstitute(ampl, controls_replacements) must be defined\nevaluate(ampl, tlist, n) must be defined and return a Number\nevaluate(ampl, tlist, n; vals_dict) must be defined and return a Number\n\nIf for_parameterization (may require the RecursiveArrayTools package to be loaded):\n\nget_parameters(ampl) must be defined and return a vector of floats. Mutating that vector must mutate the controls inside the ampl.\n\nThe function returns true for a valid amplitude and false for an invalid amplitude. Unless quiet=true, it will log an error to indicate which of the conditions failed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Interfaces.check_control","page":"QuantumPropagators","title":"QuantumPropagators.Interfaces.check_control","text":"Check that control can be evaluated on a time grid.\n\n@test check_control(\n    control;\n    tlist,\n    for_parameterization=true,\n    for_time_continuous=(control isa Function),\n    quiet=false\n)\n\nverifies the given control (one of the elements of the tuple returned by get_controls):\n\nevaluate(control, tlist, n) must be defined and return a Float64\nevaluate(control, tlist, n; vals_dict=IdDict(control => v)) must be defined and return v\ndiscretize(control, tlist) must be defined and return a vector of floats of the same size as tlist. Only if length(tlist) > 2.\nall values in discretize(control, tlist) must be finite (isfinite).\ndiscretize_on_midpoints(control, tlist) must be defined and return a vector of floats with one element less than tlist. Only if length(tlist) > 2.\nall values in discretize_on_midpoints(control, tlist) must be finite (isfinite)\n\nIf for_time_continuous:\n\nevaluate(control, t) must be defined and return a Float64\nevaluate(control, t; vals_dict=IdDict(control => v)) must be defined and return v\n\nIf for_parameterization:\n\nget_parameters(control) must be defined and return a vector of floats. Mutating that vector must mutate the control.\n\nThe function returns true for a valid control and false for an invalid control. Unless quiet=true, it will log an error to indicate which of the conditions failed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Interfaces.check_generator","page":"QuantumPropagators","title":"QuantumPropagators.Interfaces.check_generator","text":"Check the dynamical generator for propagating state over tlist.\n\n@test check_generator(\n    generator; state, tlist,\n    for_pwc=true, for_time_continuous=false,\n    for_expval=true, for_parameterization=false,\n    atol=1e-14, quiet=false)\n\nverifies the given generator:\n\nget_controls(generator) must be defined and return a tuple\nall controls returned by get_controls(generator) must pass check_control\nsubstitute(generator, replacements) must be defined\nIf generator is a Generator instance, all elements of generator.amplitudes must pass check_amplitude with for_parameterization.\n\nIf for_pwc (default):\n\nop = evaluate(generator, tlist, n) must return a valid operator (check_operator), with forwarded keyword arguments (including for_expval)\nIf QuantumPropagators.Interfaces.supports_inplace(op) is true, evaluate!(op, generator, tlist, n) must be defined\n\nIf for_time_continuous:\n\nevaluate(generator, t) must return a valid operator (check_operator), with forwarded keyword arguments (including for_expval)\nIf QuantumPropagators.Interfaces.supports_inplace(op) is true, evaluate!(op, generator, t) must be defined\n\nIf for_parameterization (may require the RecursiveArrayTools package to be loaded):\n\nget_parameters(generator) must be defined and return a vector of floats. Mutating that vector must mutate the controls inside the generator.\n\nThe function returns true for a valid generator and false for an invalid generator. Unless quiet=true, it will log an error to indicate which of the conditions failed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Interfaces.check_operator","page":"QuantumPropagators","title":"QuantumPropagators.Interfaces.check_operator","text":"Check that op is a valid operator that can be applied to state.\n\n@test check_operator(op; state, tlist=[0.0, 1.0],\n                     for_expval=true, atol=1e-14, quiet=false)\n\nverifies the given op relative to state. The state must pass check_state.\n\nAn \"operator\" is any object that evaluate returns when evaluating a time-dependent dynamic generator. The specific requirements for op are:\n\nop must not be time-dependent: evaluate(op, tlist, 1) ≡ op\nop must not contain any controls: length(get_controls(op)) == 0\nop * state must be defined\nThe QuantumPropagators.Interfaces.supports_inplace method must be defined for op. If it returns true, it must be possible to evaluate a generator in-place into the existing op. See check_generator.\n\nIf QuantumPropagators.Interfaces.supports_inplace(state):\n\nThe 3-argument LinearAlgebra.mul! must apply op to the given state\nThe 5-argument LinearAlgebra.mul! must apply op to the given state\nLinearAlgebra.mul! must match *, if applicable\nLinearAlgebra.mul! must return the resulting state\n\nIf for_expval (typically required for optimal control):\n\nLinearAlgebra.dot(state, op, state) must return return a number\ndot(state, op, state) must match dot(state, op * state), if applicable\n\nThe function returns true for a valid operator and false for an invalid operator. Unless quiet=true, it will log an error to indicate which of the conditions failed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Interfaces.check_parameterized","page":"QuantumPropagators","title":"QuantumPropagators.Interfaces.check_parameterized","text":"Check that that the object supports the parameterization interface.\n\n@test check_parameterized(object; name=\"::$typeof(object))\", quiet=false)\n\nverifies that the given object:\n\ncan be passed to get_parameters, which must return an AbstractVector of Float64\nis mutated by mutating the parameters obtained by get_parameters\n\nSee also\n\ncheck_parameterized_function is object is a ParameterizedFunction\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Interfaces.check_parameterized_function","page":"QuantumPropagators","title":"QuantumPropagators.Interfaces.check_parameterized_function","text":"Check a ParameterizedFunction instance.\n\n@test check_parameterized_function(f; tlist; quiet=false)\n\nverifies that the given f:\n\nis an instance of ParameterizedFunction.\nhas a field parameters that is an AbstractVector{Float64}.\nis a callable as f(t) for values of t in tlist, returning a Float64.\nget_parameters provides access to the parameters field.\npasses check_parameterized\n\nSee also\n\ncheck_parameterized for objects that have parameters (get_parameters), but are not instances of ParameterizedFunction\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Interfaces.check_propagator","page":"QuantumPropagators","title":"QuantumPropagators.Interfaces.check_propagator","text":"Check that the given propagator implements the required interface.\n\n@test check_propagator(propagator; atol=1e-14, quiet=false)\n\nverifies that the propagator matches the interface described for an AbstractPropagator. The propagator must have been freshly initialized with init_prop.\n\npropagator must have the properties state, tlist, t, parameters, backward, and inplace\npropagator.state must be a valid state (see check_state)\nIf propagator.inplace is true, supports_inplace for propagator.state must also be true\npropagator.tlist must be monotonically increasing.\npropagator.t must be the first or last element of propagator.tlist, depending on propagator.backward\nprop_step!(propagator) must be defined and return a valid state until the time grid is exhausted\nFor an in-place propagator, the state returned by prop_step! must be the propagator.state object\nFor a not-in-place propagator, the state returned by prop_step! must be a new object\nprop_step! must advance propagator.t forward or backward one step on the time grid\nprop_step! must return nothing when going beyond the time grid\nset_t!(propagator, t) must be defined and set propagator.t\nset_state!(propagator, state) must be defined and set propagator.state.\nset_state!(propagator, state) for an in-place propagator   must overwrite propagator.state in-place.\nset_state! must return the set propagator.state\nIn a PiecewisePropagator, propagator.parameters must be a dict mapping controls to a vector of values, one for each interval on propagator.tlist\nreinit_prop! must be defined and re-initialize the propagator\nreinit_prop!(propagator, state) must be idempotent. That is, repeated calls to reinit_prop! leave the propagator unchanged.\n\nThe function returns true for a valid propagator and false for an invalid propagator. Unless quiet=true, it will log an error to indicate which of the conditions failed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Interfaces.check_state","page":"QuantumPropagators","title":"QuantumPropagators.Interfaces.check_state","text":"Check that state is a valid element of a Hilbert space.\n\n@test check_state(state; normalized=false, atol=1e-15, quiet=false)\n\nverifies the following requirements:\n\nThe inner product (LinearAlgebra.dot) of two states must return a Complex number.\nThe LinearAlgebra.norm of state must be defined via the inner product. This is the definition of a Hilbert space, a.k.a a \"complete inner product space\" or more precisely a \"Banach space (normed vector space) where the norm is induced by an inner product\".\nThe `QuantumPropagators.Interfaces.supports_inplace method must be defined for state\n\nAny state must support the following not-in-place operations:\n\nstate + state and state - state must be defined\ncopy(state) must be defined and return an object of the same type as state\nc * state for a scalar c must be defined\nnorm(state + state) must fulfill the triangle inequality\nzero(state) must be defined and produce a state with norm 0\n0.0 * state must produce a state with norm 0\ncopy(state) - state must have norm 0\nnorm(state) must have absolute homogeneity: norm(s * state) = s * norm(state)\n\nIf supports_inplace(state) is true, the state must also support the following:\n\nsimilar(state) must be defined and return a valid state of the same type a state\ncopyto!(other, state) must be defined\nfill!(state, c) must be defined\nLinearAlgebra.lmul!(c, state) for a scalar c must be defined\nLinearAlgebra.axpy!(c, state, other) must be defined\nnorm(state) must fulfill the same general mathematical norm properties as for the non-in-place norm.\n\nIf normalized (not required by default):\n\nLinearAlgebra.norm(state) must be 1\n\nIt is strongly recommended to always support immutable operations (also for mutable states)\n\nThe function returns true for a valid state and false for an invalid state. Unless quiet=true, it will log an error to indicate which of the conditions failed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Interfaces.check_tlist","page":"QuantumPropagators","title":"QuantumPropagators.Interfaces.check_tlist","text":"Check that the given tlist is valid.\n\n@test check_tlist(tlist; quiet=false)\n\nverifies the given time grid. A valid time grid must\n\nbe a Vector{Float64},\ncontain at least two points (beginning and end),\nbe monotonically increasing\n\nThe function returns true for a valid time grid and false for an invalid time grid. Unless quiet=true, it will log an error to indicated which of the conditions failed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Interfaces.supports_inplace","page":"QuantumPropagators","title":"QuantumPropagators.Interfaces.supports_inplace","text":"Indicate whether a given state or operator supports in-place operations\n\nsupports_inplace(state)\n\nIndicates that propagators can assume that the in-place requirements defined in QuantumPropagators.Interfaces.check_state hold. States with in-place support must also fulfill specific properties when interacting with operators, see QuantumPropagators.Interfaces.check_operator.\n\nsupports_inplace(op)\n\nIndicates that the operator can be evaluated in-place with evaluate!, see QuantumPropagators.Interfaces.check_generator\n\nNote that supports_inplace is not quite the same as Base.ismutable: When using custom structs for states or operators, even if those structs are not defined as mutable, they may still define the in-place interface (typically because their components are mutable).\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagatorsNewtonAPI","page":"QuantumPropagators","title":"QuantumPropagators.Newton","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Public:","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"NewtonWrk\nnewton!","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Private:","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"extend_newton_coeffs!\nextend_leja!","category":"page"},{"location":"api/quantum_propagators/#Reference-9","page":"QuantumPropagators","title":"Reference","text":"","category":"section"},{"location":"api/quantum_propagators/#QuantumPropagators.Newton.NewtonWrk","page":"QuantumPropagators","title":"QuantumPropagators.Newton.NewtonWrk","text":"NewtonWrk(v0, m_max=10)\n\nWorkspace for the Newton-with-restarted-Arnoldi propagation routine.\n\nInitializes the workspace for the propagation of a vector v0, using a maximum Krylov dimension of m_max in each restart iteration. Note that m_max should be smaller than the length of v0.\n\n\n\n\n\n","category":"type"},{"location":"api/quantum_propagators/#QuantumPropagators.Newton.newton!","page":"QuantumPropagators","title":"QuantumPropagators.Newton.newton!","text":"newton!(Ψ, H, dt, wrk; func=(z -> exp(-1im*z)), norm_min=1e-14, relerr=1e-12,\n        max_restarts=50, _...)\n\nEvaluate Ψ = func(H*dt) Ψ using a Newton-with-restarted-Arnoldi scheme.\n\nArguments\n\nΨ: The state to propagate, will be overwritten in-place with the propagated state\nH: Operator acting on Ψ. Together with dt, this is the argument to func\ndt: Implicit time step. Together with H, this is the argument to func\nwkr: Work array, initialized with NewtonWrk\nfunc: The function to apply to H dt, taking a single (scalar) complex-valued argument z in place of H dt. The default func is to evaluate the time evaluations operator for the Schrödinger equation\nnorm_min: the minimum norm at which to consider a state similar to Ψ as zero\nrelerr: The relative error defining the convergence condition for the restart iteration. Propagation stops when the norm of the accumulated Ψ is stable up to the given relative error\nmax_restarts: The maximum number of restart iterations. Exceeding max_restarts will throw an AssertionError.\n\nAll other keyword arguments are ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Newton.extend_newton_coeffs!","page":"QuantumPropagators","title":"QuantumPropagators.Newton.extend_newton_coeffs!","text":"extend_newton_coeffs!(a, n_a, leja, func, n_leja, radius)\n\nExtend the array a of existing Newton coefficients for the expansion of the func from n_a coefficients to n_leja coefficients. Return a new value n_a=n_a+n_leja with the total number of Newton coefficients in the updated a.\n\nArguments\n\na: On input, a zero-based array of length n_a or greater, containing Newton coefficients. On output, array containing a total n_leja coefficients. The array a will be resized if necessary, and may have a length greater than n_leja on output\nn_a:  The number of Newton coefficients in a, on input. Elements of a  beyond the first n_a elements will be overwritten.\nleja: Array of normalized Leja points, containing at least n_leja elements.\nfunc: Function for which to calculate Newton coefficients\nn_leja: The number of elements in leja to use for calculating new coefficients, and the total number of Newton coefficients on output\nradius: Normalization radius for divided differences\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Newton.extend_leja!","page":"QuantumPropagators","title":"QuantumPropagators.Newton.extend_leja!","text":"extend_leja!(leja, n, newpoints, n_use)\n\nGiven an array of n (ordered) Leja points, extract n_use points from newpoints, and append them to the existing Leja points. The array leja should be sufficiently large to hold the new Leja points, which are appended after index n_old. It will be re-allocated if necessary and may have a size of up to 2*(n+n_use).\n\nArguments\n\nleja: Array of Leja values. Must contain the \"old\" Leja values to be kept  in leja(0:n-1). On output, n_use new Leja points will be in  leja(n+:n+n_use-1), for the original value of n.  The leja array must  use zero-based indexing.\nn: On input, number of \"old\" Leja points in leja. On output, total number of Leja points (i.e. n=n+n_use)\nnewpoints: On input, candidate points for new Leja points.  The n_use best values will be chosen and added to leja. On output, the values of new_points are undefined.\nn_use: Number of points that should be added to leja\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagatorsShapesAPI","page":"QuantumPropagators","title":"QuantumPropagators.Shapes","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Public:","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"blackman\nbox\nflattop","category":"page"},{"location":"api/quantum_propagators/#Reference-10","page":"QuantumPropagators","title":"Reference","text":"","category":"section"},{"location":"api/quantum_propagators/#QuantumPropagators.Shapes.blackman","page":"QuantumPropagators","title":"QuantumPropagators.Shapes.blackman","text":"Blackman window shape.\n\nblackman(t, t₀, T; a=0.16)\n\ncalculates\n\nB(t t_0 T) =\n    frac12left(\n        1 - a - cosleft(2π fract - t_0T - t_0right)\n        + a cosleft(4π fract - t_0T - t_0right)\n    right)\n\nfor a scalar t, with a = 0.16.\n\nSee https://en.wikipedia.org/wiki/Window_function#Blackman_windows\n\nA Blackman shape looks nearly identical to a Gaussian with a 6-sigma interval between t₀ and T.  Unlike the Gaussian, however, it will go exactly to zero at the edges. Thus, Blackman pulses are often preferable to Gaussians.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Shapes.box","page":"QuantumPropagators","title":"QuantumPropagators.Shapes.box","text":"Box shape (Theta-function).\n\nbox(t, t₀, T)\n\nevaluates the Heaviside (Theta-) function Theta(t) = 1 for t_0 le t le T; and Theta(t) = 0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Shapes.flattop","page":"QuantumPropagators","title":"QuantumPropagators.Shapes.flattop","text":"Flat shape (amplitude 1.0) with a switch-on/switch-off from zero.\n\nflattop(t; T, t_rise, t₀=0.0, t_fall=t_rise, func=:blackman)\n\nevaluates a shape function that starts at 0 at t=t₀, and ramps to to 1 during the t_rise interval. The function then remains at value 1, before ramping down to 0 again during the interval t_fall before T. For t  t₀ and t  T, the shape is zero.\n\nThe default switch-on/-off shape is half of a Blackman window (see blackman).\n\nFor func=:sinsq, the switch-on/-off shape is a sine-squared curve.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagatorsSpectralRangeAPI","page":"QuantumPropagators","title":"QuantumPropagators.SpectralRange","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Public:","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"specrange","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Private:","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"random_state\nritzvals","category":"page"},{"location":"api/quantum_propagators/#Reference-11","page":"QuantumPropagators","title":"Reference","text":"","category":"section"},{"location":"api/quantum_propagators/#QuantumPropagators.SpectralRange.specrange","page":"QuantumPropagators","title":"QuantumPropagators.SpectralRange.specrange","text":"Calculate the spectral range of a Hamiltonian H on the real axis.\n\nE_min, E_max = specrange(H; method=:auto, kwargs...)\n\ncalculates the approximate lowest and highest eigenvalues of H. Any imaginary part in the eigenvalues is ignored: the routine is intended for (although not strictly limited to) a Hermitian H.\n\nThis delegates to\n\nspecrange(H, method; kwargs...)\n\nfor the different methods.\n\nThe default method=:auto chooses the best method for the given H. This is :diag for small matrices, and :arnoldi otherwise. If both E_min and E_max are given in the kwargs, those will be returned directly (method=:manual).\n\nKeyword arguments not relevant to the underlying implementation will be ignored.\n\n\n\n\n\nE_min, E_max = specrange(\n    H, :arnoldi;\n    rng=Random.GLOBAL_RNG,\n    state=random_state(H; rng),\n    m_min=20,\n    m_max=60,\n    prec=1e-3,\n    norm_min=1e-15,\n    enlarge=true\n)\n\nuses Arnoldi iteration with state as the starting vector. It approximates the eigenvalues of H with between m_min and m_max Ritz values, until the lowest and highest eigenvalue are stable to a relative precision of prec. The norm_min parameter is passed to the underlying arnoldi!.\n\nIf enlarge=true (default) the returned E_min and E_max will be enlarged via a heuristic to slightly over-estimate the spectral radius instead of under-estimating it.\n\n\n\n\n\nE_min, E_max = specrange(H, :diag)\n\nuses exact diagonalization via the standard eigvals function to obtain the smallest and largest eigenvalue. This should only be used for relatively small matrices.\n\n\n\n\n\nE_min, E_max = specrange(H, :manual; E_min, E_max)\n\ndirectly returns the given E_min and E_max without considering H.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.SpectralRange.random_state","page":"QuantumPropagators","title":"QuantumPropagators.SpectralRange.random_state","text":"Random normalized quantum state.\n\n    Ψ = random_state(H; rng=Random.GLOBAL_RNG)\n\nreturns a random normalized state compatible with the Hamiltonian H. This is intended to provide a starting vector for estimating the spectral radius of H via an Arnoldi method.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.SpectralRange.ritzvals","page":"QuantumPropagators","title":"QuantumPropagators.SpectralRange.ritzvals","text":"Calculate a vector for Ritz values converged to a given precision.\n\nR = ritzvals(G, state, m_min, m_max=2*m_min; prec=1e-5, norm_min=1e-15)\n\ncalculates a complex vector R of at least m_min (assuming a sufficient Krylov dimension) and at most m_max Ritz values.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagatorsStorageAPI","page":"QuantumPropagators","title":"QuantumPropagators.Storage","text":"","category":"section"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"Public:","category":"page"},{"location":"api/quantum_propagators/","page":"QuantumPropagators","title":"QuantumPropagators","text":"get_from_storage\nget_from_storage!\ninit_storage\nmap_observable\nmap_observables\nwrite_to_storage!","category":"page"},{"location":"api/quantum_propagators/#Reference-12","page":"QuantumPropagators","title":"Reference","text":"","category":"section"},{"location":"api/quantum_propagators/#QuantumPropagators.Storage.get_from_storage","page":"QuantumPropagators","title":"QuantumPropagators.Storage.get_from_storage","text":"Obtain immutable data from storage.\n\ndata = get_from_storage(storage, i)\n\nSee get_from_storage!.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Storage.get_from_storage!","page":"QuantumPropagators","title":"QuantumPropagators.Storage.get_from_storage!","text":"Obtain data from storage.\n\nget_from_storage!(data, storage, i)\n\nextracts data from the storage for the i'th time slot. Inverse of write_to_storage!. This modifies data in-place. If get_from_storage! is implemented for arbitrary observables, it is the developer's responsibility that init_storage,  write_to_storage!, and get_from_storage! are compatible.\n\nTo extract immutable data, the non-in-place version\n\ndata = get_from_storage(storage, i)\n\ncan be used.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Storage.init_storage","page":"QuantumPropagators","title":"QuantumPropagators.Storage.init_storage","text":"Create a storage array for propagation.\n\nstorage = init_storage(state, tlist)\n\ncreates a storage array suitable for storing a state for each point in tlist.\n\nstorage = init_storage(state, tlist, observables)\n\ncreates a storage array suitable for the data generated by the observables applied to state, see map_observables, for each point in tlist.\n\nstorage = init_storage(data, nt)\n\ncreates a storage arrays suitable for storing data nt times, where nt=length(tlist). By default, this will be a vector of typeof(data) and length nt, or a n × nt Matrix with the same eltype as data if data is a Vector of length n.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Storage.map_observable","page":"QuantumPropagators","title":"QuantumPropagators.Storage.map_observable","text":"Apply a single observable to state.\n\ndata = map_observable(observable, tlist, i, state)\n\nBy default, observable can be one of the following:\n\nA function taking the three arguments state, tlist, i, where state is defined at time tlist[i].\nA function taking a single argument state, under the assumption that the observable is time-independent\nA matrix for which to calculate the expectation value with respect to the vector state.\n\nThe default map_observables delegates to this function.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Storage.map_observables","page":"QuantumPropagators","title":"QuantumPropagators.Storage.map_observables","text":"Obtain \"observable\" data from state.\n\ndata = map_observables(observables, tlist, i, state)\n\ncalculates the data for a tuple of observables applied to state defined at time tlist[i]. For a single observable (tuple of length 1), simply return the result of map_observable.\n\nFor multiple observables, return the tuple resulting from applying map_observable for each observable. If the tuple is \"uniform\" (all elements are of the same type, e.g. if each observable calculates the expectation value of a Hermitian operator), it is converted to a Vector. This allows for compact storage in a storage array, see init_storage.\n\n\n\n\n\n","category":"function"},{"location":"api/quantum_propagators/#QuantumPropagators.Storage.write_to_storage!","page":"QuantumPropagators","title":"QuantumPropagators.Storage.write_to_storage!","text":"Place data into storage for time slot i.\n\nwrite_to_storage!(storage, i, data)\n\nfor a storage array created by init_storage stores the data obtained from map_observables at time slot i.\n\nConceptually, this corresponds roughly to storage[i] = data, but storage may have its own idea on how to store data for a specific time slot. For example, with the default init_storage Vector data will be stored in a matrix, and write_to_storage! will in this case write data to the i'th column of the matrix.\n\nFor a given type of storage and data, it is the developer's responsibility that init_storage and write_to_storage! are compatible.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Control-Methods","page":"Control Methods","title":"Control Methods","text":"","category":"section"},{"location":"methods/","page":"Control Methods","title":"Control Methods","text":"All optimizations in the QuantumControl package are done by calling QuantumControl.optimize, or preferably the high-level wrapper @optimize_or_load. The actual control methods are implemented in separate packages. The module implementing a particular method should be passed to optimize as the method keyword argument.","category":"page"},{"location":"methods/#QuantumControl.optimize-Tuple{ControlProblem}-methods","page":"Control Methods","title":"QuantumControl.optimize","text":"Optimize a quantum control problem.\n\nresult = optimize(\n    problem;\n    method,  # mandatory keyword argument\n    check=true,\n    callback=nothing,\n    print_iters=true,\n    kwargs...\n)\n\noptimizes towards a solution of given problem with the given method, which should be a Module implementing the method, e.g.,\n\nusing Krotov\nresult = optimize(problem; method=Krotov)\n\nIf check is true (default), the initial_state and generator of each trajectory is checked with check_state and check_generator. Any other keyword argument temporarily overrides the corresponding keyword argument in problem. These arguments are available to the optimizer, see each optimization package's documentation for details.\n\nThe callback can be given as a function to be called after each iteration in order to analyze the progress of the optimization or to modify the state of the optimizer or the current controls. The signature of callback is method-specific, but callbacks should receive a workspace objects as the first parameter as the first argument, the iteration number as the second parameter, and then additional method-specific parameters.\n\nThe callback function may return a tuple of values, and an optimization method should store these values fore each iteration in a records field in their Result object. The callback should be called once with an iteration number of 0 before the first iteration. The callback can also be given as a tuple of vector of functions, which are automatically combined via chain_callbacks.\n\nIf print_iters is true (default), an automatic callback is created via the method-specific make_print_iters to print the progress of the optimization after each iteration. This automatic callback runs after any manually given callback.\n\nAll remaining keyword argument are method-specific. To obtain the documentation for which options a particular method uses, run, e.g.,\n\n? optimize(problem, ::Val{:Krotov})\n\nwhere :Krotov is the name of the module implementing the method. The above is also the method signature that a Module wishing to implement a control method must define.\n\nThe returned result object is specific to the optimization method, but should be a subtype of QuantumControl.AbstractOptimizationResult.\n\n\n\n\n\n","category":"method"},{"location":"methods/","page":"Control Methods","title":"Control Methods","text":"The following methods of optimal control are implemented by packages in the JuliaQuantumControl organization:","category":"page"},{"location":"methods/","page":"Control Methods","title":"Control Methods","text":"Pages = [\"methods.md\"]\nDepth = 2:2","category":"page"},{"location":"methods/#Krotov's-Method","page":"Control Methods","title":"Krotov's Method","text":"","category":"section"},{"location":"methods/","page":"Control Methods","title":"Control Methods","text":"See the documentation  of the Krotov package for more details.","category":"page"},{"location":"methods/#QuantumControl.optimize-Tuple{ControlProblem, Val{:Krotov}}-methods","page":"Control Methods","title":"QuantumControl.optimize","text":"using Krotov\nresult = optimize(problem; method=Krotov, kwargs...)\n\noptimizes the given control problem using Krotov's method, by minimizing the functional\n\nJ(ϵ_l(t)) =\n    J_T(Ψ_k(T))\n    + _l int_0^T fracλ_alS_l(t) ϵ_l(t) - ϵ_l^(0)(t)^2  dt\n\ncf. the general form of a quantum control functional. The \"reference field\" ϵ_l^(0)(t) is the guess control for that particular iteration. The above functional implies a first-order update equation\n\nΔϵ_l(t) = fracS_l(t)λ_al Im _k left\nBiglangle\n    chi_k^(0)(t)\nBigvert\n    fracpartial hatH_kpartial ϵ_l(t)\nBigvert\n    Psi_k(t)\nBigrangle\nright\n\nwhere chi^(0)_k(t) is the state backward-propagated under H_k^dagger(ϵ_l^(0)(t)) with the boundary condition chi_k(T) = partial J_T  partial Ψ_k^(0)(T) and H_k is the generator of the k'th trajectory.\n\nNote that the particular control-dependent running cost in the above functional is required to obtain the given Krotov update equation. Other running costs, or state-dependent running costs are not supported in this implementation of Krotov's method (even though some running costs are mathematically compatible with Krotov's method).\n\nReturns a KrotovResult.\n\nKeyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of problem; any of these can be overridden with explicit keyword arguments to optimize.\n\nRequired problem keyword arguments\n\nJ_T: A function J_T(Ψ, trajectories) that evaluates the final time functional from a list Ψ of forward-propagated states and problem.trajectories. The function J_T may also take a keyword argument tau. If it does, a vector containing the complex overlaps of the target states (target_state property of each trajectory in problem.trajectories) with the propagated states will be passed to J_T.\n\nRecommended problem keyword arguments\n\nlambda_a=1.0: The inverse Krotov step width λₐ for every pulse.\nupdate_shape=(t->1.0): A function S(t) for the \"update shape\" that scales the update for every pulse.\n\nIf different controls require different lambda_a or update_shape, a dict pulse_options must be given instead of a global lambda_a and update_shape; see below.\n\nOptional problem keyword arguments\n\nThe following keyword arguments are supported (with default values):\n\npulse_options: A dictionary that maps every control (as obtained by get_controls from the problem.trajectories) to the following dict:\n:lambda_a:  The value for inverse Krotov step width λₐ.\n:update_shape: A function S(t) for the \"update shape\" that scales the Krotov pulse update.\nThis overrides the global lambda_a and update_shape arguments.\nchi: A function chi(Ψ, trajectories) that receives a list Ψ of the forward propagated states and returns a vector of states χₖ = -J_TΨₖ. If not given, it will be automatically determined from J_T via make_chi with the default parameters. Similarly to J_T, if chi accepts a keyword argument tau, it will be passed a vector of complex overlaps.\nsigma=nothing: A function that calculates the second-order contribution. If not given, the first-order Krotov method is used.\niter_start=0: The initial iteration number.\niter_stop=5000: The maximum iteration number.\nprop_method: The propagation method to use for each trajectory; see below.\nprint_iters=true: Whether to print information after each iteration.\nstore_iter_info=Set(): Which fields from print_iters to store in result.records. A subset of Set([\"iter.\", \"J_T\", \"∫gₐ(t)dt\", \"J\", \"ΔJ_T\", \"ΔJ\", \"secs\"]).\ncallback: A function (or tuple of functions) that receives the Krotov workspace, the iteration number, the list of updated pulses, and the list of guess pulses as positional arguments. The function may return a tuple of values which are stored in the KrotovResult object result.records. The function can also mutate any of its arguments, in particular the updated pulses. This may be used, e.g., to apply a spectral filter to the updated pulses or to perform similar manipulations. Note that print_iters=true (default) adds an automatic callback to print information after each iteration. With store_iter_info, that callback automatically stores a subset of the printed information.\ncheck_convergence: A function to check whether convergence has been reached. Receives a KrotovResult object result, and should set result.converged to true and result.message to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with ∘. The convergence check is performed after any callback.\nverbose=false: If true, print information during initialization.\nrethrow_exceptions: By default, any exception ends the optimization but still returns a KrotovResult that captures the message associated with the exception. This is to avoid losing results from a long-running optimization when an exception occurs in a later iteration. If rethrow_exceptions=true, instead of capturing the exception, it will be thrown normally.\n\nTrajectory propagation\n\nKrotov's method involves the forward and backward propagation for every Trajectory in the problem. The keyword arguments for each propagation (see propagate) are determined from any properties of each Trajectory that have a prop_ prefix, cf. init_prop_trajectory.\n\nIn situations where different parameters are required for the forward and backward propagation, instead of the prop_ prefix, the fw_prop_ and bw_prop_ prefixes can be used, respectively. These override any setting with the prop_ prefix. This applies both to the properties of each Trajectory and the problem keyword arguments.\n\nNote that the propagation method for each propagation must be specified. In most cases, it is sufficient (and recommended) to pass a global prop_method problem keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"methods/#GRAPE","page":"Control Methods","title":"GRAPE","text":"","category":"section"},{"location":"methods/","page":"Control Methods","title":"Control Methods","text":"The Gradient Ascent Pulse Engineering (GRAPE) method is implemented in the GRAPE package. See the GRAPE documentation for details.","category":"page"},{"location":"methods/#QuantumControl.optimize-Tuple{ControlProblem, Val{:GRAPE}}-methods","page":"Control Methods","title":"QuantumControl.optimize","text":"using GRAPE\nresult = optimize(problem; method=GRAPE, kwargs...)\n\noptimizes the given control problem via the GRAPE method, by minimizing the functional\n\nJ(ϵ_nl) = J_T(ϕ_k(T)) + λ_a J_a(ϵ_nl)\n\nwhere the final time functional J_T depends explicitly on the forward-propagated states and the running cost J_a depends explicitly on pulse values ϵ_nl of the l'th control discretized on the n'th interval of the time grid.\n\nReturns a GrapeResult.\n\nKeyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of problem; any of these can be overridden with explicit keyword arguments to optimize.\n\nRequired problem keyword arguments\n\nJ_T: A function J_T(Ψ, trajectories) that evaluates the final time functional from a list Ψ of forward-propagated states and problem.trajectories. The function J_T may also take a keyword argument tau. If it does, a vector containing the complex overlaps of the target states (target_state property of each trajectory in problem.trajectories) with the propagated states will be passed to J_T.\n\nOptional problem keyword arguments\n\nchi: A function chi(Ψ, trajectories) that receives a list Ψ of the forward propagated states and returns a vector of states χₖ = -J_TΨₖ. If not given, it will be automatically determined from J_T via QuantumControl.Functionals.make_chi with the default parameters. Similarly to J_T, if chi accepts a keyword argument tau, it will be passed a vector of complex overlaps.\nchi_min_norm=1e-100: The minimum allowable norm for any χₖ(T). Smaller norms would mean that the gradient is zero, and will abort the optimization with an error.\nJ_a: A function J_a(pulsevals, tlist) that evaluates running costs over the pulse values, where pulsevals are the vectorized values ϵ_nl, where n are in indices of the time intervals and l are the indices over the controls, i.e., [ϵ₁₁, ϵ₂₁, …, ϵ₁₂, ϵ₂₂, …] (the pulse values for each control are contiguous). If not given, the optimization will not include a running cost.\ngradient_method=:gradgen: One of :gradgen (default) or :taylor. With gradient_method=:gradgen, the gradient is calculated using QuantumGradientGenerators. With gradient_method=:taylor, it is evaluated via a Taylor series, see Eq. (20) in Kuprov and Rogers,  J. Chem. Phys. 131, 234108 (2009) [17].\ntaylor_grad_max_order=100: If given with gradient_method=:taylor, the maximum number of terms in the Taylor series. If taylor_grad_check_convergence=true (default), if the Taylor series does not convergence within the given number of terms, throw an an error. With taylor_grad_check_convergence=true, this is the exact order of the Taylor series.\ntaylor_grad_tolerance=1e-16: If given with gradient_method=:taylor and taylor_grad_check_convergence=true, stop the Taylor series when the norm of the term falls below the given tolerance. Ignored if taylor_grad_check_convergence=false.\ntaylor_grad_check_convergence=true: If given as true (default), check the convergence after each term in the Taylor series an stop as soon as the norm of the term drops below the given number. If false, stop after exactly taylor_grad_max_order terms.\nlambda_a=1: A weight for the running cost J_a.\ngrad_J_a: A function to calculate the gradient of J_a. If not given, it will be automatically determined. See make_grad_J_a for the required interface.\nupper_bound: An upper bound for the value of any optimized control. Time-dependent upper bounds can be specified via pulse_options.\nlower_bound: A lower bound for the value of any optimized control. Time-dependent lower bounds can be specified via pulse_options.\npulse_options: A dictionary that maps every control (as obtained by get_controls from the problem.trajectories) to a dict with the following possible keys:\n:upper_bounds: A vector of upper bound values, one for each intervals of the time grid. Values of Inf indicate an unconstrained upper bound for that time interval, respectively the global upper_bound, if given.\n:lower_bounds: A vector of lower bound values. Values of -Inf indicate an unconstrained lower bound for that time interval,\nprint_iters=true: Whether to print information after each iteration.\nprint_iter_info=[\"iter.\", \"J_T\", \"|∇J|\", \"|Δϵ|\", \"ΔJ\", \"FG(F)\", \"secs\"]: Which fields to print if print_iters=true. If given, must be a list of header labels (strings), which can be any of the following:\n\"iter.\": The iteration number\n\"J_T\": The value of the final-time functional for the dynamics under the optimized pulses\n\"J_a\": The value of the pulse-dependent running cost for the optimized pulses\n\"λ_a⋅J_a\": The total contribution of J_a to the full functional J\n\"J\": The value of the optimization functional for the optimized pulses\n\"ǁ∇J_Tǁ\": The ℓ²-norm of the current gradient of the final-time functional. Note that this is usually the gradient of the optimize pulse, not the guess pulse.\n\"ǁ∇J_aǁ\": The ℓ²-norm of the the current gradient of the pulse-dependent running cost. For comparison with \"ǁ∇J_Tǁ\".\n\"λ_aǁ∇J_aǁ\": The ℓ²-norm of the the current gradient of the complete pulse-dependent running cost term. For comparison with \"ǁ∇J_Tǁ\".\n\"ǁ∇Jǁ\": The norm of the guess pulse gradient. Note that the guess pulse gradient is not the same the current gradient.\n\"ǁΔϵǁ\":  The ℓ²-norm of the pulse update\n\"ǁϵǁ\": The ℓ²-norm of optimized pulse values\n\"max|Δϵ|\" The maximum value of the pulse update (infinity norm)\n\"max|ϵ|\": The maximum value of the pulse values (infinity norm)\n\"ǁΔϵǁ/ǁϵǁ\": The ratio of the pulse update tothe optimized pulse values\n\"∫Δϵ²dt\": The L²-norm of the pulse update, summed over all pulses. A convergence measure comparable (proportional) to the running cost in Krotov's method\n\"ǁsǁ\": The norm of the search direction. Should be ǁΔϵǁ scaled by the step with α.\n\"∠°\": The angle (in degrees) between the negative gradient -∇J and the search direction s.\n\"α\": The step width as determined by the line search (Δϵ = α⋅s)\n\"ΔJ_T\": The change in the final time functional relative to the previous iteration\n\"ΔJ_a\":  The change in the control-dependent running cost relative to the previous iteration\n\"λ_a⋅ΔJ_a\": The change in the control-dependent running cost term relative to the previous iteration.\n\"ΔJ\":  The change in the total optimization functional relative to the previous iteration.\n\"FG(F)\":  The number of functional/gradient evaluation (FG), or pure functional (F) evaluations\n\"secs\":  The number of seconds of wallclock time spent on the iteration.\nstore_iter_info=[]: Which fields to store in result.records, given as\na list of header labels, see print_iter_info.\ncallback: A function (or tuple of functions) that receives the GRAPE workspace and the iteration number. The function may return a tuple of values which are stored in the GrapeResult object result.records. The function can also mutate the workspace, in particular the updated pulsevals. This may be used, e.g., to apply a spectral filter to the updated pulses or to perform similar manipulations. Note that print_iters=true (default) adds an automatic callback to print information after each iteration. With store_iter_info, that callback automatically stores a subset of the available information.\ncheck_convergence: A function to check whether convergence has been reached. Receives a GrapeResult object result, and should set result.converged to true and result.message to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with ∘. The convergence check is performed after any callback.\nx_tol: Parameter for Optim.jl\nf_tol: Parameter for Optim.jl\ng_tol: Parameter for Optim.jl\nshow_trace: Parameter for Optim.jl\nextended_trace:  Parameter for Optim.jl\nshow_every: Parameter for Optim.jl\nallow_f_increases: Parameter for Optim.jl\noptimizer: An optional Optim.jl optimizer (Optim.AbstractOptimizer instance). If not given, an L-BFGS-B optimizer will be used.\nprop_method: The propagation method to use for each trajectory, see below.\nverbose=false: If true, print information during initialization\nrethrow_exceptions: By default, any exception ends the optimization, but still returns a GrapeResult that captures the message associated with the exception. This is to avoid losing results from a long-running optimization when an exception occurs in a later iteration. If rethrow_exceptions=true, instead of capturing the exception, it will be thrown normally.\n\nTrajectory propagation\n\nGRAPE may involve three types of propagation:\n\nA forward propagation for every Trajectory in the problem\nA backward propagation for every trajectory\nA backward propagation of a gradient generator for every trajectory.\n\nThe keyword arguments for each propagation (see propagate) are determined from any properties of each Trajectory that have a prop_ prefix, cf. init_prop_trajectory.\n\nIn situations where different parameters are required for the forward and backward propagation, instead of the prop_ prefix, the fw_prop_ and bw_prop_ prefix can be used, respectively. These override any setting with the prop_ prefix. Similarly, properties for the backward propagation of the gradient generators can be set with properties that have a grad_prop_ prefix. These prefixes apply both to the properties of each Trajectory and the problem keyword arguments.\n\nNote that the propagation method for each propagation must be specified. In most cases, it is sufficient (and recommended) to pass a global prop_method problem keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"api/quantum_control_index/#API-Index","page":"Index","title":"API Index","text":"","category":"section"},{"location":"api/quantum_control_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"examples/#examples-list","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Krotov-specific-examples","page":"Examples","title":"Krotov-specific examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Optimization of a State-to-State Transfer in a Two-Level-System\nOptimization of a Dissipative Quantum Gate\nPulse Parameterization\nOptimization for a perfect entangler","category":"page"},{"location":"examples/#GRAPE-specific-examples","page":"Examples","title":"GRAPE-specific examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Optimization of a State-to-State Transfer in a Two-Level-System\nOptimization for a perfect entangler","category":"page"},{"location":"glossary/#Glossary","page":"Glossary","title":"Glossary","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"In the context of the JuliaQuantumControl ecosystem, we apply the following nomenclature.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Generator","page":"Glossary","title":"Generator","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Dynamical generator (Hamiltonian / Liouvillian) for the time evolution of a state, i.e., the right-hand-side of the equation of motion (up to a factor of i) such that Ψ(t+dt) = e^-i H dt Ψ(t) in the infinitesimal limit. We use the symbols G, H, or L, depending on the context (general, Hamiltonian, Liouvillian).","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Examples for supported forms a Hamiltonian are the following, from the most general case to simplest and most common case of linear controls,","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"<img src=\"../assets/controlhams.svg\" width=\"80%\"/>","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"In Eq. (G1), H_0 is the Drift Term (which may be zero) and each term under the sum over l is a Control Term. Each control term is a Hamiltonian that depends on a set of control functions (or simply \"controls\"). The controls are the functions directly tunable via optimal control. The control term may also contain an explicit time dependence outside of the controls. This most general form (G1) is supported only via custom user-implemented generator objects, see the documentation of the QuantumPropagators package.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"More commonly, each control term is separable into the Control Amplitude a_l(t) and the Control Operator H_l, as in Eq. (G2). This is the most general form supported by the built-in Generator object, which can be initialized via the hamiltonian or liouvillian functions. The control amplitude a_l(t) depends in turn on one ore more function ϵ_l(t), where each ϵ_l(t) is as Control Function. It may also contain an explicit time dependence.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"In the most common case, a_l  ϵ_l, as in Eq. (G3). The control may further depend on a set of Control Parameters, ϵ_l(t) = ϵ_l(u_n).","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"In an open quantum system, the structure of Eqs. (G1–G3) is the same, but with Liouvillian (super-)operators acting on density matrices instead of Hamiltonians acting on state vectors. See liouvillian with convention=:TDSE.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Operator","page":"Glossary","title":"Operator","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A static, non-time-dependent object that can be multiplied to a state. An operator can be obtained from a time-dependent Generator by plugging in values for the controls and potentially any explicit time dependence. For example, an Operator is obtained from a Generator via QuantumControl.Controls.evaluate.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Drift-Term","page":"Glossary","title":"Drift Term","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A term in the dynamical generator that does not depend on any controls.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Term","page":"Glossary","title":"Control Term","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A term in the dynamical generator that depends on one or more controls.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Function","page":"Glossary","title":"Control Function","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"(aka \"Control\") A function ϵ_l(t) in the Generator that is directly tuned by an optimal control method, either as Pulse values or via Control Parameters.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Field","page":"Glossary","title":"Control Field","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A function that corresponds directly to some kind of physical drive (laser amplitude, microwave pulse, etc.). The term can be ambiguous in that it usually corresponds to the Control Amplitude a(t), but depending on how the control problem is formulated, it can also correspond to the Control Function ϵ(t)","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Operator","page":"Glossary","title":"Control Operator","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"(aka \"control Hamiltonian/Liouvillian\"). The operator H_l in Eqs. (G2, G3). This is a static operator which forms the Control Term together with a Control Amplitude. The control generator is not a well-defined concept in the most general case of non-separable controls terms, Eq. (G1).","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Amplitude","page":"Glossary","title":"Control Amplitude","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The time-dependent coefficient a_l(t) for the Control Operator in Eq. (G2). A control amplitude may depend on on or more control functions, as well as have an explicit time dependency. Some conceptual examples for control amplitudes and how they may depend on a Control Function are the following:","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Non-linear coupling of a control field to the operator, e.g., the quadratic coupling of the laser field to a Stark shift operator\nPulse Parameterization as a way to enforce bounds on a Control Field\nTransfer functions, e.g., to model the response of an electronic device to the optimal control field ϵ(t).\nNoise in the amplitude of the control function\nNon-controllable aspects of the control amplitude, e.g. a \"guided\" control amplitude a_l(t) = R(t) + ϵ_l(t) or a non-controllable envelope S(t) in a_l(t) = S(t) ϵ(t) that ensures switch-on- and switch-off in a CRAB pulse ϵ(t).","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"In Qiskit Dynamics, the \"control amplitude\" is called \"Signal\", see Connecting Qiskit Pulse with Qiskit Dynamics, where a Qiskit \"pulse\" corresponds roughly to our Control Function.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Parameters","page":"Glossary","title":"Control Parameters","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Non-time-dependent parameters that a Control Function depends on, ϵ(t) = ϵ(u_n t). One common parameterization of a control field is as a Pulse, where the control parameters are the amplitude of the field at discrete points of a time grid. Parameterization as a \"pulse\" is implicit in Krotov's method and standard GRAPE.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"More generally, the control parameters could also be spectral coefficients (CRAB) or simple parameters for an analytic pulse shape (e.g., position, width, and amplitude of a Gaussian shape). All optimal control methods find optimized control fields by varying the control parameters.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Pulse","page":"Glossary","title":"Pulse","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"(aka \"control pulse\") A control field discretized to a time grid, usually on the midpoints of the time grid, in a piecewise-constant approximation. Stored as a vector of floating point values. The parameterization of a control field as a \"pulse\" is implicit for Krotov's method and standard GRAPE. One might think of these methods to optimize the control fields directly, but a conceptually cleaner understanding is to think of the discretized \"pulse\" as a vector of control parameters for the time-continuous control field.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Pulse-Parameterization","page":"Glossary","title":"Pulse Parameterization","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A special case of a Control Amplitude where a(t) = a(ϵ(t)) at every point in time. The purpose of this is to constrain the amplitude of the control amplitude a(t). See e.g. QuantumControl.PulseParameterizations.SquareParameterization, where a(t) = ϵ^2(t) to ensure that a(t) is positive. Since Krotov's method inherently has no constraints on the optimized control fields, pulse parameterization is a method of imposing constraints on the amplitude in this context.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Control-Derivative","page":"Glossary","title":"Control Derivative","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The derivative of the dynamical Generator with respect to the control ϵ(t). In the case of linear controls terms in Eq. (G3), the control derivative is the Control Operator coupling to ϵ(t). In general, however, for non-linear control terms, the control derivatives still depends on the control fields and is thus time dependent. We commonly use the symbol μ for the control derivative (reminiscent of the dipole operator)","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Parameter-Derivative","page":"Glossary","title":"Parameter Derivative","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The derivative of a control with respect to a single control parameter. The derivative of the dynamical Generator with respect to that control parameter is then the product of the Control Derivative and the parameter derivative.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/#Gradient","page":"Glossary","title":"Gradient","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The derivative of the optimization functional with respect to all Control Parameters, i.e. the vector of all parameter derivatives.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"note: Note\nThe above nomenclature does not consistently extend throughout the quantum control literature: the terms \"control\"/\"control term\"/\"control Hamiltonian\", and \"control\"/\"control field\"/\"control function\"/\"control pulse\"/\"pulse\" are generally somewhat ambiguous. In particular, the distinction between \"control field\" and \"pulse\" (as a parameterization of the control field in terms of amplitudes on a time grid) here is somewhat artifcial and borrowed from the Krotov Python package. However, the terminology defined in this glossary is consistently applied within the JuliaQuantumControl organization, both in the documentation and in the names of members and methods.","category":"page"},{"location":"api/reference/#API-Reference","page":"Reference","title":"API Reference","text":"","category":"section"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"This page provides all docstrings locally defined in the QuantumControl package for both private and public symbols. See also the summary of the public API.","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"QuantumControl exposes local exported and unexported local symbols as well as re-exporting symbols and sub-modules from the QuantumPropagators subpackage and some of its submodules.","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"The QuantumControl submodules provide additional public functionality. Note that some of the most commonly used symbols from QuantumControl's submodules may also be re-exported at the top-level (such as @optimize_or_load from the QuantumControl.Workflows submodule).","category":"page"},{"location":"api/reference/#quantumcontrol-local-symbols","page":"Reference","title":"Local Exported Symbols","text":"","category":"section"},{"location":"api/reference/#QuantumControl.ControlProblem","page":"Reference","title":"QuantumControl.ControlProblem","text":"A full control problem with multiple trajectories.\n\nControlProblem(\n   trajectories,\n   tlist;\n   kwargs...\n)\n\nThe trajectories are a list of Trajectory instances, each defining an initial state and a dynamical generator for the evolution of that state. Usually, the trajectory will also include a target state (see Trajectory) and possibly a weight. The trajectories may also be given together with tlist as a mandatory keyword argument.\n\nThe tlist is the time grid on which the time evolution of the initial states of each trajectory should be propagated. It may also be given as a (mandatory) keyword argument.\n\nThe remaining kwargs are keyword arguments that are passed directly to the optimal control method. These typically include e.g. the optimization functional.\n\nThe control problem is solved by finding a set of controls that minimize an optimization functional over all trajectories.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#QuantumControl.Trajectory","page":"Reference","title":"QuantumControl.Trajectory","text":"Description of a state's time evolution.\n\nTrajectory(\n    initial_state,\n    generator;\n    target_state=nothing,\n    weight=1.0,\n    kwargs...\n)\n\ndescribes the time evolution of the initial_state under a time-dependent dynamical generator (e.g., a Hamiltonian or Liouvillian).\n\nTrajectories are central to quantum control problems: an optimization functional depends on the result of propagating one or more trajectories. For example, when optimizing for a quantum gate, the optimization considers the trajectories of all logical basis states.\n\nIn addition to the initial_state and generator, a Trajectory may include data relevant to the propagation and to evaluating a particular optimization functional. Most functionals have the notion of a \"target state\" that the initial_state should evolve towards, which can be given as the target_state keyword argument. In some functionals, different trajectories enter with different weights [18], which can be given as a weight keyword argument. Any other keyword arguments are also available to a functional as properties of the Trajectory .\n\nA Trajectory can also be instantiated using all keyword arguments.\n\nProperties\n\nAll keyword arguments used in the instantiation are available as properties of the Trajectory. At a minimum, this includes initial_state, generator, target_state, and weight.\n\nBy convention, properties with a prop_ prefix, e.g., prop_method, will be taken into account when propagating the trajectory. See propagate_trajectory for details.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#QuantumControl.optimize","page":"Reference","title":"QuantumControl.optimize","text":"Optimize a quantum control problem.\n\nresult = optimize(\n    problem;\n    method,  # mandatory keyword argument\n    check=true,\n    callback=nothing,\n    print_iters=true,\n    kwargs...\n)\n\noptimizes towards a solution of given problem with the given method, which should be a Module implementing the method, e.g.,\n\nusing Krotov\nresult = optimize(problem; method=Krotov)\n\nIf check is true (default), the initial_state and generator of each trajectory is checked with check_state and check_generator. Any other keyword argument temporarily overrides the corresponding keyword argument in problem. These arguments are available to the optimizer, see each optimization package's documentation for details.\n\nThe callback can be given as a function to be called after each iteration in order to analyze the progress of the optimization or to modify the state of the optimizer or the current controls. The signature of callback is method-specific, but callbacks should receive a workspace objects as the first parameter as the first argument, the iteration number as the second parameter, and then additional method-specific parameters.\n\nThe callback function may return a tuple of values, and an optimization method should store these values fore each iteration in a records field in their Result object. The callback should be called once with an iteration number of 0 before the first iteration. The callback can also be given as a tuple of vector of functions, which are automatically combined via chain_callbacks.\n\nIf print_iters is true (default), an automatic callback is created via the method-specific make_print_iters to print the progress of the optimization after each iteration. This automatic callback runs after any manually given callback.\n\nAll remaining keyword argument are method-specific. To obtain the documentation for which options a particular method uses, run, e.g.,\n\n? optimize(problem, ::Val{:Krotov})\n\nwhere :Krotov is the name of the module implementing the method. The above is also the method signature that a Module wishing to implement a control method must define.\n\nThe returned result object is specific to the optimization method, but should be a subtype of QuantumControl.AbstractOptimizationResult.\n\n\n\n\n\nusing Krotov\nresult = optimize(problem; method=Krotov, kwargs...)\n\noptimizes the given control problem using Krotov's method, by minimizing the functional\n\nJ(ϵ_l(t)) =\n    J_T(Ψ_k(T))\n    + _l int_0^T fracλ_alS_l(t) ϵ_l(t) - ϵ_l^(0)(t)^2  dt\n\ncf. the general form of a quantum control functional. The \"reference field\" ϵ_l^(0)(t) is the guess control for that particular iteration. The above functional implies a first-order update equation\n\nΔϵ_l(t) = fracS_l(t)λ_al Im _k left\nBiglangle\n    chi_k^(0)(t)\nBigvert\n    fracpartial hatH_kpartial ϵ_l(t)\nBigvert\n    Psi_k(t)\nBigrangle\nright\n\nwhere chi^(0)_k(t) is the state backward-propagated under H_k^dagger(ϵ_l^(0)(t)) with the boundary condition chi_k(T) = partial J_T  partial Ψ_k^(0)(T) and H_k is the generator of the k'th trajectory.\n\nNote that the particular control-dependent running cost in the above functional is required to obtain the given Krotov update equation. Other running costs, or state-dependent running costs are not supported in this implementation of Krotov's method (even though some running costs are mathematically compatible with Krotov's method).\n\nReturns a KrotovResult.\n\nKeyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of problem; any of these can be overridden with explicit keyword arguments to optimize.\n\nRequired problem keyword arguments\n\nJ_T: A function J_T(Ψ, trajectories) that evaluates the final time functional from a list Ψ of forward-propagated states and problem.trajectories. The function J_T may also take a keyword argument tau. If it does, a vector containing the complex overlaps of the target states (target_state property of each trajectory in problem.trajectories) with the propagated states will be passed to J_T.\n\nRecommended problem keyword arguments\n\nlambda_a=1.0: The inverse Krotov step width λₐ for every pulse.\nupdate_shape=(t->1.0): A function S(t) for the \"update shape\" that scales the update for every pulse.\n\nIf different controls require different lambda_a or update_shape, a dict pulse_options must be given instead of a global lambda_a and update_shape; see below.\n\nOptional problem keyword arguments\n\nThe following keyword arguments are supported (with default values):\n\npulse_options: A dictionary that maps every control (as obtained by get_controls from the problem.trajectories) to the following dict:\n:lambda_a:  The value for inverse Krotov step width λₐ.\n:update_shape: A function S(t) for the \"update shape\" that scales the Krotov pulse update.\nThis overrides the global lambda_a and update_shape arguments.\nchi: A function chi(Ψ, trajectories) that receives a list Ψ of the forward propagated states and returns a vector of states χₖ = -J_TΨₖ. If not given, it will be automatically determined from J_T via make_chi with the default parameters. Similarly to J_T, if chi accepts a keyword argument tau, it will be passed a vector of complex overlaps.\nsigma=nothing: A function that calculates the second-order contribution. If not given, the first-order Krotov method is used.\niter_start=0: The initial iteration number.\niter_stop=5000: The maximum iteration number.\nprop_method: The propagation method to use for each trajectory; see below.\nprint_iters=true: Whether to print information after each iteration.\nstore_iter_info=Set(): Which fields from print_iters to store in result.records. A subset of Set([\"iter.\", \"J_T\", \"∫gₐ(t)dt\", \"J\", \"ΔJ_T\", \"ΔJ\", \"secs\"]).\ncallback: A function (or tuple of functions) that receives the Krotov workspace, the iteration number, the list of updated pulses, and the list of guess pulses as positional arguments. The function may return a tuple of values which are stored in the KrotovResult object result.records. The function can also mutate any of its arguments, in particular the updated pulses. This may be used, e.g., to apply a spectral filter to the updated pulses or to perform similar manipulations. Note that print_iters=true (default) adds an automatic callback to print information after each iteration. With store_iter_info, that callback automatically stores a subset of the printed information.\ncheck_convergence: A function to check whether convergence has been reached. Receives a KrotovResult object result, and should set result.converged to true and result.message to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with ∘. The convergence check is performed after any callback.\nverbose=false: If true, print information during initialization.\nrethrow_exceptions: By default, any exception ends the optimization but still returns a KrotovResult that captures the message associated with the exception. This is to avoid losing results from a long-running optimization when an exception occurs in a later iteration. If rethrow_exceptions=true, instead of capturing the exception, it will be thrown normally.\n\nTrajectory propagation\n\nKrotov's method involves the forward and backward propagation for every Trajectory in the problem. The keyword arguments for each propagation (see propagate) are determined from any properties of each Trajectory that have a prop_ prefix, cf. init_prop_trajectory.\n\nIn situations where different parameters are required for the forward and backward propagation, instead of the prop_ prefix, the fw_prop_ and bw_prop_ prefixes can be used, respectively. These override any setting with the prop_ prefix. This applies both to the properties of each Trajectory and the problem keyword arguments.\n\nNote that the propagation method for each propagation must be specified. In most cases, it is sufficient (and recommended) to pass a global prop_method problem keyword argument.\n\n\n\n\n\nusing GRAPE\nresult = optimize(problem; method=GRAPE, kwargs...)\n\noptimizes the given control problem via the GRAPE method, by minimizing the functional\n\nJ(ϵ_nl) = J_T(ϕ_k(T)) + λ_a J_a(ϵ_nl)\n\nwhere the final time functional J_T depends explicitly on the forward-propagated states and the running cost J_a depends explicitly on pulse values ϵ_nl of the l'th control discretized on the n'th interval of the time grid.\n\nReturns a GrapeResult.\n\nKeyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of problem; any of these can be overridden with explicit keyword arguments to optimize.\n\nRequired problem keyword arguments\n\nJ_T: A function J_T(Ψ, trajectories) that evaluates the final time functional from a list Ψ of forward-propagated states and problem.trajectories. The function J_T may also take a keyword argument tau. If it does, a vector containing the complex overlaps of the target states (target_state property of each trajectory in problem.trajectories) with the propagated states will be passed to J_T.\n\nOptional problem keyword arguments\n\nchi: A function chi(Ψ, trajectories) that receives a list Ψ of the forward propagated states and returns a vector of states χₖ = -J_TΨₖ. If not given, it will be automatically determined from J_T via QuantumControl.Functionals.make_chi with the default parameters. Similarly to J_T, if chi accepts a keyword argument tau, it will be passed a vector of complex overlaps.\nchi_min_norm=1e-100: The minimum allowable norm for any χₖ(T). Smaller norms would mean that the gradient is zero, and will abort the optimization with an error.\nJ_a: A function J_a(pulsevals, tlist) that evaluates running costs over the pulse values, where pulsevals are the vectorized values ϵ_nl, where n are in indices of the time intervals and l are the indices over the controls, i.e., [ϵ₁₁, ϵ₂₁, …, ϵ₁₂, ϵ₂₂, …] (the pulse values for each control are contiguous). If not given, the optimization will not include a running cost.\ngradient_method=:gradgen: One of :gradgen (default) or :taylor. With gradient_method=:gradgen, the gradient is calculated using QuantumGradientGenerators. With gradient_method=:taylor, it is evaluated via a Taylor series, see Eq. (20) in Kuprov and Rogers,  J. Chem. Phys. 131, 234108 (2009) [17].\ntaylor_grad_max_order=100: If given with gradient_method=:taylor, the maximum number of terms in the Taylor series. If taylor_grad_check_convergence=true (default), if the Taylor series does not convergence within the given number of terms, throw an an error. With taylor_grad_check_convergence=true, this is the exact order of the Taylor series.\ntaylor_grad_tolerance=1e-16: If given with gradient_method=:taylor and taylor_grad_check_convergence=true, stop the Taylor series when the norm of the term falls below the given tolerance. Ignored if taylor_grad_check_convergence=false.\ntaylor_grad_check_convergence=true: If given as true (default), check the convergence after each term in the Taylor series an stop as soon as the norm of the term drops below the given number. If false, stop after exactly taylor_grad_max_order terms.\nlambda_a=1: A weight for the running cost J_a.\ngrad_J_a: A function to calculate the gradient of J_a. If not given, it will be automatically determined. See make_grad_J_a for the required interface.\nupper_bound: An upper bound for the value of any optimized control. Time-dependent upper bounds can be specified via pulse_options.\nlower_bound: A lower bound for the value of any optimized control. Time-dependent lower bounds can be specified via pulse_options.\npulse_options: A dictionary that maps every control (as obtained by get_controls from the problem.trajectories) to a dict with the following possible keys:\n:upper_bounds: A vector of upper bound values, one for each intervals of the time grid. Values of Inf indicate an unconstrained upper bound for that time interval, respectively the global upper_bound, if given.\n:lower_bounds: A vector of lower bound values. Values of -Inf indicate an unconstrained lower bound for that time interval,\nprint_iters=true: Whether to print information after each iteration.\nprint_iter_info=[\"iter.\", \"J_T\", \"|∇J|\", \"|Δϵ|\", \"ΔJ\", \"FG(F)\", \"secs\"]: Which fields to print if print_iters=true. If given, must be a list of header labels (strings), which can be any of the following:\n\"iter.\": The iteration number\n\"J_T\": The value of the final-time functional for the dynamics under the optimized pulses\n\"J_a\": The value of the pulse-dependent running cost for the optimized pulses\n\"λ_a⋅J_a\": The total contribution of J_a to the full functional J\n\"J\": The value of the optimization functional for the optimized pulses\n\"ǁ∇J_Tǁ\": The ℓ²-norm of the current gradient of the final-time functional. Note that this is usually the gradient of the optimize pulse, not the guess pulse.\n\"ǁ∇J_aǁ\": The ℓ²-norm of the the current gradient of the pulse-dependent running cost. For comparison with \"ǁ∇J_Tǁ\".\n\"λ_aǁ∇J_aǁ\": The ℓ²-norm of the the current gradient of the complete pulse-dependent running cost term. For comparison with \"ǁ∇J_Tǁ\".\n\"ǁ∇Jǁ\": The norm of the guess pulse gradient. Note that the guess pulse gradient is not the same the current gradient.\n\"ǁΔϵǁ\":  The ℓ²-norm of the pulse update\n\"ǁϵǁ\": The ℓ²-norm of optimized pulse values\n\"max|Δϵ|\" The maximum value of the pulse update (infinity norm)\n\"max|ϵ|\": The maximum value of the pulse values (infinity norm)\n\"ǁΔϵǁ/ǁϵǁ\": The ratio of the pulse update tothe optimized pulse values\n\"∫Δϵ²dt\": The L²-norm of the pulse update, summed over all pulses. A convergence measure comparable (proportional) to the running cost in Krotov's method\n\"ǁsǁ\": The norm of the search direction. Should be ǁΔϵǁ scaled by the step with α.\n\"∠°\": The angle (in degrees) between the negative gradient -∇J and the search direction s.\n\"α\": The step width as determined by the line search (Δϵ = α⋅s)\n\"ΔJ_T\": The change in the final time functional relative to the previous iteration\n\"ΔJ_a\":  The change in the control-dependent running cost relative to the previous iteration\n\"λ_a⋅ΔJ_a\": The change in the control-dependent running cost term relative to the previous iteration.\n\"ΔJ\":  The change in the total optimization functional relative to the previous iteration.\n\"FG(F)\":  The number of functional/gradient evaluation (FG), or pure functional (F) evaluations\n\"secs\":  The number of seconds of wallclock time spent on the iteration.\nstore_iter_info=[]: Which fields to store in result.records, given as\na list of header labels, see print_iter_info.\ncallback: A function (or tuple of functions) that receives the GRAPE workspace and the iteration number. The function may return a tuple of values which are stored in the GrapeResult object result.records. The function can also mutate the workspace, in particular the updated pulsevals. This may be used, e.g., to apply a spectral filter to the updated pulses or to perform similar manipulations. Note that print_iters=true (default) adds an automatic callback to print information after each iteration. With store_iter_info, that callback automatically stores a subset of the available information.\ncheck_convergence: A function to check whether convergence has been reached. Receives a GrapeResult object result, and should set result.converged to true and result.message to an appropriate string in case of convergence. Multiple convergence checks can be performed by chaining functions with ∘. The convergence check is performed after any callback.\nx_tol: Parameter for Optim.jl\nf_tol: Parameter for Optim.jl\ng_tol: Parameter for Optim.jl\nshow_trace: Parameter for Optim.jl\nextended_trace:  Parameter for Optim.jl\nshow_every: Parameter for Optim.jl\nallow_f_increases: Parameter for Optim.jl\noptimizer: An optional Optim.jl optimizer (Optim.AbstractOptimizer instance). If not given, an L-BFGS-B optimizer will be used.\nprop_method: The propagation method to use for each trajectory, see below.\nverbose=false: If true, print information during initialization\nrethrow_exceptions: By default, any exception ends the optimization, but still returns a GrapeResult that captures the message associated with the exception. This is to avoid losing results from a long-running optimization when an exception occurs in a later iteration. If rethrow_exceptions=true, instead of capturing the exception, it will be thrown normally.\n\nTrajectory propagation\n\nGRAPE may involve three types of propagation:\n\nA forward propagation for every Trajectory in the problem\nA backward propagation for every trajectory\nA backward propagation of a gradient generator for every trajectory.\n\nThe keyword arguments for each propagation (see propagate) are determined from any properties of each Trajectory that have a prop_ prefix, cf. init_prop_trajectory.\n\nIn situations where different parameters are required for the forward and backward propagation, instead of the prop_ prefix, the fw_prop_ and bw_prop_ prefix can be used, respectively. These override any setting with the prop_ prefix. Similarly, properties for the backward propagation of the gradient generators can be set with properties that have a grad_prop_ prefix. These prefixes apply both to the properties of each Trajectory and the problem keyword arguments.\n\nNote that the propagation method for each propagation must be specified. In most cases, it is sufficient (and recommended) to pass a global prop_method problem keyword argument.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.propagate_trajectories","page":"Reference","title":"QuantumControl.propagate_trajectories","text":"Propagate multiple trajectories in parallel.\n\nresult = propagate_trajectories(\n    trajectories, tlist; use_threads=true, kwargs...\n)\n\nruns propagate_trajectory for every trajectory in trajectories, collects and returns a vector of results. The propagation happens in parallel if use_threads=true (default). All keyword parameters are passed to propagate_trajectory, except that if initial_state is given, it must be a vector of initial states, one for each trajectory. Likewise, to pass pre-allocated storage arrays to storage, a vector of storage arrays must be passed. A simple storage=true will still work to return a vector of storage results.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.propagate_trajectory","page":"Reference","title":"QuantumControl.propagate_trajectory","text":"Propagate a Trajectory.\n\npropagate_trajectory(\n    traj,\n    tlist;\n    initial_state=traj.initial_state,\n    kwargs...\n)\n\npropagates initial_state under the dynamics described by traj.generator. It takes the same keyword arguments as QuantumPropagators.propagate, with default values from any property of traj with a prop_ prefix (prop_method, prop_inplace, prop_callback, …). See init_prop_trajectory for details.\n\nNote that method (a mandatory keyword argument in QuantumPropagators.propagate) must be specified, either as a property prop_method of the trajectory, or by passing a method keyword argument explicitly.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#quantumcontrol-local-unexported-symbols","page":"Reference","title":"Local Unexported Symbols","text":"","category":"section"},{"location":"api/reference/#QuantumControl.set_default_ad_framework","page":"Reference","title":"QuantumControl.set_default_ad_framework","text":"Set the default provider for automatic differentiation.\n\nQuantumControl.set_default_ad_framework(mod; quiet=false)\n\nregisters the given module (package) as the default AD framework.\n\nThis determines the default setting for the automatic parameter in the following functions:\n\nQuantumControl.Functionals.make_chi\nQuantumControl.Functionals.make_gate_chi\nQuantumControl.Functionals.make_grad_J_a\n\nThe given mod must be a supported AD framework, e.g.,\n\nimport Zygote\nQuantumControl.set_default_ad_framework(Zygote)\n\nCurrently, there is built-in support for Zygote and FiniteDifferences.\n\nFor other packages to be used as the default AD framework, the appropriate methods for make_chi etc. must be defined.\n\nUnless quiet=true, calling set_default_ad_framework will show a message to confirm the setting.\n\nTo unset the default AD framework, use\n\nQuantumControl.set_default_ad_framework(nothing)\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.AbstractOptimizationResult","page":"Reference","title":"QuantumControl.AbstractOptimizationResult","text":"Abstract type for the result object returned by optimize. Any optimization method implemented on top of QuantumControl should subtype from AbstractOptimizationResult. This enables conversion between the results of different methods, allowing one method to continue an optimization from another method.\n\nIn order for this to work seamlessly, result objects should use a common set of field names as much as a possible. When a result object requires fields that cannot be provided by all other result objects, it should have default values for these field, which can be defined in a custom Base.convert method, as, e.g.,\n\nfunction Base.convert(::Type{MyResult}, result::AbstractOptimizationResult)\n    defaults = Dict{Symbol,Any}(\n        :f_calls => 0,\n        :fg_calls => 0,\n    )\n    return convert(MyResult, result, defaults)\nend\n\nWhere f_calls and fg_calls are fields of MyResult that are not present in a given result of a different type. The three-argument convert is defined internally for any AbstractOptimizationResult.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"gdeftgttexttgt gdeftroperatornametr gdefReoperatornameRe gdefImoperatornameIm","category":"page"},{"location":"api/reference/#quantumcontrol-submodules","page":"Reference","title":"List of Submodules","text":"","category":"section"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"QuantumControl has the following sub-modules:","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"QuantumControl.Amplitudes\nQuantumControl.Controls\nQuantumControl.Functionals\nQuantumControl.Generators\nQuantumControl.Interfaces\nQuantumControl.PulseParameterizations\nQuantumControl.Shapes\nQuantumControl.Storage\nQuantumControl.Workflows","category":"page"},{"location":"api/reference/#QuantumControlAmplitudesLocalAPI","page":"Reference","title":"QuantumControl.Amplitudes","text":"","category":"section"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"Re-exported Symbols:","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"LockedAmplitude\nShapedAmplitude","category":"page"},{"location":"api/reference/#QuantumControlControlsLocalAPI","page":"Reference","title":"QuantumControl.Controls","text":"","category":"section"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"Public Symbols:","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"get_control_deriv\nget_control_derivs","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"Re-exported Symbols:","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"ParameterizedFunction\ndiscretize\ndiscretize_on_midpoints\nevaluate\nevaluate!\nget_controls\nget_parameters\nget_tlist_midpoints\nsubstitute\nt_mid","category":"page"},{"location":"api/reference/#Public-Symbols","page":"Reference","title":"Public Symbols","text":"","category":"section"},{"location":"api/reference/#QuantumControl.Controls.get_control_deriv","page":"Reference","title":"QuantumControl.Controls.get_control_deriv","text":"Get the derivative of the generator G w.r.t. the control ϵ(t).\n\nμ  = get_control_deriv(generator, control)\n\nreturns nothing if the generator (Hamiltonian or Liouvillian) does not depend on control, or a generator\n\nμ = fracGϵ(t)\n\notherwise. For linear control terms, μ will be a static operator, e.g. an AbstractMatrix or an Operator. For non-linear controls, μ will be time-dependent, e.g. a Generator. In either case, evaluate should be used to evaluate μ into a constant operator for particular values of the controls and a particular point in time.\n\nFor constant generators, e.g. an Operator, the result is always nothing.\n\n\n\n\n\na = get_control_deriv(ampl, control)\n\nreturns the derivative a_l(t)ϵ_l(t) of the given amplitude a_l(ϵ_l(t) t) with respect to the given control ϵ_l(t). For \"trivial\" amplitudes, where a_l(t)  ϵ_l(t), the result with be either 1.0 or 0.0 (depending on whether ampl ≡ control). For non-trivial amplitudes, the result may be another amplitude that depends on the controls and potentially on time, but can be evaluated to a constant with evaluate.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Controls.get_control_derivs","page":"Reference","title":"QuantumControl.Controls.get_control_derivs","text":"Get a vector of the derivatives of generator w.r.t. each control.\n\nget_control_derivs(generator, controls)\n\nreturn as vector containing the derivative of generator with respect to each control in controls. The elements of the vector are either nothing if generator does not depend on that particular control, or a function μ(α) that evaluates the derivative for a particular value of the control, see get_control_deriv.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControlFunctionalsLocalAPI","page":"Reference","title":"QuantumControl.Functionals","text":"","category":"section"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"Public Symbols:","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"J_T_re\nJ_T_sm\nJ_T_ss\nJ_a_fluence\ngate_functional\nmake_chi\nmake_gate_chi\nmake_grad_J_a","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"Private Symbols:","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"F_re\nf_tau\nF_ss\ngrad_J_a_fluence\nchi_sm\nF_sm\ntaus!\ntaus\nchi_re\nchi_ss","category":"page"},{"location":"api/reference/#Public-Symbols-2","page":"Reference","title":"Public Symbols","text":"","category":"section"},{"location":"api/reference/#QuantumControl.Functionals.J_T_re","page":"Reference","title":"QuantumControl.Functionals.J_T_re","text":"Real-part functional.\n\nJ_T_re(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)\n\ncalculates\n\nJ_Ttextre = 1 - F_textre quadin begincases\n    0 2  textin Hilbert space \n    0 1  textin Liouville space\nendcases\n\nAll arguments are passed to f_tau while evaluating F_textre in F_re.\n\nReference\n\n[12] Palao and Kosloff,  Phys. Rev. A 68, 062308 (2003)\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Functionals.J_T_sm","page":"Reference","title":"QuantumControl.Functionals.J_T_sm","text":"Square-modulus functional.\n\nJ_T_sm(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)\n\ncalculates\n\nJ_Ttextsm = 1 - F_textsm quadin 0 1\n\nAll arguments are passed to f_tau while evaluating F_textsm in F_sm.\n\nReference\n\n[12] Palao and Kosloff,  Phys. Rev. A 68, 062308 (2003)\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Functionals.J_T_ss","page":"Reference","title":"QuantumControl.Functionals.J_T_ss","text":"State-to-state phase-insensitive functional.\n\nJ_T_ss(Ψ, trajectories; tau=taus(Ψ, trajectories); τ=tau)\n\ncalculates\n\nJ_Ttextss = 1 - F_textss in 0 1\n\nAll arguments are passed to F_ss.\n\nReference\n\n[12] Palao and Kosloff,  Phys. Rev. A 68, 062308 (2003)\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Functionals.J_a_fluence","page":"Reference","title":"QuantumControl.Functionals.J_a_fluence","text":"Running cost for the pulse fluence.\n\nJ_a = J_a_fluence(pulsevals, tlist)\n\ncalculates\n\nJ_a = sum_l int_0^T ϵ_l(t)^2 dt = left(sum_nl ϵ_nl^2 right) dt\n\nwhere ϵ_nl are the values in the (vectorized) pulsevals, n is the index of the intervals of the time grid, and dt is the time step, taken from the first time interval of tlist and assumed to be uniform.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Functionals.gate_functional","page":"Reference","title":"QuantumControl.Functionals.gate_functional","text":"Convert a functional from acting on a gate to acting on propagated states.\n\nJ_T = gate_functional(J_T_U; kwargs...)\n\nconstructs a functional J_T that meets the requirements for for Krotov/GRAPE and make_chi. That is, the output J_T takes positional positional arguments Ψ and trajectories. The input functional J_T_U is assumed to have the signature J_T_U(U; kwargs...) where U is a matrix with elements U_ij = Ψ_iΨ_j, where Ψ_i is the initial_state of the i'th trajectories (assumed to be the i'th canonical basis state) and Ψ_j is the result of forward-propagating Ψ_j. That is, U is the projection of the time evolution operator into the subspace defined by the basis in the initial_states of the  trajectories.\n\nSee also\n\nmake_gate_chi — create a corresponding chi function that acts more efficiently than the general make_chi.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Functionals.make_chi","page":"Reference","title":"QuantumControl.Functionals.make_chi","text":"Return a function that calculates χ_k = -J_TΨ_k.\n\nchi = make_chi(\n    J_T,\n    trajectories;\n    mode=:any,\n    automatic=:default,\n    via=(any(isnothing(t.target_state) for t in trajectories) ? :states : :tau),\n)\n\ncreates a function chi(Ψ, trajectories; τ) that returns a vector of states χ with χ_k = -J_TΨ_k, where Ψ_k is the k'th element of Ψ. These are the states used as the boundary condition for the backward propagation propagation in Krotov's method and GRAPE. Each χₖ is defined as a matrix calculus Wirtinger derivative,\n\nχ_k(T) = -fracJ_TΨ_k = -frac12 _Ψ_k J_Tqquad\n_Ψ_k J_T  fracJ_TReΨ_k + i fracJ_TImΨ_k\n\nThe function J_T must take a vector of states Ψ and a vector of trajectories as positional parameters. If via=:tau, it must also a vector tau as a keyword argument, see e.g. J_T_sm). that contains the overlap of the states Ψ with the target states from the trajectories\n\nThe derivative can be calculated analytically of automatically (via automatic differentiation) depending on the value of mode. For mode=:any, an analytic derivative is returned if available, with a fallback to an automatic derivative.\n\nIf mode=:analytic, return an analytically known -J_TΨ_k, e.g.,\n\nQuantumControl.Functionals.J_T_sm → QuantumControl.Functionals.chi_sm,\nQuantumControl.Functionals.J_T_re → QuantumControl.Functionals.chi_re,\nQuantumControl.Functionals.J_T_ss → QuantumControl.Functionals.chi_ss.\n\nand throw an error if no analytic derivative is known.\n\nIf mode=:automatic, return an automatic derivative (even if an analytic derivative is known). The calculation of an automatic derivative  (whether via mode=:any or mode=:automatic) requires that a suitable framework (e.g., Zygote or FiniteDifferences) has been loaded. The loaded module must be passed as automatic keyword argument. Alternatively, it can be registered as a default value for automatic by calling QuantumControl.set_default_ad_framework.\n\nWhen evaluating χ_k automatically, if via=:states is given , χ_k(T) is calculated directly as defined above from the gradient with respect to the states Ψ_k(T).\n\nIf via=:tau is given instead, the functional J_T is considered a function of overlaps τ_k = Ψ_k^tgtΨ_k(T). This requires that all trajectories define a target_state and that J_T calculates the value of the functional solely based on the values of tau passed as a keyword argument.  With only the complex conjugate τ_k = Ψ_k(T)Ψ_k^tgt having an explicit dependency on Ψ_k(T),  the chain rule in this case is\n\nχ_k(T)\n= -fracJ_TΨ_k\n= -left(\n    fracJ_Tτ_k\n    fracτ_kΨ_k\n  right)\n= - frac12 (_τ_k J_T) Ψ_k^tgt\n\nAgain, we have used the definition of the Wirtinger derivatives,\n\nbeginalign*\n    fracJ_Tτ_k\n     frac12left(\n        frac J_T Reτ_k\n        - i frac J_T Imτ_k\n    right)\n    fracJ_Tτ_k\n     frac12left(\n        frac J_T Reτ_k\n        + i frac J_T Imτ_k\n    right)\nendalign*\n\nand the definition of the Zygote gradient with respect to a complex scalar,\n\n_τ_k J_T = left(\n    frac J_T Reτ_k\n    + i frac J_T Imτ_k\nright)\n\ntip: Tip\nIn order to extend make_chi with an analytic implementation for a new J_T function, define a new method make_analytic_chi like so:QuantumControl.Functionals.make_analytic_chi(::typeof(J_T_sm), trajectories) = chi_smwhich links make_chi for QuantumControl.Functionals.J_T_sm to QuantumControl.Functionals.chi_sm.\n\nwarning: Warning\nZygote is notorious for being buggy (silently returning incorrect gradients). Always test automatic derivatives against finite differences and/or other automatic differentiation frameworks.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Functionals.make_gate_chi","page":"Reference","title":"QuantumControl.Functionals.make_gate_chi","text":"Return a function to evaluate χ_k = -J_T(U)Ψ_k via the chain rule.\n\nchi = make_gate_chi(J_T_U, trajectories; automatic=:default, kwargs...)\n\nreturns a function equivalent to\n\nchi = make_chi(\n    gate_functional(J_T_U; kwargs...),\n    trajectories;\n    mode=:automatic,\n    automatic,\n)\n\nbeginsplit\n    χ_k\n    = -fracΨ_k J_T \n    = - frac12 sum_i (_U J_T)_ik frac U_ikΨ_k \n    = - frac12 sum_i (_U J_T)_ik Ψ_i\nendsplit\n\nwhere Ψ_i is the basis state stored as the initial_state of the i'th trajectory, see gate_functional.\n\nThe gradient _U J_T is obtained via automatic differentiation (AD). This requires that an AD package has been loaded (e.g., using Zygote). This package must either be passed as the automatic keyword argument, or the package must be set as the default AD provider using QuantumControl.set_default_ad_framework.\n\nCompared to the more general make_chi with mode=:automatic, make_gate_chi will generally have a slightly smaller numerical overhead, as it pushes the use of automatic differentiation down by one level.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Functionals.make_grad_J_a","page":"Reference","title":"QuantumControl.Functionals.make_grad_J_a","text":"Return a function to evaluate J_aϵ_ln for a pulse value running cost.\n\ngrad_J_a = make_grad_J_a(\n    J_a,\n    tlist;\n    mode=:any,\n    automatic=:default,\n)\n\nreturns a function so that ∇J_a = grad_J_a(pulsevals, tlist) sets that returns a vector ∇J_a containing the vectorized elements J_aϵ_ln. The function J_a must have the interface J_a(pulsevals, tlist), see, e.g., J_a_fluence.\n\nThe parameters mode and automatic are handled as in make_chi, where mode is one of :any, :analytic, :automatic, and automatic is he loaded module of an automatic differentiation framework, where :default refers to the framework set with QuantumControl.set_default_ad_framework.\n\ntip: Tip\nIn order to extend make_grad_J_a with an analytic implementation for a new J_a function, define a new method make_analytic_grad_J_a like so:make_analytic_grad_J_a(::typeof(J_a_fluence), tlist) = grad_J_a_fluencewhich links make_grad_J_a for J_a_fluence to grad_J_a_fluence.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#Private-Symbols","page":"Reference","title":"Private Symbols","text":"","category":"section"},{"location":"api/reference/#QuantumControl.Functionals.F_re","page":"Reference","title":"QuantumControl.Functionals.F_re","text":"Real-part fidelity.\n\nF_re(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)\n\ncalculates\n\nF_textre\n    = Ref_τ\n    = Releft\n        frac1N sum_k=1^N w_k τ_k\n    right\n    quadin begincases\n    -1 1  textin Hilbert space \n    0 1  textin Liouville space\nendcases\n\nwith w_k the weight for the k'th trajectory and τ_k the overlap of the k'th propagated state with the k'th target state, and N the number of trajectories.\n\nAll arguments are passed to f_tau to evaluate f_τ.\n\nReference\n\n[12] Palao and Kosloff,  Phys. Rev. A 68, 062308 (2003)\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Functionals.f_tau","page":"Reference","title":"QuantumControl.Functionals.f_tau","text":"Average complex overlap of the target states with forward-propagated states.\n\nf_tau(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)\n\ncalculates\n\nf_τ = frac1N sum_k=1^N w_k τ_k\n\nwith\n\nτ_k = Ψ_k^tgtΨ_k(T)\n\nin Hilbert space, or\n\nτ_k = trρ_k^tgtdagger ρ_k(T)\n\nin Liouville space, where Ψ_k or ρ_k are the elements of Ψ, and Ψ_k^tgt or ρ_k^tgt are the target states from the target_state field of the trajectories. If tau/τ is given as a keyword argument, it must contain the values τ_k according to the above definition. Otherwise, the τ_k values will be calculated internally, see taus.\n\nN is the number of trajectories, and w_k is the weight attribute for each trajectory. The weights are not automatically normalized, they are assumed to have values such that the resulting f_τ lies in the unit circle of the complex plane. Usually, this means that the weights should sum to N.\n\nReference\n\n[12] Palao and Kosloff,  Phys. Rev. A 68, 062308 (2003)\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Functionals.F_ss","page":"Reference","title":"QuantumControl.Functionals.F_ss","text":"State-to-state phase-insensitive fidelity.\n\nF_ss(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)\n\ncalculates\n\nF_textss = frac1N sum_k=1^N w_k τ_k^2 quadin 0 1\n\nwith N, w_k and τ_k as in f_tau.\n\nReference\n\n[12] Palao and Kosloff,  Phys. Rev. A 68, 062308 (2003)\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Functionals.grad_J_a_fluence","page":"Reference","title":"QuantumControl.Functionals.grad_J_a_fluence","text":"Analytic derivative for J_a_fluence.\n\n∇J_a = grad_J_a_fluence(pulsevals, tlist)\n\nreturns the ∇J_a, which contains the (vectorized) elements 2 ϵ_nl dt, where ϵ_nl are the (vectorized) elements of pulsevals and dt is the time step, taken from the first time interval of tlist and assumed to be uniform.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Functionals.chi_sm","page":"Reference","title":"QuantumControl.Functionals.chi_sm","text":"Backward boundary states χ for functional J_T_sm.\n\nχ = chi_sm(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)\n\ncalculates the vector of states χ according to\n\nχ_k\n= -fracpartial J_Ttextsmpartial Ψ_k(T)\n= frac1N^2 w_k sum_j^N w_j τ_j Ψ_k^tgt\n\nwith Ψ^tgt_k, τ_j and w_k as defined in f_tau.\n\nNote: this function can be obtained with make_chi(J_T_sm, trajectories).\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Functionals.F_sm","page":"Reference","title":"QuantumControl.Functionals.F_sm","text":"Square-modulus fidelity.\n\nF_sm(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)\n\ncalculates\n\nF_textsm\n    = f_τ^2\n    = leftvertfrac1N sum_k=1^N w_k τ_krightvert^2\n    = frac1N^2 sum_k=1^N sum_j=1^N w_k w_j τ_k τ_j\n    quadin 0 1\n\nwith w_k the weight for the k'th trajectory and τ_k the overlap of the k'th propagated state with the k'th target state, τ_k the complex conjugate of τ_k, and N the number of trajectories.\n\nAll arguments are passed to f_tau to evaluate f_τ.\n\nReference\n\n[12] Palao and Kosloff,  Phys. Rev. A 68, 062308 (2003)\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Functionals.taus!","page":"Reference","title":"QuantumControl.Functionals.taus!","text":"Overlaps of target states with propagates states, calculated in-place.\n\ntaus!(τ, Ψ, trajectories; ignore_missing_target_state=false)\n\noverwrites the complex vector τ with the results of taus(Ψ, trajectories).\n\nThrows an ArgumentError if any of trajectories have a target_state of nothing. If ignore_missing_target_state=true, values in τ instead will remain unchanged for any trajectories with a missing target state.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Functionals.taus","page":"Reference","title":"QuantumControl.Functionals.taus","text":"Overlaps of target states with propagates states\n\nτ = taus(Ψ, trajectories)\n\ncalculates a vector of values τ_k = Ψ_k^tgtΨ_k where Ψ_k^tgt is the traj.target_state of the k'th element of trajectories and Ψₖ is the k'th element of Ψ.\n\nThe definition of the τ values with Ψ_k^tgt on the left (overlap of target states with propagated states, as opposed to overlap of propagated states with target states) matches Refs. [12] and [19].\n\nThe function requires that each trajectory defines a target state. See also taus! for an in-place version that includes well-defined error handling for any trajectories whose target_state property is nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Functionals.chi_re","page":"Reference","title":"QuantumControl.Functionals.chi_re","text":"Backward boundary states χ for functional J_T_re.\n\nχ chi_re(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)\n\ncalculates the vector of states χ according to\n\nχ_k\n= -frac J_Ttextre Ψ_k(T)\n= frac12N w_k Ψ^tgt_k\n\nwith Ψ^tgt_k and w_k as defined in f_tau.\n\nNote: this function can be obtained with make_chi(J_T_re, trajectories).\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Functionals.chi_ss","page":"Reference","title":"QuantumControl.Functionals.chi_ss","text":"Backward boundary states χ for functional J_T_ss.\n\nχ = chi_ss(Ψ, trajectories; tau=taus(Ψ, trajectories), τ=tau)\n\ncalculates the vector of states χ according to\n\nχ_k\n= -frac J_Ttextss Ψ_k(T)\n= frac1N w_k τ_k Ψ^tgt_k\n\nwith Ψ^tgt_k, τ_k and w_k as defined in f_tau.\n\nNote: this function can be obtained with make_chi(J_T_ss, trajectories).\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControlGeneratorsLocalAPI","page":"Reference","title":"QuantumControl.Generators","text":"","category":"section"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"Re-exported Symbols:","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"Generator\nOperator\nScaledOperator\nhamiltonian\nliouvillian","category":"page"},{"location":"api/reference/#QuantumControlInterfacesLocalAPI","page":"Reference","title":"QuantumControl.Interfaces","text":"","category":"section"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"Public Symbols:","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"check_amplitude\ncheck_generator","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"Re-exported Symbols:","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"check_control\ncheck_operator\ncheck_parameterized\ncheck_parameterized_function\ncheck_state\nsupports_inplace","category":"page"},{"location":"api/reference/#Public-Symbols-3","page":"Reference","title":"Public Symbols","text":"","category":"section"},{"location":"api/reference/#QuantumControl.Interfaces.check_amplitude","page":"Reference","title":"QuantumControl.Interfaces.check_amplitude","text":"Check an amplitude in a Generator in the context of optimal control.\n\n@test check_amplitude(\n    ampl; tlist, for_gradient_optimization=true, quiet=false\n)\n\nverifies that the given ampl is a valid element in the list of amplitudes of a Generator object. This checks all the conditions of QuantumPropagators.Interfaces.check_amplitude. In addition, the following conditions must be met.\n\nIf for_gradient_optimization:\n\nThe function get_control_deriv(ampl, control) must be defined\nIf ampl does not depend on control, get_control_deriv(ampl, control) must return 0.0\nIf ampl depends on control, u = get_control_deriv(ampl, control) must return an object u so that evaluate(u, tlist, n) returns a Number. In most cases, u itself will be a Number. For more unusual amplitudes, e.g., an amplitude with a non-linear dependency on the controls, u may be another amplitude. The controls in u (as obtained by QuantumPropagators.Controls.get_controls) must be a subset of the controls in ampl.\n\nThe function returns true for a valid amplitude and false for an invalid amplitude. Unless quiet=true, it will log an error to indicate which of the conditions failed.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Interfaces.check_generator","page":"Reference","title":"QuantumControl.Interfaces.check_generator","text":"Check the dynamical generator in the context of optimal control.\n\n@test check_generator(\n    generator; state, tlist,\n    for_expval=true, for_pwc=true, for_time_continuous=false,\n    for_parameterization=false, for_gradient_optimization=true,\n    atol=1e-15, quiet=false\n)\n\nverifies the given generator. This checks all the conditions of QuantumPropagators.Interfaces.check_generator. In addition, the following conditions must be met.\n\nIf for_gradient_optimization:\n\nget_control_derivs(generator, controls) must be defined and return a vector containing the result of get_control_deriv(generator, control) for every control in controls.\nget_control_deriv(generator, control) must return an object that passes the less restrictive QuantumPropagators.Interfaces.check_generator if control is in get_controls(generator). The controls in the derivative (if any) must be a subset of the controls in generator.\nget_control_deriv(generator, control) must return nothing if control is not in get_controls(generator)\nIf generator is a Generator instance, every ampl in generator.amplitudes must pass check_amplitude(ampl; tlist).\n\nThe function returns true for a valid generator and false for an invalid generator. Unless quiet=true, it will log an error to indicate which of the conditions failed.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControlPulseParameterizationsLocalAPI","page":"Reference","title":"QuantumControl.PulseParameterizations","text":"","category":"section"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"Public Symbols:","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"LogisticParameterization\nLogisticSqParameterization\nParameterizedAmplitude\nSquareParameterization\nTanhParameterization\nTanhSqParameterization","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"Private Symbols:","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"PulseParameterization","category":"page"},{"location":"api/reference/#Public-Symbols-4","page":"Reference","title":"Public Symbols","text":"","category":"section"},{"location":"api/reference/#QuantumControl.PulseParameterizations.LogisticParameterization","page":"Reference","title":"QuantumControl.PulseParameterizations.LogisticParameterization","text":"Parameterization with a Logistic function that enforces a_min < a(t) < a_max.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.PulseParameterizations.LogisticSqParameterization","page":"Reference","title":"QuantumControl.PulseParameterizations.LogisticSqParameterization","text":"Parameterization with a Logistic-Square function that enforces 0 ≤ a(t) < a_max.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.PulseParameterizations.ParameterizedAmplitude","page":"Reference","title":"QuantumControl.PulseParameterizations.ParameterizedAmplitude","text":"An amplitude determined by a pulse parameterization.\n\nThat is, a(t) = a(ϵ(t)) with a bijective mapping between the value of a(t) and ϵ(t), e.g. a(t) = ϵ^2(t) (a SquareParameterization). Optionally, the amplitude may be multiplied with an additional shape function, cf. ShapedAmplitude.\n\nampl = ParameterizedAmplitude(control; parameterization)\n\ninitializes a(t) = a(ϵ(t) where ϵ(t) is the control, and the mandatory keyword argument parameterization is a PulseParameterization. The control must either be a vector of values discretized to the midpoints of a time grid, or a callable control(t).\n\nampl = ParameterizedAmplitude(control; parameterization, shape=shape)\n\ninitializes a(t) = S(t) a(ϵ(t)) where S(t) is the given shape. It must be a vector if control is a vector, or a callable shape(t) if control is a callable.\n\nampl = ParameterizedAmplitude(control, tlist; parameterization, shape=shape)\n\ndiscretizes control and shape (if given) to the midpoints of tlist before initialization.\n\nampl = ParameterizedAmplitude(\n    amplitude, tlist; parameterization, shape=shape, parameterize=true\n)\n\ninitializes a(t) = S(t) a(t) where a(t) is the input amplitude. First, if amplitude is a callable amplitude(t), it is discretized to the midpoints of tlist. Then, a control ϵ(t) is calculated so that a(t)  a(ϵ(t)). Clippling may occur if the values in amplitude cannot represented with the given parameterization. Lastly, ParameterizedAmplitude(control; parameterization, shape) is initialized with the calculated control.\n\nNote that the tlist keyword argument is required when parameterize=true is given, even if amplitude is already a vector.\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#QuantumControl.PulseParameterizations.SquareParameterization","page":"Reference","title":"QuantumControl.PulseParameterizations.SquareParameterization","text":"Parameterization a(t) = ϵ²(t), enforcing pulse values a(t)  0.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.PulseParameterizations.TanhParameterization","page":"Reference","title":"QuantumControl.PulseParameterizations.TanhParameterization","text":"Parameterization with a tanh function that enforces a_min < a(t) < a_max.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.PulseParameterizations.TanhSqParameterization","page":"Reference","title":"QuantumControl.PulseParameterizations.TanhSqParameterization","text":"Parameterization with a tanh² function that enforces 0 ≤ a(t) < a_max.\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#Private-Symbols-2","page":"Reference","title":"Private Symbols","text":"","category":"section"},{"location":"api/reference/#QuantumControl.PulseParameterizations.PulseParameterization","page":"Reference","title":"QuantumControl.PulseParameterizations.PulseParameterization","text":"Specification for a \"time-local\" pulse parameterization.\n\nThe parameterization is given as a collection of three functions:\n\na(ϵ(t))\nϵ(a(t))\naϵ as a function of ϵ(t).\n\n\n\n\n\n","category":"type"},{"location":"api/reference/#QuantumControlShapesLocalAPI","page":"Reference","title":"QuantumControl.Shapes","text":"","category":"section"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"Re-exported Symbols:","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"blackman\nbox\nflattop","category":"page"},{"location":"api/reference/#QuantumControlStorageLocalAPI","page":"Reference","title":"QuantumControl.Storage","text":"","category":"section"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"Re-exported Symbols:","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"get_from_storage\nget_from_storage!\ninit_storage\nmap_observable\nmap_observables\nwrite_to_storage!","category":"page"},{"location":"api/reference/#QuantumControlWorkflowsLocalAPI","page":"Reference","title":"QuantumControl.Workflows","text":"","category":"section"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"Public Symbols:","category":"page"},{"location":"api/reference/","page":"Reference","title":"Reference","text":"@optimize_or_load\nload_optimization\nrun_or_load\nsave_optimization","category":"page"},{"location":"api/reference/#Public-Symbols-5","page":"Reference","title":"Public Symbols","text":"","category":"section"},{"location":"api/reference/#QuantumControl.Workflows.@optimize_or_load","page":"Reference","title":"QuantumControl.Workflows.@optimize_or_load","text":"Run optimize and store the result, or load the result if it exists.\n\nresult = @optimize_or_load(\n    file,\n    problem;\n    method,\n    force=false,\n    verbose=true,\n    metadata=nothing,\n    logfile=nothing,\n    kwargs...\n)\n\nruns result = optimize(problem; method, kwargs...) and stores result in file in the JLD2 format. Note that the method keyword argument is mandatory.\n\nIn addition to the result, the data in the output file can also contain metadata. By default, this is \"script\" with the file name and line number of where @optimize_or_load was called, as well as data from the dict metadata mapping arbitrary (string) keys to values. Lastly, the data contains truncated captured output (up to 1kB of both the beginning and end of the output) from the optimization.\n\nIf logfile is given as the path to a file, both stdout and stderr from optimize are redirected into the given file.\n\nIf file already exists (and force=false), load the result from that file instead of running the optimization, and print any (truncated) captured output.\n\nAll other kwargs are passed directly to optimize.\n\nFor methods that support this, @optimize_or_load will set up a callback to dump the optimization result to file in case of an unexpected program shutdown, see set_atexit_save_optimization.\n\nRelated Functions\n\nrun_or_load  — a function for more general long-running calculations.\nload_optimization: Function to load a file produced by @optimize_or_load\n\n\n\n\n\n","category":"macro"},{"location":"api/reference/#QuantumControl.Workflows.load_optimization","page":"Reference","title":"QuantumControl.Workflows.load_optimization","text":"Load a previously stored optimization.\n\nresult = load_optimization(file; verbose=false, kwargs...)\n\nrecovers a result previously stored by @optimize_or_load or save_optimization.\n\nresult, metadata = load_optimization(file; return_metadata=true, kwargs...)\n\nalso obtains a metadata dict, see @optimize_or_load. This dict maps string keys to values.\n\nCalling load_optimization with verbose=true will @info the metadata after loading the file\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Workflows.run_or_load","page":"Reference","title":"QuantumControl.Workflows.run_or_load","text":"Run some code and write the result to file, or load from the file if it exists.\n\ndata = run_or_load(\n    file;\n    save=(endswith(file, \".jld2\") ? JLD2.save_object : FileIO.save),\n    load=(endswith(file, \".jld2\") ? JLD2.load_object : FileIO.load),\n    force=false,\n    verbose=true,\n    kwargs...\n) do\n    data = Dict()  # ...  # something that can be saved to / loaded from file\n    return data\nend\n\nruns the code in the block and stores data in the given file. If file already exists, skip running the code and instead return the data in file.\n\nIf force is True, run the code whether or not file exists, potentially overwriting it.\n\nWith verbose=true, information about the status of file will be shown as @info.\n\nThe data returned by the code block must be compatible with the format of file and the save/load functions. When using JLD2.save_object and JLD2.load_object, almost any data can be written, so this should be particularly safe. More generally, when using FileIO.save and FileIO.load, see the FileIO registry for details. A common examples would be a DataFrame being written to a .csv file.\n\nSee also\n\n@optimize_or_load — for wrapping around optimize\nDrWatson.@produce_or_load — a similar but more opinionated function with automatic naming\n\n\n\n\n\n","category":"function"},{"location":"api/reference/#QuantumControl.Workflows.save_optimization","page":"Reference","title":"QuantumControl.Workflows.save_optimization","text":"Write an optimization result to file.\n\nsave_optimization(file, result; metadata=nothing)\n\nwrites the result obtained from a call to optimize to the given file in JLD2 format. If given, metadata is a dict of additional data that will be stored with the result. The metadata dict should use strings as keys.\n\nSee also\n\nload_optimization: Function to load a file produced by @optimize_or_load or save_optimization\n@optimize_or_load: Run optimize and save_optimization in one go.\n\n\n\n\n\n","category":"function"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"This page describes the API of the QuantumControl package by outlining the general procedure for defining and solving quantum control problems. See the API for a detailed reference.","category":"page"},{"location":"overview/#Setting-up-control-problems","page":"Overview","title":"Setting up control problems","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Quantum control problems are described by instantiating ControlProblem. Remember that a quantum control problem aims to find control parameters in the dynamical generators (Hamiltonians, Liouvillians) of a quantum system to steer the dynamics of the system in some desired way. The dynamics of system are probed by one or more quantum states, each with its particular dynamical generator, which we encode as a Trajectory object.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"To determine how well the system dynamics meet the desired behavior, a Trajectory can have additional properties that are taken into account in the optimization functional. Most commonly, this is represented by a target_state property of the Trajectory. The objective is fulfilled when the control parameters are chosen such that the initial state of each Trajectory evolves into the target state, on the time grid given as tlist in the ControlProblem.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"A control problem with a single such trajectory already encodes the common state-to-state problem, e.g., to initialize a system into an entangled state, or to control a chemical reaction. However, there are many control problems that require simultaneously solving more than one trajectory. For example, finding the control parameters that implement a two-qubit quantum gate O on a quantum computer naturally translates to four simultaneous trajectories, one for each two-qubit basis state: 00  O 00, 01  O 01, 10  O 10, 00  O 11. By virtue of the linearity of Hilbert space, finding a simultaneous solution to these four trajectories means the any state Ψ will then evolve as Ψ  O Ψ.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Some optimal control frameworks treat the optimization of quantum gates by numerically evolving the gate itself, U(t=0) = I  O(t=T). This is perfectly compatible with our framework: we can have a single trajectory for an initial \"state\" U with a target \"state\" O. However, this approach does not scale well numerically when the logical subspace of the two-qubit gate is embedded in a significantly larger physical Hilbert space: U is quadratically larger than Ψ. Moreover, the various methods implemented in the QuantumControl package are inherently parallel with respect to multiple trajectories. This is why we emphasize the formulation of the control problem in terms of multiple simultaneous trajectories.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Sometimes, some of the trajectories may be more important than others. In this case, the Trajectory can be instantiated with a weight attribute. There are also situations where the notion of a \"target state\" is not meaningful. Coming back to the example of two-qubit quantum gates, one may wish to maximize the entangling power of the quantum gate, without requiring a specific gate. We extract the information about the entangling power of the dynamical generator by tracking the time evolution of a set of states (the Bell basis, as it happens), but there is no meaningful notion of a \"target state\". In this example, an Trajectory may be instantiated without the target_state attribute, i.e., containing only the initial_state and the generator. These are the minimal required attributes for any optimization.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Mathematically, the control problem is solved by minimizing a functional that is calculated from the time-propagated trajectory states. By convention, this functional is passed as a keyword argument J_T when instantiating the ControlProblem. Standard functionals are defined in the QuantumControl.Functionals module. Depending on the control method, there can be additional options. See the documentation of the various methods implementing optimize for the options required or supported by the different solvers. All of these options can be passed as keyword arguments when instantiating the ControlProblem[1], or they can be passed later to optimize/@optimize_or_load.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"[1]: The solvers that ship with QuantumControl ignore options they do not know about. So when setting up a ControlProblem it is safe to pass a superset of options for different optimization methods.","category":"page"},{"location":"overview/#Controls-and-control-parameters","page":"Overview","title":"Controls and control parameters","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The controls that the QuantumControl package optimizes are implicit in the dynamical generator (hamiltonian, liouvillian) of the Trajectories in the ControlProblem.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The QuantumControl.Controls.get_controls method extracts the controls from the trajectories. Each control is typically time-dependent, e.g., a function ϵ(t) or a vector of pulse values on a time grid. For each control, QuantumControl.Controls.discretize and QuantumControl.Controls.discretize_on_midpoints discretizes the control to an existing time grid. For controls that are implemented through some custom type, these methods must be defined to enable piecewise-constant time propagation or an optimization that assumes piecewise-constant control (most notably, Krotov's method). See QuantumControl.Interfaces.check_control for the full interface required of a control.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"See also the section on Dynamical Generators in the QuantumPropagators documentation and QuantumControl.Interfaces.check_generator for details on how generators and controls relate.","category":"page"},{"location":"overview/#Time-propagation","page":"Overview","title":"Time propagation","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The QuantumControl package uses (and includes) QuantumPropagators.jl as the numerical back-end for simulating the time evolution of all quantum states. The main high-level function provided from that package is propagate, which simulates the dynamics of a quantum state over an entire time grid. In the context of a ControlProblem consisting of one or more Trajectory, there is also a propagate_trajectory function that provides a more convenient interface, automatically using the initial state and the dynamical generator from the trajectory.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"A very typical overall workflow is to set up the control problem, then propagate the trajectories with the guess control to see how the system behaves, run the optimization, and then propagate the trajectories again with the optimized controls, to verify the success of the optimization. For plugging in the optimized controls, QuantumControl.Controls.substitute can be used.","category":"page"},{"location":"overview/#Optimization","page":"Overview","title":"Optimization","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The most direct way to solve a ControlProblem is with the optimize routine. It has a mandatory method argument that then delegates the optimization to the appropriate sub-package implementing that method.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"However, if the optimization takes more than a few minutes to complete, you should use @optimize_or_load instead of just optimize. This routine runs the optimization and then writes the result to file. When called again, it will then simply load the result instead of rerunning the optimization. The @optimize_or_load also embeds some metadata in the output file, including (by default) the commit hash of the project repository containing the script that called @optimize_or_load and the filename of the script and line number where the call was made.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The output file written by @optimize_or_load can be read via the load_optimization function. This can recover both the optimization result and the metadata.","category":"page"},{"location":"api/quantum_control/#QuantumControlAPI","page":"QuantumControl","title":"QuantumControl Public API","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"This page summarizes the public API of the QuantumControl package. See also the Index of all symbols.","category":"page"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl exports the following symbols:","category":"page"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"ControlProblem\nTrajectory\noptimize\npropagate_trajectories\npropagate_trajectory","category":"page"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"and re-exports the following symbols either from its own submodules or from QuantumPropagators:","category":"page"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"@optimize_or_load\nPropagation\nhamiltonian\ninit_prop\nliouvillian\nload_optimization\nprop_step!\npropagate\npropagate_sequence\nreinit_prop!\nrun_or_load\nsave_optimization","category":"page"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"It also defines the following public, but unexported functions:","category":"page"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl.set_default_ad_framework","category":"page"},{"location":"api/quantum_control/#public_submodules","page":"QuantumControl","title":"Submodules","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"Each of the following submodules defines their own public API. Note that some of these submodules are re-exported from or extend submodules of QuantumPropagators.","category":"page"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl.Amplitudes\nQuantumControl.Controls\nQuantumControl.Functionals\nQuantumControl.Generators\nQuantumControl.Interfaces\nQuantumControl.PulseParameterizations\nQuantumControl.Shapes\nQuantumControl.Storage\nQuantumControl.Workflows","category":"page"},{"location":"api/quantum_control/#QuantumControlAmplitudesAPI","page":"QuantumControl","title":"QuantumControl.Amplitudes","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl.Amplitudes.LockedAmplitude\nQuantumControl.Amplitudes.ShapedAmplitude","category":"page"},{"location":"api/quantum_control/#QuantumControlControlsAPI","page":"QuantumControl","title":"QuantumControl.Controls","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl.Controls.ParameterizedFunction\nQuantumControl.Controls.discretize\nQuantumControl.Controls.discretize_on_midpoints\nQuantumControl.Controls.evaluate\nQuantumControl.Controls.evaluate!\nQuantumControl.Controls.get_control_deriv\nQuantumControl.Controls.get_control_derivs\nQuantumControl.Controls.get_controls\nQuantumControl.Controls.get_parameters\nQuantumControl.Controls.get_tlist_midpoints\nQuantumControl.Controls.substitute\nQuantumControl.Controls.t_mid","category":"page"},{"location":"api/quantum_control/#QuantumControlFunctionalsAPI","page":"QuantumControl","title":"QuantumControl.Functionals","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl.Functionals.J_T_re\nQuantumControl.Functionals.J_T_sm\nQuantumControl.Functionals.J_T_ss\nQuantumControl.Functionals.J_a_fluence\nQuantumControl.Functionals.gate_functional\nQuantumControl.Functionals.make_chi\nQuantumControl.Functionals.make_gate_chi\nQuantumControl.Functionals.make_grad_J_a","category":"page"},{"location":"api/quantum_control/#QuantumControlGeneratorsAPI","page":"QuantumControl","title":"QuantumControl.Generators","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl.Generators.Generator\nQuantumControl.Generators.Operator\nQuantumControl.Generators.ScaledOperator\nQuantumControl.Generators.hamiltonian\nQuantumControl.Generators.liouvillian","category":"page"},{"location":"api/quantum_control/#QuantumControlInterfacesAPI","page":"QuantumControl","title":"QuantumControl.Interfaces","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl.Interfaces.check_amplitude\nQuantumControl.Interfaces.check_control\nQuantumControl.Interfaces.check_generator\nQuantumControl.Interfaces.check_operator\nQuantumControl.Interfaces.check_parameterized\nQuantumControl.Interfaces.check_parameterized_function\nQuantumControl.Interfaces.check_state\nQuantumControl.Interfaces.supports_inplace","category":"page"},{"location":"api/quantum_control/#QuantumControlPulseParameterizationsAPI","page":"QuantumControl","title":"QuantumControl.PulseParameterizations","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl.PulseParameterizations.LogisticParameterization\nQuantumControl.PulseParameterizations.LogisticSqParameterization\nQuantumControl.PulseParameterizations.ParameterizedAmplitude\nQuantumControl.PulseParameterizations.SquareParameterization\nQuantumControl.PulseParameterizations.TanhParameterization\nQuantumControl.PulseParameterizations.TanhSqParameterization","category":"page"},{"location":"api/quantum_control/#QuantumControlShapesAPI","page":"QuantumControl","title":"QuantumControl.Shapes","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl.Shapes.blackman\nQuantumControl.Shapes.box\nQuantumControl.Shapes.flattop","category":"page"},{"location":"api/quantum_control/#QuantumControlStorageAPI","page":"QuantumControl","title":"QuantumControl.Storage","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl.Storage.get_from_storage\nQuantumControl.Storage.get_from_storage!\nQuantumControl.Storage.init_storage\nQuantumControl.Storage.map_observable\nQuantumControl.Storage.map_observables\nQuantumControl.Storage.write_to_storage!","category":"page"},{"location":"api/quantum_control/#QuantumControlWorkflowsAPI","page":"QuantumControl","title":"QuantumControl.Workflows","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl.Workflows.@optimize_or_load\nQuantumControl.Workflows.load_optimization\nQuantumControl.Workflows.run_or_load\nQuantumControl.Workflows.save_optimization","category":"page"},{"location":"api/quantum_control/#Subpackages","page":"QuantumControl","title":"Subpackages","text":"","category":"section"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumControl contains the following sub-packages from the JuliaQuantumControl organization:","category":"page"},{"location":"api/quantum_control/","page":"QuantumControl","title":"QuantumControl","text":"QuantumPropagators","category":"page"},{"location":"#QuantumControl.jl","page":"Home","title":"QuantumControl.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nusing Pkg\n\nVERSION = Pkg.dependencies()[Base.UUID(\"8a270532-f23f-47a8-83a9-b33d10cad486\")].version\n\ngithub_badge = \"[![Github](https://img.shields.io/badge/JuliaQuantumControl-QuantumControl.jl-blue.svg?logo=github)](https://github.com/JuliaQuantumControl/QuantumControl.jl)\"\n\nversion_badge = \"![v$VERSION](https://img.shields.io/badge/version-v$VERSION-green.svg)\"\n\nMarkdown.parse(\"$github_badge $version_badge\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"QuantumControl.jl is a Julia framework for quantum dynamics and control.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quantum optimal control [1–8] attempts to steer a quantum system in some desired way by finding optimal control parameters or control fields inside the system Hamiltonian or Liouvillian. Typical control tasks are the preparation of a specific quantum state or the realization of a logical gate in a quantum computer (\"pulse level control\"). Thus, quantum control theory is a critical part of realizing quantum technologies at the lowest level. Numerical methods of open-loop quantum control (methods that do not involve measurement feedback from a physical quantum device) such as Krotov's method [9–14] and GRAPE [15, 16] address the control problem by simulating the dynamics of the system and then iteratively improving the value of a functional that encodes the desired outcome.","category":"page"},{"location":"#Functional","page":"Home","title":"Functional","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mathematically, the control problem is the minimization of a functional of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"J(ϵ_l(t))\n    = J_T(Ψ_k(T))\n    + λ_a  underbrace_l int_0^T g_a(ϵ_l(t))  dt_=J_a(ϵ_l(t))\n    + λ_b  underbrace_k int_0^T g_b(Ψ_k(t))  dt_=J_b(Ψ_k(t))","category":"page"},{"location":"","page":"Home","title":"Home","text":"where ϵ_l(t) is a set of control functions defined between the initial time t=0 and the final time t=T, and Ψ_k(t) is a set of \"trajectories\" evolving from a set of initial states Psi_k(t=0) under the controls ϵ_l(t). The full functional consists of the final-time functional J_T, a control-dependent running cost J_a weighted by λ_a, and sometimes a state-dependent running cost J_b weighted by λ_b. The states can be Hilbert space vectors or density matrices, and the equation of motion is implicit, typically the Schrödinger or Liouville equation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The QuantumControl.jl package provides a single coherent API for solving the quantum control problem with the packages in the JuliaQuantumControl organization. Different optimization methods target specific variants of the above functional.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the installation instructions on Github.\nLook at a simple example for a state-to-state transition with GRAPE to get a feeling for how the QuantumControl package is intended to be used, or look at the larger list of Examples.\nRead the Glossary and Overview to understand the philosophy of the framework.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"glossary.md\",\n    \"overview.md\",\n    \"methods.md\",\n    \"howto.md\",\n]\nDepth = 2","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"examples/index.md\",\n]","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"api/quantum_control.md\",\n]\nDepth = 1","category":"page"},{"location":"#Sub-Packages","page":"Home","title":"Sub-Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"api/quantum_propagators.md\",\n]\nDepth = 1","category":"page"},{"location":"#History","page":"Home","title":"History","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Releases on Github.","category":"page"}]
}
